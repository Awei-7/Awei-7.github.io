<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>八股文</title>
      <link href="/2024/05/23/%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2024/05/23/%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="一、java基础篇"><a href="#一、java基础篇" class="headerlink" title="一、java基础篇"></a>一、java基础篇</h1><h2 id="1-接口和抽象类的区别"><a href="#1-接口和抽象类的区别" class="headerlink" title="1.  接口和抽象类的区别"></a>1.  接口和抽象类的区别</h2><p>相似点：</p><p>（1）接口和抽象类都不能被实例化</p><p>（2）实现接口或继承抽象类的普通子类都必须实现这些抽象方法</p><p>不同点：</p><p>（1）抽象类可以包含普通方法和代码块，接口里只能包含抽象方法，静态方法和默认方法，</p><p>（2）抽象类可以有构造方法，而接口没有</p><p>（3）抽象类中的成员变量可以是各种类型的，接口的成员变量只能是 public static final 类型的，并且必须赋值</p><h2 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.  重载和重写的区别"></a>2.  重载和重写的区别</h2><p>重载发生在同一个类中，方法名相同、参数列表、返回类型、权限修饰符可以不同</p><p>重写发生在子类中，方法名相、参数列表、返回类型都相同，权限修饰符要大于父类方法，声明异常范围要小于父类方法，但是final和private修饰的方法不可重写</p><h2 id="3-equals和-的区别"><a href="#3-equals和-的区别" class="headerlink" title="3.  equals和&#x3D;&#x3D;的区别"></a>3.  equals和&#x3D;&#x3D;的区别</h2><p>&#x3D;&#x3D;比较基本类型，比较的是值，&#x3D;&#x3D;比较引用类型，比较的是内存地址</p><p>equlas是Object类的方法，本质上与&#x3D;&#x3D;一样，但是有些类重写了equals方法，比如String的equals被重写后，比较的是字符值，另外重写了equlas后，也必须重写hashcode()方法</p><h2 id="4-异常处理机制"><a href="#4-异常处理机制" class="headerlink" title="4.  异常处理机制"></a>4.  异常处理机制</h2><p>（1）使用try、catch、finaly捕获异常，finaly中的代码一定会执行，捕获异常后程序会继续执行</p><p>（2）使用throws声明该方法可能会抛出的异常类型，出现异常后，程序终止</p><h2 id="5-HashMap原理"><a href="#5-HashMap原理" class="headerlink" title="5.  HashMap原理"></a>5.  HashMap原理</h2><p>(1).HashMap在Jdk1.8以后是基于数组+链表+红黑树来实现的，特点是，key不能重复，可以为null，线程不安全</p><p>(2).HashMap的扩容机制：</p><p>HashMap的默认容量为16，默认的负载因子为0.75，当HashMap中元素个数超过容量乘以负载因子的个数时，就创建一个大小为前一次两倍的新数组，再将原来数组中的数据复制到新数组中。当数组长度到达64且链表长度大于8时，链表转为红黑树</p><p>(3).HashMap存取原理：</p><p>1）计算key的hash值，然后进行二次hash，根据二次hash结果找到对应的索引位置</p><p>2）如果这个位置有值，先进性equals比较，若结果为true则取代该元素，若结果为false，就使用高低位平移法将节点插入链表（JDK8以前使用头插法，但是头插法在并发扩容时可能会造成环形链表或数据丢失，而高低位平移发会发生数据覆盖的情况）</p><h2 id="6-想要线程安全的HashMap怎么办？"><a href="#6-想要线程安全的HashMap怎么办？" class="headerlink" title="6.  想要线程安全的HashMap怎么办？"></a>6.  想要线程安全的HashMap怎么办？</h2><p>（1）使用ConcurrentHashMap</p><p>（2）使用HashTable</p><p>（3）Collections.synchronizedHashMap()方法</p><h2 id="7-ConcurrentHashMap原如何保证的线程安全？"><a href="#7-ConcurrentHashMap原如何保证的线程安全？" class="headerlink" title="7.  ConcurrentHashMap原如何保证的线程安全？"></a>7.  ConcurrentHashMap原如何保证的线程安全？</h2><p>JDK1.7:使用分段锁，将一个Map分为了16个段，每个段都是一个小的hashmap，每次操作只对其中一个段加锁</p><p>JDK1.8:采用CAS+Synchronized保证线程安全，每次插入数据时判断在当前数组下标是否是第一次插入，是就通过CAS方式插入，然后判断f.hash是否&#x3D;-1，是的话就说明其他线程正在进行扩容，当前线程也会参与扩容；删除方法用了synchronized修饰，保证并发下移除元素安全</p><h2 id="8-HashTable与HashMap的区别"><a href="#8-HashTable与HashMap的区别" class="headerlink" title="8.  HashTable与HashMap的区别"></a>8.  HashTable与HashMap的区别</h2><p>（1）HashTable的每个方法都用synchronized修饰，因此是线程安全的，但同时读写效率很低</p><p>（2）HashTable的Key不允许为null</p><p>（3）HashTable只对key进行一次hash，HashMap进行了两次Hash</p><p>（4）HashTable底层使用的数组加链表</p><h2 id="9-ArrayList和LinkedList的区别"><a href="#9-ArrayList和LinkedList的区别" class="headerlink" title="9.  ArrayList和LinkedList的区别"></a>9.  ArrayList和LinkedList的区别</h2><p> ArratList的底层使用动态数组，默认容量为10，当元素数量到达容量时，生成一个新的数组，大小为前一次的1.5倍，然后将原来的数组copy过来；因为数组在内存中是连续的地址，所以ArrayList查找数据更快，由于扩容机制添加数据效率更低</p><p>LinkedList的底层使用链表，在内存中是离散的，没有扩容机制；LinkedList在查找数据时需要从头遍历，所以查找慢，但是添加数据效率更高</p><h2 id="10-如何保证ArrayList的线程安全？"><a href="#10-如何保证ArrayList的线程安全？" class="headerlink" title="10. 如何保证ArrayList的线程安全？"></a>10. 如何保证ArrayList的线程安全？</h2><p>（1）使用collentions.synchronizedList（）方法为ArrayList加锁</p><p>（2）使用Vector，Vector底层与Arraylist相同，但是每个方法都由synchronized修饰，速度很慢</p><p>（3）使用juc下的CopyOnWriterArrayList，该类实现了读操作不加锁，写操作时为list创建一个副本，期间其它线程读取的都是原本list，写操作都在副本中进行，写入完成后，再将指针指向副本。</p><h2 id="11-String、StringBuffer、StringBuilder的区别"><a href="#11-String、StringBuffer、StringBuilder的区别" class="headerlink" title="11. String、StringBuffer、StringBuilder的区别"></a>11. String、StringBuffer、StringBuilder的区别</h2><p>String 由 char[] 数组构成，使用了 final 修饰，对 String 进行改变时每次都会新生成一个 String 对象，然后把指针指向新的引用对象。</p><p>StringBuffer可变并且线程安全</p><p>StringBuiler可变但线程不安全。</p><p>操作少量字符数据用 String；单线程操作大量数据用 StringBuilder；多线程操作大量数据用 StringBuffer。</p><h2 id="12-hashCode和equals"><a href="#12-hashCode和equals" class="headerlink" title="12. hashCode和equals"></a>12. hashCode和equals</h2><p> hashCode()和equals()都是Obkect类的方法，hashCode()默认是通过地址来计算hash码，但是可能被重写过用内容来计算hash码，equals()默认通过地址判断两个对象是否相等，但是可能被重写用内容来比较两个对象</p><p>所以两个对象相等，他们的hashCode和equals一定相等，但是hashCode相等的两个对象未必相等</p><p>如果重写equals()必须重写hashCode()，比如在HashMap中，key如果是String类型，String如果只重写了equals（）而没有重写hashcode（）的话，则两个equals()比较为true的key，因为hashcode不同导致两个key没有出现在一个索引上，就会出现map中存在两个相同的key</p><h2 id="13-面向对象和面向过程的区别"><a href="#13-面向对象和面向过程的区别" class="headerlink" title="13. 面向对象和面向过程的区别"></a>13. 面向对象和面向过程的区别</h2><p>面向对象有封装、继承、多态性的特性，所以相比面向过程易维护、易复用、易扩展，但是因为类调用时要实例化，所以开销大性能比面向过程低</p><h2 id="14-深拷贝和浅拷贝"><a href="#14-深拷贝和浅拷贝" class="headerlink" title="14.深拷贝和浅拷贝"></a>14.深拷贝和浅拷贝</h2><p>浅拷贝:浅拷贝只复制某个对象的引用，而不复制对象本身，新旧对象还是共享同一块内存</p><p>深拷贝:深拷贝会创造一个一摸一样的对象，新对象和原对象不共享内存，修改新对象不会改变原对对象。</p><h2 id="14-多态的作用"><a href="#14-多态的作用" class="headerlink" title="14. 多态的作用"></a>14. 多态的作用</h2><p>多态的实现要有继承、重写，父类引用指向子类对象。它的好处是可以消除类型之间的耦合关系，增加类的可扩充性和灵活性。</p><h2 id="15-什么是反射？"><a href="#15-什么是反射？" class="headerlink" title="15. 什么是反射？"></a>15. 什么是反射？</h2><p>反射是通过获取类的class对象，然后动态的获取到这个类的内部结构，动态的去操作类的属性和方法。</p><p>应用场景有：要操作权限不够的类属性和方法时、实现自定义注解时、动态加载第三方jar包时、按需加载类，节省编译和初始化时间；</p><p>获取class对象的方法有：class.forName(类路径)，类.class()，对象的getClass（）</p><h2 id="16-Java创建对象得五种方式"><a href="#16-Java创建对象得五种方式" class="headerlink" title="16. Java创建对象得五种方式?"></a>16. Java创建对象得五种方式?</h2><p>(1)new关键字  (2)Class.newInstance (3)Constructor.newInstance</p><p>(4)Clone方法  (5)反序列化</p><h1 id="二-Java多线程篇"><a href="#二-Java多线程篇" class="headerlink" title="二.Java多线程篇"></a>二.Java多线程篇</h1><h2 id="1-进程和线程的区别，进程间如何通信"><a href="#1-进程和线程的区别，进程间如何通信" class="headerlink" title="1.  进程和线程的区别，进程间如何通信"></a>1.  进程和线程的区别，进程间如何通信</h2><p>进程：系统运行的基本单位，进程在运行过程中都是相互独立，但是线程之间运行可以相互影响。</p><p>线程：独立运行的最小单位，一个进程包含多个线程且它们共享同一进程内的系统资源</p><p>进程间通过管道、 共享内存、信号量机制、消息队列通信</p><h2 id="2-什么是线程上下文切换"><a href="#2-什么是线程上下文切换" class="headerlink" title="2.  什么是线程上下文切换"></a>2.  什么是线程上下文切换</h2><p>当一个线程被剥夺cpu使用权时，切换到另外一个线程执行</p><h2 id="3-什么是死锁"><a href="#3-什么是死锁" class="headerlink" title="3.  什么是死锁"></a>3.  什么是死锁</h2><p>死锁指多个线程在执行过程中，因争夺资源造成的一种相互等待的僵局</p><h2 id="4-死锁的必要条件"><a href="#4-死锁的必要条件" class="headerlink" title="4.  死锁的必要条件"></a>4.  死锁的必要条件</h2><p>互斥条件：同一资源同时只能由一个线程读取</p><p>不可抢占条件：不能强行剥夺线程占有的资源</p><p>请求和保持条件：请求其他资源的同时对自己手中的资源保持不放</p><p>循环等待条件：在相互等待资源的过程中，形成一个闭环</p><p>想要预防死锁，只需要破坏其中一个条件即可，比如使用定时锁、尽量让线程用相同的加锁顺序，还可以用银行家算法可以预防死锁</p><h2 id="5-Synchrpnized和lock的区别"><a href="#5-Synchrpnized和lock的区别" class="headerlink" title="5.  Synchrpnized和lock的区别"></a>5.  Synchrpnized和lock的区别</h2><p>（1）synchronized是关键字，lock是一个类</p><p>（2） synchronized在发生异常时会自动释放锁，lock需要手动释放锁</p><p>（3）synchronized是可重入锁、非公平锁、不可中断锁，lock的ReentrantLock是可重入锁，可中断锁，可以是公平锁也可以是非公平锁</p><p>（4）synchronized是JVM层次通过监视器实现的，Lock是通过AQS实现的</p><h2 id="6-什么是AQS锁"><a href="#6-什么是AQS锁" class="headerlink" title="6.  什么是AQS锁?"></a>6.  什么是AQS锁?</h2><p>AQS是一个抽象类，可以用来构造锁和同步类，如ReentrantLock，Semaphore，CountDownLatch，CyclicBarrier。</p><p>AQS的原理是，AQS内部有三个核心组件，一个是state代表加锁状态初始值为0，一个是获取到锁的线程，还有一个阻塞队列。当有线程想获取锁时，会以CAS的形式将state变为1，CAS成功后便将加锁线程设为自己。当其他线程来竞争锁时会判断state是不是0，不是0再判断加锁线程是不是自己，不是的话就把自己放入阻塞队列。这个阻塞队列是用双向链表实现的</p><p>可重入锁的原理就是每次加锁时判断一下加锁线程是不是自己，是的话state+1，释放锁的时候就将state-1。当state减到0的时候就去唤醒阻塞队列的第一个线程。</p><h2 id="7-为什么AQS使用的双向链表？"><a href="#7-为什么AQS使用的双向链表？" class="headerlink" title="7.为什么AQS使用的双向链表？"></a>7.为什么AQS使用的双向链表？</h2><p>因为有一些线程可能发生中断 ，而发生中断时候就需要在同步阻塞队列中删除掉，这个时候用双向链表方便删除掉中间的节点</p><h2 id="7-有哪些常见的AQS锁"><a href="#7-有哪些常见的AQS锁" class="headerlink" title="7.  有哪些常见的AQS锁"></a>7.  有哪些常见的AQS锁</h2><p>AQS分为独占锁和共享锁</p><p>ReentrantLock（独占锁）：可重入，可中断，可以是公平锁也可以是非公平锁，非公平锁就是会通过两次CAS去抢占锁，公平锁会按队列顺序排队</p><p>Semaphore（信号量）:设定一个信号量，当调用acquire()时判断是否还有信号，有就获取一个信号量，没有就阻塞等待其他线程释放信号量，当调用release()时释放一个信号量，唤醒阻塞线程。</p><p>应用场景：允许多个线程访问某个临界资源时，如上下车，买卖票</p><p>CountDownLatch（倒计数器）:给计数器设置一个初始值，当调用CountDown()时计数器减一，当调用await() 时判断计数器是否归0，不为0就阻塞，直到计数器为0。</p><p>应用场景：启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行</p><p>CyclicBarrier（循环栅栏）:给计数器设置一个目标值,当调用await() 时会计数+1并判断计数器是否达到目标值，未达到就阻塞，直到计数器达到目标值</p><p>应用场景：多线程计算数据，最后合并计算结果的应用场景</p><h2 id="9-sleep-和wait-的区别"><a href="#9-sleep-和wait-的区别" class="headerlink" title="9.sleep()和wait()的区别"></a>9.sleep()和wait()的区别</h2><p> (1)wait()是Object的方法，sleep()是Thread类的方法</p><p>(2)wait()会释放锁，sleep()不会释放锁</p><p>(3)wait()要在同步方法或者同步代码块中执行，sleep()没有限制</p><p>(4)wait()要调用notify()或notifyall()唤醒,sleep()自动唤醒</p><h2 id="10-yield-和join-区别"><a href="#10-yield-和join-区别" class="headerlink" title="10. yield()和join()区别"></a>10. yield()和join()区别</h2><p>yield()调用后线程进入就绪状态</p><p>A线程中调用B线程的join() ,则B执行完前A进入阻塞状态</p><h2 id="11-线程池七大参数"><a href="#11-线程池七大参数" class="headerlink" title="11. 线程池七大参数"></a>11. 线程池七大参数</h2><p>核心线程数：线程池中的基本线程数量</p><p>最大线程数：当阻塞队列满了之后，逐一启动</p><p>最大线程的存活时间：当阻塞队列的任务执行完后，最大线长的回收时间</p><p>最大线程的存活时间单位</p><p>阻塞队列：当核心线程满后，后面来的任务都进入阻塞队列</p><p>线程工厂：用于生产线程</p><p>任务拒绝策略：阻塞队列满后，拒绝任务，有四种策略（1）抛异常（2）丢弃任务不抛异常（3）打回任务（4）尝试与最老的线程竞争</p><h2 id="12-Java内存模型"><a href="#12-Java内存模型" class="headerlink" title="12. Java内存模型"></a>12. Java内存模型</h2><p>JMM（Java内存模型 ）屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各平台下都能达到一致的内存访问效果，它定义了JVM如何将程序中的变量在主存中读取</p><p>具体定义为：所有变量都存在主存中，主存是线程共享区域；每个线程都有自己独有的工作内存，线程想要操作变量必须从主从中copy变量到自己的工作区，每个线程的工作内存是相互隔离的</p><p>由于主存与工作内存之间有读写延迟，且读写不是原子性操作，所以会有线程安全问题</p><h2 id="13-保证并发安全的三大特性？"><a href="#13-保证并发安全的三大特性？" class="headerlink" title="13. 保证并发安全的三大特性？"></a>13. 保证并发安全的三大特性？</h2><p> 原子性：一次或多次操作在执行期间不被其他线程影响</p><p>可见性：当一个线程在工作内存修改了变量，其他线程能立刻知道</p><p>有序性：JVM对指令的优化会让指令执行顺序改变，有序性是禁止指令重排</p><h2 id="14-Volatile"><a href="#14-Volatile" class="headerlink" title="14. Volatile"></a>14. Volatile</h2><p>保证变量的可见性和有序性，不保证原子性。使用了 volatile 修饰变量后，在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。</p><p>单例模式双重校验锁变量为什么使用 volatile 修饰？ 禁止 JVM 指令重排序，new Object()分为三个步骤：为实例对象分配内存，用构造器初始化成员变量，将实例对象引用指向分配的内存；实例对象在分配内存后实才不为null。如果分配内存后还未初始化就先将实例对象指向了内存，那么此时最外层的if会判断实例对象已经不等于null就直接将实例对象返回。而此时初始化还没有完成。</p><h2 id="15-线程使用方式"><a href="#15-线程使用方式" class="headerlink" title="15. 线程使用方式"></a>15. 线程使用方式</h2><p>(1)继承 Tread 类</p><p>(2)实现 Runnable 接口</p><p>(3)实现 Callable 接口：带有返回值</p><p>(4)线程池创建线程</p><h2 id="16-ThreadLocal原理"><a href="#16-ThreadLocal原理" class="headerlink" title="16. ThreadLocal原理"></a>16. ThreadLocal原理</h2><p>原理是为每个线程创建变量副本，不同线程之间不可见，保证线程安全。每个线程内部都维护了一个Map，key为threadLocal实例，value为要保存的副本。</p><p>但是使用ThreadLocal会存在内存泄露问题，因为key为弱引用，而value为强引用，每次gc时key都会回收，而value不会被回收。所以为了解决内存泄漏问题，可以在每次使用完后删除value或者使用static修饰ThreadLocal，可以随时获取value</p><h2 id="17-什么是CAS锁"><a href="#17-什么是CAS锁" class="headerlink" title="17. 什么是CAS锁"></a>17. 什么是CAS锁</h2><p>CAS锁可以保证原子性，思想是更新内存时会判断内存值是否被别人修改过，如果没有就直接更新。如果被修改，就重新获取值，直到更新完成为止。这样的缺点是</p><p>（1）只能支持一个变量的原子操作，不能保证整个代码块的原子操作</p><p>（2）CAS频繁失败导致CPU开销大</p><p>（3）ABS问题:线程1和线程2同时去修改一个变量，将值从A改为B，但线程1突然阻塞，此时线程2将A改为B,然后线程3又将B改成A,此时线程1将A又改为B,这个过程线程2是不知道的，这就是ABA问题，可以通过版本号或时间戳解决</p><h2 id="18-Synchronized锁原理和优化"><a href="#18-Synchronized锁原理和优化" class="headerlink" title="18. Synchronized锁原理和优化"></a>18. Synchronized锁原理和优化</h2><p>Synchronize是通过对象头的markwordk来表明监视器的，监视器本质是依赖操作系统的互斥锁实现的。操作系统实现线程切换要从用户态切换为核心态，成本很高，此时这种锁叫重量级锁，在JDK1.6以后引入了偏向锁、轻量级锁、重量级锁</p><p>偏向锁：当一段代码没有别的线程访问，此时线程去访问会直接获取偏向锁</p><p>轻量级锁：当锁是偏向锁时，有另外一个线程来访问，会升级为轻量级锁。线程会通过CAS方式获取锁，不会阻塞，提高性能，</p><p>重量级锁：轻量级锁自旋一段时间后线程还没有获取到锁，会升级为重量级锁，重量级锁时，来竞争锁的所有线程都会阻塞，性能降低</p><p>注意，锁只能升级不能降级</p><h2 id="19-如何根据-CPU-核心数设计线程池线程数量"><a href="#19-如何根据-CPU-核心数设计线程池线程数量" class="headerlink" title="19. 如何根据 CPU 核心数设计线程池线程数量"></a>19. 如何根据 CPU 核心数设计线程池线程数量</h2><p>IO 密集型：线程中十分消耗Io的线程数*2</p><p>CPU密集型： cpu线程数量</p><h2 id="20-AtomicInteger的使用场景"><a href="#20-AtomicInteger的使用场景" class="headerlink" title="20. AtomicInteger的使用场景"></a>20. AtomicInteger的使用场景</h2><p>AtomicInteger是一个提供原子操作的Integer类，使用CAS+volatile实来现线程安全的数值操作。</p><p>因为volatile禁止了jvm的排序优化,所以它不适合在并发量小的时候使用，只适合在一些高并发程序中使用</p><h1 id="三-JVM篇"><a href="#三-JVM篇" class="headerlink" title="三.JVM篇"></a>三.JVM篇</h1><h2 id="1-JVM运行时数据区（内存结构）"><a href="#1-JVM运行时数据区（内存结构）" class="headerlink" title="1.  JVM运行时数据区（内存结构）"></a>1.  JVM运行时数据区（内存结构）</h2><p>线程私有区：</p><p>（1）虚拟机栈：每次调用方法都会在虚拟机栈中产生一个栈帧，每个栈帧中都有方法的参数、局部变量、方法出口等信息，方法执行完毕后释放栈帧</p><p>（2）本地方法栈：为native修饰的本地方法提供的空间，在HotSpot中与虚拟机合二为一</p><p>（3）程序计数器：保存指令执行的地址，方便线程切回后能继续执行代码</p><p>线程共享区：</p><p>（4）堆内存：Jvm进行垃圾回收的主要区域，存放对象信息，分为新生代和老年代，内存比例为1：2，新生代的Eden区内存不够时时发生MinorGC,老年代内存不够时发生FullGC</p><p>（5）方法区：存放类信息、静态变量、常量、运行时常量池等信息。JDK1.8之前用持久代实现，JDK1.8后用元空间实现，元空间使用的是本地内存，而非在JVM内存结构中</p><h2 id="2-什么情况下会内存溢出？"><a href="#2-什么情况下会内存溢出？" class="headerlink" title="2.  什么情况下会内存溢出？"></a>2.  什么情况下会内存溢出？</h2><p>堆内存溢出：（1）当对象一直创建而不被回收时（2）加载的类越来越多时（3)虚拟机栈的线程越来越多时</p><p>栈溢出：方法调用次数过多，一般是递归不当造成</p><h2 id="3-JVM有哪些垃圾回收算法？"><a href="#3-JVM有哪些垃圾回收算法？" class="headerlink" title="3.  JVM有哪些垃圾回收算法？"></a>3.  JVM有哪些垃圾回收算法？</h2><p>（1）标记清除算法： 标记不需要回收的对象，然后清除没有标记的对象，会造成许多内存碎片。</p><p>（2）复制算法： 将内存分为两块，只使用一块，进行垃圾回收时，先将存活的对象复制到另一块区域，然后清空之前的区域。用在新生代</p><p>（3）标记整理算法： 与标记清除算法类似，但是在标记之后，将存活对象向一端移动，然后清除边界外的垃圾对象。用在老年代</p><h2 id="4-GC如何判断对象可以被回收？"><a href="#4-GC如何判断对象可以被回收？" class="headerlink" title="4.  GC如何判断对象可以被回收？"></a>4.  GC如何判断对象可以被回收？</h2><p>（1）引用计数法：已淘汰，为每个对象添加引用计数器，引用为0时判定可以回收，会有两个对象相互引用无法回收的问题</p><p>（2）可达性分析法：从GCRoot开始往下搜索，搜索过的路径称为引用链，若一个对象GCRoot没有任何的引用链，则判定可以回收</p><p> GCRoot有：虚拟机栈中引用的对象，方法区中静态变量引用的对象，本地方法栈中引用的对象</p><h2 id="5-典型垃圾回收器"><a href="#5-典型垃圾回收器" class="headerlink" title="5.  典型垃圾回收器"></a>5.  典型垃圾回收器</h2><p>CMS:以最小的停顿时间为目标、只运行在老年代的垃圾回收器，使用标记-清除算法，可以并发收集。</p><p>G1 ：JDK1.9以后的默认垃圾回收器，注重响应速度，支持并发，采用标记整理+复制算法回收内存，使用可达性分析法来判断对象是否可以被回收。</p><h2 id="6-类加载器和双亲委派机制"><a href="#6-类加载器和双亲委派机制" class="headerlink" title="6.  类加载器和双亲委派机制"></a>6.  类加载器和双亲委派机制</h2><p>从父类加载器到子类加载器分别为：</p><p>BootStrapClassLoader  加载路径为：JAVA_HOME&#x2F;jre&#x2F;lib</p><p>ExtensionClassLoader  加载路径为：JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</p><p>ApplicationClassLoader 加载路径为：classpath</p><p>还有一个自定义类加载器</p><p>当一个类加载器收到类加载请求时，会先把这个请求交给父类加载器处理，若父类加载器找不到该类，再由自己去寻找。该机制可以避免类被重复加载，还可以避免系统级别的类被篡改</p><h2 id="7-JVM中有哪些引用？"><a href="#7-JVM中有哪些引用？" class="headerlink" title="7.  JVM中有哪些引用？"></a>7.  JVM中有哪些引用？</h2><p>强引用：new的对象。哪怕内存溢出也不会回收</p><p>软引用：只有内存不足时才会回收</p><p>弱引用：每次垃圾回收都会回收</p><p>虚引用：必须配合引用队列使用，一般用于追踪垃圾回收动作</p><h2 id="8-类加载过程"><a href="#8-类加载过程" class="headerlink" title="8.  类加载过程"></a>8.  类加载过程</h2><p>（1）加载 ：把字节码通过二进制的方式转化到方法区中的运行数据区</p><p>（2）连接：</p><p> 验证：验证字节码文件的正确性。</p><p> 准备：正式为类变量在方法区中分配内存，并设置初始值，final类型的变量在编译时已经赋值了</p><p> 解析：将常量池中的符号引用（如类的全限定名）解析为直接引用（类在实际内存中的地址） </p><p>（3）初始化 ：执行类构造器（不是常规的构造方法），为静态变量赋初值并初始化静态代码块。</p><h2 id="9-JVM类初始化顺序"><a href="#9-JVM类初始化顺序" class="headerlink" title="9.  JVM类初始化顺序"></a>9.  JVM类初始化顺序</h2><p>父类静态代码块和静态成员变量-&gt;子类静态代码块和静态成员变量-&gt;父类代码块和普通成员变量-&gt;父类构造方法-&gt;子类代码块和普成员变量-&gt;子类构造方法</p><h2 id="10-对象的创建过程"><a href="#10-对象的创建过程" class="headerlink" title="10. 对象的创建过程"></a>10. 对象的创建过程</h2><p>（1）检查类是否已被加载，没有加载就先加载类</p><p>（2）为对象在堆中分配内存，使用CAS方式分配，防止在为A分配内存时，执行当前地址的指针还没有来得及修改，对象B就拿来分配内存。</p><p>（3）初始化，将对象中的属性都分配0值或null</p><p>（4）设置对象头</p><p>（5）为属性赋值和执行构造方法</p><h2 id="11-对象头中有哪些信息"><a href="#11-对象头中有哪些信息" class="headerlink" title="11. 对象头中有哪些信息"></a>11. 对象头中有哪些信息</h2><p>对象头中有两部分，一部分是MarkWork,存储对象运行时的数据，如对象的hashcode、GC分代年龄、GC标记、锁的状态、获取到锁的线程ID等；另外一部分是表明对象所属类，如果是数组，还有一个部分存放数组长度</p><h2 id="12-JVM内存参数"><a href="#12-JVM内存参数" class="headerlink" title="12. JVM内存参数"></a>12. JVM内存参数</h2><p>-Xmx[]:堆空间最大内存</p><p>-Xms[]:堆空间最小内存，一般设置成跟堆空间最大内存一样的</p><p>-Xmn[]:新生代的最大内存</p><p>-xx:[survivorRatio&#x3D;3]:eden区与from+to区的比例为3：1，默认为4：1</p><p>-xx[use 垃圾回收器名称]：指定垃圾回收器</p><p>-xss:设置单个线程栈大小</p><p>一般设堆空间为最大可用物理地址的百分之80</p><h2 id="13-GC的回收机制和原理"><a href="#13-GC的回收机制和原理" class="headerlink" title="13. GC的回收机制和原理"></a>13. GC的回收机制和原理</h2><p>GC的目的实现内存的自动释放，使用可达性分析法判断对象是否可回收，采用了分代回收思想，</p><p>将堆分为新生代、老年代，新生代中采用复制算法，老年代采用整理算法，当新生代内存不足时会发生minorGC,老年代不足时会发送fullGC</p><h1 id="四-Mysql篇"><a href="#四-Mysql篇" class="headerlink" title="四.Mysql篇"></a>四.Mysql篇</h1><h2 id="1-MyIsAm和InnoDB的区别"><a href="#1-MyIsAm和InnoDB的区别" class="headerlink" title="1.  MyIsAm和InnoDB的区别"></a>1.  MyIsAm和InnoDB的区别</h2><p>InnoDB有三大特性，分别是事务、外键、行级锁，这些都是MyIsAm不支持的，</p><p>另外InnoDB是聚簇索引，MyIAm是非聚簇索引，</p><p>InnoDB不支持全文索引，MyIAm支持</p><p>InnoDB支持自增和MVCC模式的读写，MyIAm不支持</p><p>MyIsAM的访问速度一般InnoDB快，差异在于innodb的mvcc、行锁会比较消耗性能，还可能有回表的过程（先去辅助索引中查询数据，找到数据对应的key之后，再通过key回表到聚簇索引树查找数据）</p><h2 id="2-mysql事务特性"><a href="#2-mysql事务特性" class="headerlink" title="2.  mysql事务特性"></a>2.  mysql事务特性</h2><p>原子性：一个事务内的操作统一成功或失败</p><p>一致性：事务前后的数据总量不变</p><p>隔离性：事务与事务之间相互不影响</p><p>持久性：事务一旦提交发生的改变不可逆</p><h2 id="3-事务靠什么保证"><a href="#3-事务靠什么保证" class="headerlink" title="3.  事务靠什么保证"></a>3.  事务靠什么保证</h2><p>原子性：由undolog日志保证，他记录了需要回滚的日志信息，回滚时撤销已执行的sql</p><p>一致性：由其他三大特性共同保证，是事务的目的</p><p>隔离性：由MVCC保证</p><p>持久性：由redolog日志和内存保证，mysql修改数据时内存和redolog会记录操作，宕机时可恢复</p><h2 id="4-事务的隔离级别"><a href="#4-事务的隔离级别" class="headerlink" title="4.  事务的隔离级别"></a>4.  事务的隔离级别</h2><p>在高并发情况下，并发事务会产生脏读、不可重复读、幻读问题，这时需要用隔离级别来控制</p><p>读未提交： 允许一个事务读取另一个事务已提交的数据，可能出现不可重复读，幻读。</p><p>读提交：  只允许事务读取另一个事务没有提交的数据可能出现不可重复读，幻读。</p><p>可重复读： 确保同一字段多次读取结果一致，可能出现欢幻读。</p><p>可串行化： 所有事务逐次执行，没有并发问日</p><p>Inno DB 默认隔离级别为可重复读级别，分为快照度和当前读，并且通过间隙锁解决了幻读问题。</p><h2 id="5-什么是快照读和当前读"><a href="#5-什么是快照读和当前读" class="headerlink" title="5.  什么是快照读和当前读"></a>5.  什么是快照读和当前读</h2><p>*快照读读取的是当前数据的可见版本，可能是会过期数据，不加锁的select就是快照都</p><p>*当前读读取的是数据的最新版本，并且当前读返回的记录都会上锁，保证其他事务不会并发修改这条记录。如update、insert、delete、select for undate（排他锁）、select lockin share mode（共享锁） 都是当前读</p><h2 id="6-MVCC是什么"><a href="#6-MVCC是什么" class="headerlink" title="6.  MVCC是什么"></a>6.  MVCC是什么</h2><p>MVCC是多版本并发控制，为每次事务生成一个新版本数据，每个事务都由自己的版本，从而不加锁就决绝读写冲突，这种读叫做快照读。只在读已提交和可重复读中生效。</p><p>实现原理由四个东西保证，他们是</p><p>undolog日志：记录了数据历史版本</p><p>readView:事务进行快照读时动态生成产生的视图，记录了当前系统中活跃的事务id，控制哪个历史版本对当前事务可见</p><p>隐藏字段DB_TRC_ID： 最近修改记录的事务ID </p><p>隐藏字段DB_Roll_PTR： 回滚指针，配合undolog指向数据的上一个版本</p><h2 id="7-MySQL有哪些索引"><a href="#7-MySQL有哪些索引" class="headerlink" title="7.  MySQL有哪些索引"></a>7.  MySQL有哪些索引</h2><p>主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值</p><p>唯一索引：唯一索引不能有相同值，但允许为空</p><p>普通索引：允许出现重复值</p><p>组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则</p><p>全文索引：myisam引擎支持，通过建立倒排索引提升检索效率，广泛用于搜索引擎</p><h2 id="8-聚簇索引和非聚簇索引的区别"><a href="#8-聚簇索引和非聚簇索引的区别" class="headerlink" title="8.  聚簇索引和非聚簇索引的区别"></a>8.  聚簇索引和非聚簇索引的区别</h2><p>聚簇索引：聚簇索引的叶子节点存放的是主键值和数据行；辅助索引（在聚簇索引上创建的其它索引）的叶子节点存放的是主键值或指向数据行的指针。</p><p>优点：根据索引可以直接获取值，所以他获取数据更快；对于主键的排序查找和范围查找效率更高；</p><p>缺点：如果主键值很大的话，辅助索引也会变得很大；如果用uuid作为主键，数据存储会很稀疏；修改主键或乱序插入会让数据行移动导致页分裂；所以一般我们定义主键时尽量让主键值小，并且定义为自增和不可修改。</p><p>非聚簇索引（辅助索引）：叶子节点存放的是数据行地址，先根据索引找到数据地址，再根据地址去找数据</p><p>他们都是b+数结构</p><h2 id="9-MySQL如何做慢SQL优化"><a href="#9-MySQL如何做慢SQL优化" class="headerlink" title="9.  MySQL如何做慢SQL优化"></a>9.  MySQL如何做慢SQL优化</h2><p>可以查看执行计划分析数据的扫描类型、索引是否生效，常见的慢查询优化有：</p><p>（1）尽量减少select的数据列，尽量使用覆盖索引</p><p>（2）orderby查找时使用索引进行排序，否则的话需要进行回表</p><p>（3）groupby查询时，同样要用索引，避免使用到临时表</p><p>（4）分页查询时，如果limit 后面的数字太大，可以使用子查询查出主键，再limit主键后n条数据就能走覆盖索引</p><p>（5） 使用复杂查询时，使用关联查询来代替子查询，并且最好使用内连接</p><p>（6）使用count函数时直接使用count的话count(*)的效率最高</p><p>count(*)或count(唯一索引)或count(数字):表中总记录数，count(字段)不会统计null</p><p> (7) 在写update语句时，where条件要使用索引，否则会锁会从行锁升级为表锁</p><p>（8）表中数据是否太大，是不是要分库分表</p><h2 id="10-为什么要用内连接而不用外连接？"><a href="#10-为什么要用内连接而不用外连接？" class="headerlink" title="10. 为什么要用内连接而不用外连接？"></a>10. 为什么要用内连接而不用外连接？</h2><p>用外连接的话连接顺序是固定死的，比如left join，他必须先对左表进行全表扫描，然后一条条到右表去匹配；而内连接的话mysql会自己根据查询优化器去判断用哪个表做驱动。</p><p>子查询的话同样也会对驱动表进行全表扫描，所以尽量用小表做驱动表。</p><h2 id="11-MySQL整个查询的过程"><a href="#11-MySQL整个查询的过程" class="headerlink" title="11. MySQL整个查询的过程"></a>11. MySQL整个查询的过程</h2><p>（1）客户端向 MySQL 服务器发送一条查询请求</p><p>（2）服务器首先检查查询缓存，如果命中缓存，则返回存储在缓存中的结果。否则进入下一阶段</p><p>（3）服务器进行 SQL 解析、预处理、再由优化器生成对应的执行计划</p><p>（4）MySQL 根据执行计划，调用存储引擎的 API 来执行查询</p><p>（5）将结果返回给客户端，同时缓存查询结果</p><p>注意：只有在8.0之前才有查询缓存，8.0之后查询缓存被去掉了</p><h2 id="12-执行计划中有哪些字段？"><a href="#12-执行计划中有哪些字段？" class="headerlink" title="12. 执行计划中有哪些字段？"></a>12. 执行计划中有哪些字段？</h2><p>我们想看一个sql的执行计划使用的语句是explain+SQL，表中的字段包括：</p><p>type:扫描类型，效率从底到高为ALL（全表扫描)&gt;index(全索引扫描，我们的需要的数据在索引中可以获取)&gt;range(使用索引进行范围查找)&gt;ref(使用非唯一索引列进行了关联查询)&gt; eq_ref (使用唯一索引进行关联查询)&gt;const(使用唯一索引查询一行数据)&gt;system(表中只有一行数据)</p><p> extra（额外的）:mysql如何查询额外信息，常见的有：</p><p>filesort:在排序缓冲区中进行排序，需要回表查询数据</p><p>index:表示使用覆盖索引</p><p>index scan:排序时使用了索引排序，但如果是按照降序排序的话就会使用反向扫描索引</p><p>temporary:查询时要建立一个临时表存放数据</p><p>rows:找到了多少行数据</p><p>key:实际使用到的索引</p><p>id:select查询的优先级，id越大优先级越高，子查询的id一般会更大</p><p>select_type:查询的类型,是普通查询还是联合查询还是子查询，常见类型有simple（不包含子查询），primary（标记复杂查询中最外层的查询），union(标记primart只后子查询)</p><p>table：者一行的数据是数哪张表的</p><p>possible_keys（可能的）:当前查询语句可能用到的索引，可能为null(如果用了索引但是为null有可能是表数据太少innodb认为全表扫描更快)</p><p>ref（编号）:显示索引的哪一行被使用了</p><h2 id="13-哪些情况索引会失效"><a href="#13-哪些情况索引会失效" class="headerlink" title="13. 哪些情况索引会失效"></a>13. 哪些情况索引会失效</h2><p>（1）where条件中有or，除非所有查询条件都有索引，否则失效</p><p>（2）like查询用%开头，索引失效</p><p>（3）索引列参与计算，索引失效</p><p>（4）违背最左匹配原则，索引失效</p><p>（5）索引字段发生类型转换，索引失效</p><p>（6）mysql觉得全表扫描更快时（数据少），索引失效</p><h2 id="14-B和B-数的区别，为什么使用B-数"><a href="#14-B和B-数的区别，为什么使用B-数" class="headerlink" title="14. B和B+数的区别，为什么使用B+数"></a>14. B和B+数的区别，为什么使用B+数</h2><p>二叉树：索引字段有序，极端情况会变成链表形式</p><p>AVL数：树的高度不可控</p><p>B数：控制了树的高度，但是索引值和data都分布在每个具体的节点当中，若要进行范围查询，要进行多次回溯，IO开销大</p><p>B+树：非叶子节点只存储索引值，叶子节点再存储索引+具体数据，从小到大用链表连接在一起，范围查询可直接遍历不需要回溯7</p><h2 id="15-MySQL有哪些锁"><a href="#15-MySQL有哪些锁" class="headerlink" title="15. MySQL有哪些锁"></a>15. MySQL有哪些锁</h2><p>基于粒度：</p><p> *表级锁：对整张表加锁，粒度大并发小</p><p> *行级锁：对行加锁，粒度小并发大</p><p> *间隙锁：间隙锁，锁住表的一个区间，间隙锁之间不会冲突只在可重复读下才生效，解决了幻读</p><p>基于属性：</p><p>  *共享锁：又称读锁，一个事务为表加了读锁，其它事务只能加读锁，不能加写锁</p><p>   *排他锁：又称写锁，一个事务加写锁之后，其他事务不能再加任何锁，避免脏读问题  </p><h2 id="16-Mysql内连接、左连接、右连接的区别"><a href="#16-Mysql内连接、左连接、右连接的区别" class="headerlink" title="16. Mysql内连接、左连接、右连接的区别"></a>16. Mysql内连接、左连接、右连接的区别</h2><p>内连接取量表交集部分，左连接取左表全部右表匹部分，右连接取右表全部坐表匹部分</p><h2 id="17-sql执行顺序"><a href="#17-sql执行顺序" class="headerlink" title="17. sql执行顺序"></a>17. sql执行顺序</h2><p>我单独写了一篇文章 <a href="http://t.csdn.cn/6a5Y3">http://t.csdn.cn/6a5Y3</a></p><h2 id="18-如何设计数据库？"><a href="#18-如何设计数据库？" class="headerlink" title="18. 如何设计数据库？"></a>18. 如何设计数据库？</h2><p>（1）抽取实体，如用户信息，商品信息，评论</p><p>（2）分析其中属性，如用户信息：姓名、性别…</p><p>（3）分析表与表之间的关联关系</p><p>然后可以参考三大范式进行设计，设计主键时，主键要尽量小并且定义为自增和不可修改。</p><h2 id="19-where和having的区别？"><a href="#19-where和having的区别？" class="headerlink" title="19. where和having的区别？"></a>19. where和having的区别？</h2><p>where是约束声明，having是过滤声明，where早于having执行，并且where不可以使用聚合函数，having可以</p><h2 id="20-三大范式"><a href="#20-三大范式" class="headerlink" title="20. 三大范式"></a>20. 三大范式</h2><p>第一范式：每个列都不可以再拆分。</p><p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p><p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p><h2 id="21-char和varchar的区别"><a href="#21-char和varchar的区别" class="headerlink" title="21. char和varchar的区别"></a>21. char和varchar的区别</h2><p>char是不可变的，最大长度为255，varchar是可变的字符串，最大长度为2^16</p><h2 id="22-InnoDB-什么情况下会产生死锁"><a href="#22-InnoDB-什么情况下会产生死锁" class="headerlink" title="22. InnoDB 什么情况下会产生死锁"></a>22. InnoDB 什么情况下会产生死锁</h2><p>事务1已经获取数据A的写锁，想要去获取数据B的写锁，然后事务2获取了B的写锁，想要去获取A的写锁，相互等待形成死锁。</p><p>mysql解决死锁的机制有两个：1.等待， 直到超时 2.发起死锁检测，主动回滚一条事务</p><p>死锁检测的原理是构建一个以事务为顶点、 锁为边的有向图， 判断有向图是否存在环， 存在即有死锁。</p><p>我们平时尽量减少事务操作的资源和隔离级别</p><h2 id="23-MySQL-删除自增-id，随后重启-MySQL-服务，再插入数据，自增-id-会从几开始？"><a href="#23-MySQL-删除自增-id，随后重启-MySQL-服务，再插入数据，自增-id-会从几开始？" class="headerlink" title="23. MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始？"></a>23. MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始？</h2><p>innodb 引擎：</p><p>MySQL8.0前，下次自增会取表中最大 id + 1。原理是最大id会记录在内存中，重启之后会重新读取表中最大的id</p><p>MySQL8.0后，仍从删除数据 id 后算起。原理是它将最大id记录在redolog里了</p><p>myisam：</p><p>自增的 id 都从删除数据 id 后算起。原理是它将最大id记录到数据文件里了</p><h2 id="24-MySQL插入百万级的数据如何优化？"><a href="#24-MySQL插入百万级的数据如何优化？" class="headerlink" title="24. MySQL插入百万级的数据如何优化？"></a>24. MySQL插入百万级的数据如何优化？</h2><p>（1）一次sql插入多条数据，可以减少写redolog日志和binlog日志的io次数（sql是有长度限制的，但可以调整）</p><p>（2）保证数据按照索引进行有序插入</p><p>（3）可以分表后多线程插入</p><h1 id="五-常用开发框架系列"><a href="#五-常用开发框架系列" class="headerlink" title="五.常用开发框架系列"></a>五.常用开发框架系列</h1><h2 id="1-什么是Spring？"><a href="#1-什么是Spring？" class="headerlink" title="1.  什么是Spring？"></a>1.  什么是Spring？</h2><p>Spring是个轻量级的框架，通过IOC达到松耦合的目的，通过AOP可以分离应用业务逻辑和系统服务进行内聚性的开发，不过配置各种组件时比较繁琐，所以后面才出选了SpringBoot的框架。 </p><h2 id="2-IOC是什么？"><a href="#2-IOC是什么？" class="headerlink" title="2.  IOC是什么？"></a>2.  IOC是什么？</h2><p>IOC是控制反转，是一种思想，把对象的创建和调用从程序员手中交由IOC容器管理，降低对象之间的依赖关系。</p><p>创建一个bean的方式有xml方式、@Bean注解方式、@Componte方式</p><p>我们在对一个bean进行实例化后，要对他的属性进行填充，大多数我们都是使用 @Autowire直接的填充依赖注入的，他是有限按照类型进行匹配。</p><h2 id="3-AOP是什么？"><a href="#3-AOP是什么？" class="headerlink" title="3.  AOP是什么？"></a>3.  AOP是什么？</h2><p>AOP是面向切面编程，可以将那些与业务不相关但是很多业务都要调用的代码抽取出来，思想就是不侵入原有代码的情况下对功能进行增强。</p><p>SpringAOP是基于动态代理实现的，动态代理是有两种，一种是jdk动态代理，一种是cglib动态代理;</p><p>jdk动态代理是原理是利用反射来实现的，需要调用反射包下的Proxy类的newProxyInstance方法来返回代理对象，这个方法中有三个参数，分别是用于加载代理类的类加载器，被代理类实现的接口的class数组和一个用于增强方法的InvocaHandler实现类。</p><p>cglib动态代理原理是利用asm开源包来实现的，是把被代理类的class文件加载进来，通过修改它的字节码生成子类来处理</p><p>jdk动态代理要求被代理类必须有实现的接口，生成的动态代理类会和代理类实现同样的接口，cglib则，生成的动态代理类会继承被代理类。Spring默认使用jdk动态代理，当被代理的类没有接口时就使用cglib动态代理</p><h2 id="4-如何定义一个全局异常处理类？"><a href="#4-如何定义一个全局异常处理类？" class="headerlink" title="4.  如何定义一个全局异常处理类？"></a>4.  如何定义一个全局异常处理类？</h2><p>想要定义一个全局异常处理类的话，我们需要在这个类上添加@ContaollerAdvice注解，然后定义一些用于捕捉不同异常类型的方法，在这些方法上添加@ExceptionHandler(value &#x3D; 异常类型.class)和@ResponseBody注解，方法参数是HttpServletRequest和异常类型，然后将异常消息进行处理。</p><p>如果我们需要自定义异常的话，就写一个自定义异常类，该类需要继承一个异常接口，类属性包括final类型的连续id、错误码、错误信息，再根据需求写构造方法；</p><h2 id="5-如何使用aop自定义日志？"><a href="#5-如何使用aop自定义日志？" class="headerlink" title="5.  如何使用aop自定义日志？"></a>5.  如何使用aop自定义日志？</h2><p>第一步：创建一个切面类，把它添加到ioc容器中并添加@Aspect注解</p><p>第二步： 在切面类中写一个通知方法，在方法上添加通知注解并通过切入点表达式来表示要对哪些方法进行日志打印，然后方法参数为JoinPoint</p><p>第三步：通过JoinPoint这个参数可以获取当前执行的方法名、方法参数等信息，这样就可以根据需求在方法进入或结束时打印日志</p><h2 id="6-循环依赖是什么，怎么解决的？"><a href="#6-循环依赖是什么，怎么解决的？" class="headerlink" title="6.  循环依赖是什么，怎么解决的？"></a>6.  循环依赖是什么，怎么解决的？</h2><p>循环依赖就是在创建 A 实例的时候里面包含着 B 属性实例，所以这个时候就需要去创建 B 实例，而创 建 B 实例过程中也包含着 A 实例。 这样 A 实例还在创建的过程当中，所以就导致 A 和 B 实例都创建不出来。</p><p>spring通过三级缓存来解决循环依赖：</p><p>一级缓存：单例池，缓存经过了已经初始化完毕的Bean</p><p>二级缓存 ：半成品池，缓存还未初始化完毕的Bean</p><p>三级缓存：缓存的是获取Bean的代理对象的表达式</p><p>我们在创建 A 的过程中，先将 A 放入三级缓存 ，这时要创建B，B要创建A就直接去三级缓存中查找，并且判断需不需要进行 AOP 处理，如果需要就在三级缓存中获取A的代理对象，不需要就取A原始对象。然后将取出的对象放入二级缓存中，这个时候其他需要依赖 A 对象的直接从二级缓存中去获取即可。当B初始化完成进入一级缓存后，A 继续执行生命周期，当A完成了属性的注入后，就可以放入一级缓存了</p><p>spring2.6之前默认会解决循环依赖。在spring2.6之后需要通过配置开启解决循环依赖</p><h2 id="7-Bean-的作用域"><a href="#7-Bean-的作用域" class="headerlink" title="7.  Bean 的作用域"></a>7.  Bean 的作用域</h2><p>（1）Singleton:一个IOC容器只有一个</p><p>（2）Prototype:每次调用getBean()都会生成一个新的对象</p><p>（3）request:每个http请求都会创建一个自己的bean</p><p>（4）session:同一个session共享一个实例</p><p>（5）application:整个serverContext只有一个bean</p><p>（6）webSocket:一个websocket只有一个bean</p><h2 id="8-Bean-生命周期"><a href="#8-Bean-生命周期" class="headerlink" title="8.  Bean 生命周期"></a>8.  Bean 生命周期</h2><p>实例化 Instantiation-&gt;属性赋值 Populate-&gt;初始化 Initialization-&gt;销毁 Destruction</p><p>在这四步的基础上面，Spring 提供了一些拓展点：</p><p>*Bean 自身的方法: 包括了 Bean 本身调用的方法和通过配置文件中的 init-method 和 destroy-method 指定的方法</p><p>*Bean 级生命周期接口方法:包括了 BeanNameAware、BeanFactoryAware、InitializingBean 和 DiposableBean 这些接口的方法</p><p>*容器级生命周期接口方法:包括了 InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</p><p>*工厂后处理器接口方法: 包括了 AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer 等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p><h2 id="9-Spring-事务原理？"><a href="#9-Spring-事务原理？" class="headerlink" title="9.  Spring 事务原理？"></a>9.  Spring 事务原理？</h2><p>spring事务有编程式和声明式，我们一般使用声明式，在某个方法上增加@Transactional注解，这个方法中的sql会统一成功或失败。</p><p>原理是：</p><p>当一个方法加上@Transactional注解，spring会基于这个类生成一个代理对象并将这个代理对象作为bean，当使用这个bean中的方法时，如果存在@Transactional注解，就会将事务自动提交设为false，然后执行方法，执行过程没有异常则提交，有异常则回滚、</p><h2 id="10-spring事务失效场景"><a href="#10-spring事务失效场景" class="headerlink" title="10. spring事务失效场景"></a>10. spring事务失效场景</h2><p>（1）事务方法所在的类没有加载到容器中</p><p>（2）事务方法不是public类型</p><p>（3）同一类中，一个没有添加事务的方法调用另外以一个添加事务的方法，事务不生效</p><p>（4）spring事务默认只回滚运行时异常，可以用rollbackfor属性设置</p><p>（5）业务自己捕获了异常，事务会认为程序正常秩序</p><h2 id="11-spring事务的隔离级别"><a href="#11-spring事务的隔离级别" class="headerlink" title="11. spring事务的隔离级别"></a>11. spring事务的隔离级别</h2><p>default:默认级别，使用数据库自定义的隔离级别</p><p>其它四种隔离级别与mysql一样</p><h2 id="12-spring事务的传播行为"><a href="#12-spring事务的传播行为" class="headerlink" title="12. spring事务的传播行为"></a>12. spring事务的传播行为</h2><p>（1）支持当前事务，如果不存在，则新启一个事务</p><p>（2）支持当前事务，如果不存在，则抛出异常</p><p>（3）支持当前事务，如果不存在，则以非事务方式执行</p><p>（4）不支持当前事务，创建一个新事物</p><p>（5）不支持当前事务，如果已存在事务就抛异常</p><p>（6）不支持当前事务，始终以非事务方式执行</p><h2 id="13-spring用了哪些设计模式"><a href="#13-spring用了哪些设计模式" class="headerlink" title="13. spring用了哪些设计模式"></a>13. spring用了哪些设计模式</h2><p>BeanFactory用了工厂模式，AOP用了动态代理模式，RestTemplate用来模板方法模式，SpringMVC中handlerAdaper用来适配器模式，Spring里的监听器用了观察者模式</p><h2 id="14-SpringMV工作原理"><a href="#14-SpringMV工作原理" class="headerlink" title="14. SpringMV工作原理"></a>14. SpringMV工作原理</h2><p>SpringMVC工作过程围绕着前端控制器DispatchServerlet，几个重要组件有HandleMapping（处理器映射器）、HandleAdapter（处理器适配器）、ViewReslover（试图解析器）</p><p>工作流程：</p><p>（1）DispatchServerlet接收用户请求将请求发送给HandleMapping</p><p> （2）HandleMapping根据请求url找到具体的handle和拦截器，返回给DispatchServerlet</p><p>（3）DispatchServerlet调用HandleAdapter,HandleAdapter执行具体的controller，并将controller返回的ModelAndView返回给DispatchServler</p><p>（4）DispatchServerlet将ModelAndView传给ViewReslover,ViewReslover解析后返回具体view</p><p>（5）DispatchServerlet根据view进行视图渲染，返回给用户</p><h2 id="15-springboot自动配置原理"><a href="#15-springboot自动配置原理" class="headerlink" title="15. springboot自动配置原理"></a>15. springboot自动配置原理</h2><p>在spring—boot—autoconfigura包下存放了spring内置的自动配置类和spring.factories文件，这个文件中存放了这些配置类的全类名 ；</p><p>启动类@SpringbootApplication注解下，有三个关键注解</p><p>（1）@springbootConfiguration:表示启动类是一个自动配置类</p><p>（2）@CompontScan:扫描启动类所在包下及子包的组件到容器中</p><p>（3）@EnableConfigutarion，下面有个子注解@Import会导入上面所说的自动配置类，这些配置类会根据元注解的装配条件生效，生效的类就会被实例化，加载到ioc容器中；这些自动配置类还会通过xxxProperties文件里配置来进行属性设值</p><h2 id="16-springboot常用注解"><a href="#16-springboot常用注解" class="headerlink" title="16 .springboot常用注解"></a>16 .springboot常用注解</h2><p>@RestController         ：修饰类，该控制器会返回Json数据 </p><p>@RequestMapping(“&#x2F;path”) ：修饰类，该控制器的请求路径</p><p>@Autowired             : 修饰属性，按照类型进行依赖注入</p><p>@PathVariable           : 修饰参数，将路径值映射到参数上</p><p>@ResponseBody         :修饰方法，该方法会返回Json数据</p><p>@RequestBody（需要使用Post提交方式） :修饰参数，将Json数据封装到对应参数中</p><p>@Controller@Service@Compont: 将类注册到ioc容器</p><p>@Transaction：开启事务</p><h2 id="16-spring的bean是线程安全的吗？"><a href="#16-spring的bean是线程安全的吗？" class="headerlink" title="16. spring的bean是线程安全的吗？"></a>16. spring的bean是线程安全的吗？</h2><p>spring的默认bean作用域是单例的，单例的bean不是线程安全的，但是开发中大部分的bean都是无状态的，不具备存储功能，比如controller、service、dao，他们不需要保证线程安全。</p><p>如果要保证线程安全，可以将bean的作用域改为prototype，比如像Model View。</p><p>另外还可以采用ThreadLocal来解决线程安全问题。ThreadLocal为每个线程保存一个副本变量，每个线程只操作自己的副本变量。</p><h2 id="17-springcloud主要解决什么问题？"><a href="#17-springcloud主要解决什么问题？" class="headerlink" title="17. springcloud主要解决什么问题？"></a>17. springcloud主要解决什么问题？</h2><p>解决服务之间的通信、容灾、负载平衡、冗余问题，能方便服务集中管理，常用组件有注册中心、配置中心、远程调用。服务熔断、网关</p><h2 id="18-CAP理论"><a href="#18-CAP理论" class="headerlink" title="18. CAP理论"></a>18. CAP理论</h2><p>C：一致性，这里指的强一致性，也就是数据更新完，访问任何节点看到的数据完全一致</p><p>A：可用性，就是任何没有发生故障的服务必须在规定时间内返回合正确结果</p><p>P：容灾性，当网络不稳定时节点之间无法通信，造成分区，这时要保证系统可以继续正常服务。提高容灾性的办法就是把数据分配到每一个节点当中，所以P是分布式系统必须实现的，然后需要在C和A中取舍</p><h2 id="19-为什么不能同时保证一致性和可用性呢？"><a href="#19-为什么不能同时保证一致性和可用性呢？" class="headerlink" title="19. 为什么不能同时保证一致性和可用性呢？"></a>19. 为什么不能同时保证一致性和可用性呢？</h2><p>当网络发生故障时，如果要保障数据一致性，那么节点相互间就只能阻塞等待数据真正同步时再返回，就违背可用性了。如果要保证可用性，节点要在有限时间内将结果返回，无法等待其它节点的更新消息，此时返回的数据可能就不是最新数据，就违背了一致性了</p><h2 id="20-熔断限流的理解？"><a href="#20-熔断限流的理解？" class="headerlink" title="20. 熔断限流的理解？"></a>20. 熔断限流的理解？</h2><p>SprngCloud中用Hystrix组件来进行降级、熔断、限流</p><p>熔断是对于消费者来讲，当对提供者请求时间过久时为了不影响性能就对链接进行熔断，</p><p>限流是对于提供者来讲，为了防止某个消费者流量太大，导致其它更重要的消费者请求无法及时处理。限流可用通过拒绝服务、服务降级、消息队列延时处理、限流算法来实现</p><h2 id="21-常用限流算法"><a href="#21-常用限流算法" class="headerlink" title="21. 常用限流算法"></a>21. 常用限流算法</h2><p>计数器算法：使用redis的setnx和过期机制实现</p><p>漏桶算法：一般使用消息队列来实现，系统以恒定速度处理队列中的请求，当队列满的时候开始拒绝请求。</p><p>令牌桶算法：计数器算法和漏桶算法都无法解决突然的大并发，令牌桶算法是预先往桶中放入一定数量token，然后用恒定速度放入token直到桶满为止，所有请求都必须拿到token才能访问系统</p><h1 id="六-Redis系列"><a href="#六-Redis系列" class="headerlink" title="六.Redis系列"></a>六.Redis系列</h1><h2 id="1-redis为什么快？"><a href="#1-redis为什么快？" class="headerlink" title="1.  redis为什么快？"></a>1.  redis为什么快？</h2><p>（1）完全基于内存操作</p><p>（2）数据结构简单，对数据操作简单</p><p>（3）redis执行命令是单线程的，避免了上下文切换带来的性能问题，也不用考虑锁的问题</p><p> (4) 采用了非阻塞的io多路复用机制，使用了单线程来处理并发的连接;内部采用的epoll+自己实现的事件分离器</p><p>其实Redis不是完全多线程的，在核心的网络模型中是多线程的用来处理并发连接，但是数据的操作都是单线程。Redis坚持单线程是因为Redis是的性能瓶颈是网络延迟而不是CPU，多线程对数据读取不会带来性能提升。</p><h2 id="2-redis持久化机制"><a href="#2-redis持久化机制" class="headerlink" title="2.  redis持久化机制"></a>2.  redis持久化机制</h2><p>（1）快照持久化RDB</p><p>redis的默认持久化机制，通过父进程fork一个子进程，子进程将redis的数据快照写入一个临时文件，等待持久化完毕后替换上一次的rdb文件。整个过程主进程不进行任何的io操作。持久化策略可以通过save配置单位时间内执行多少次操作触发持久化。所以RDB的优点是保证redis性能最大化，恢复速度数据较快，缺点是可能会丢失两次持久化之间的数据</p><p>（2）追加持久化AOF</p><p>以日志形式记录每一次的写入和删除操作，策略有每秒同步、每次操作同步、不同步，优点是数据完整性高，缺点是运行效率低，恢复时间长</p><h2 id="3-Redis如何实现key的过期删除？"><a href="#3-Redis如何实现key的过期删除？" class="headerlink" title="3.  Redis如何实现key的过期删除？"></a>3.  Redis如何实现key的过期删除？</h2><p>采用的定期过期+惰性过期</p><p>定期删除 ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。</p><p>惰性删除 ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。</p><h2 id="4-Redis数据类型应用场景"><a href="#4-Redis数据类型应用场景" class="headerlink" title="4.  Redis数据类型应用场景"></a>4.  Redis数据类型应用场景</h2><p>String：可以用来缓存json信息，可以用incr命令实现自增或自减的计数器</p><p>Hash：与String一样可以保存json信息</p><p>List：可以用来做消息队列，list的pop是原子性操作能一定程度保证线程安全</p><p>Set：可以做去重，比如一个用户只能参加一次活动 ;可以做交集求共友</p><p>SortSet ：有序的。可以实现排行榜</p><h2 id="5-Redis缓存穿透如何解决？"><a href="#5-Redis缓存穿透如何解决？" class="headerlink" title="5.  Redis缓存穿透如何解决？"></a>5.  Redis缓存穿透如何解决？</h2><p>缓存穿透是指频繁请求客户端和缓存中都不存在的数据，缓存永远不生效，请求都到达了数据库。</p><p>解决方案：</p><p>（1）在接口上做基础校验，比如id&lt;&#x3D;0就拦截</p><p>（2）缓存空对象：找不到的数据也缓存起来，并设置过期时间，可能会造成短期不一致</p><p>（3）布隆过滤器：在客户端和缓存之间添加一个过滤器，拦截掉一定不存在的数据请求</p><h2 id="6-Redis如何解决缓存击穿？"><a href="#6-Redis如何解决缓存击穿？" class="headerlink" title="6.  Redis如何解决缓存击穿？"></a>6.  Redis如何解决缓存击穿？</h2><p>缓存击穿是值一个key非常热点，key在某一瞬间失效，导致大量请求到达数据库</p><p>解决方案：</p><p>（1）设置热点数据永不过期</p><p>（2）给缓存重建的业务加上互斥锁，缺点是性能低</p><h2 id="7-Redis如何解决缓存雪崩？"><a href="#7-Redis如何解决缓存雪崩？" class="headerlink" title="7.  Redis如何解决缓存雪崩？"></a>7.  Redis如何解决缓存雪崩？</h2><p>缓存雪崩是值某一时间Key同时失效或redis宕机，导致大量请求到达数据库</p><p>解决方案：</p><p>（1）搭建集群保证高可用</p><p>（2）进行数据预热，给不同的key设置随机的过期时间</p><p>（3）给缓存业务添加限流降级，通过加锁或队列控制操作redis的线程数量</p><p>（4）给业务添加多级缓存</p><h2 id="8-Redis分布式锁的实现原理"><a href="#8-Redis分布式锁的实现原理" class="headerlink" title="8.  Redis分布式锁的实现原理"></a>8.  Redis分布式锁的实现原理</h2><p>原理是使用setnx+setex命令来实现，但是会有一系列问题：</p><p>（1）任务时常超过缓存时间，锁自动释放。可以使用Redision看门狗解决</p><p>（2）加锁和释放锁的不是同一线程。可以在Value中存入uuid，删除时进行验证。但是要注意验证锁和删除锁也不是一个原子性操作，可以用lua脚本使之成为原子性操作</p><p>（3）不可重入。可以使用Redision解决（实现机制类似AQS,计数）</p><p>（4）redis集群下主节点宕机导致锁丢失。使用红锁解决</p><h2 id="9-Redis集群方案"><a href="#9-Redis集群方案" class="headerlink" title="9.  Redis集群方案"></a>9.  Redis集群方案</h2><p>(1)主从模式：个master节点，多个slave节点，master节点宕机slave自动变成主节点</p><p>(2)哨兵模式：在主从集群基础上添加哨兵节点或哨兵集群，用于监控master节点健康状态，通过投票机制选择slave成为主节点</p><p>(3)分片集群：主从模式和哨兵模式解决了并发读的问题，但没有解决并发写的问题，因此有了分片集群。分片集群有多个master节点并且不同master保存不同的数据，master之间通过ping相互监测健康状态。客户端请求任意一个节点都会转发到正确节点，因为每个master都被映射到0-16384个插槽上，集群的key是根据key的hash值与插槽绑定</p><h2 id="10-Redis集群主从同步原理"><a href="#10-Redis集群主从同步原理" class="headerlink" title="10. Redis集群主从同步原理"></a>10. Redis集群主从同步原理</h2><p>主从同步第一次是全量同步：slave第一次请求master节点会根据replid判断是否是第一次同步，是的话master会生成RDB发送给slave。</p><p>后续为增量同步：在发送RDB期间，会产生一个缓存区间记录发送RDB期间产生的新的命令,slave节点在加载完后，会持续读取缓存区间中的数据</p><h2 id="11-Redis缓存一致性解决方案"><a href="#11-Redis缓存一致性解决方案" class="headerlink" title="11. Redis缓存一致性解决方案"></a>11. Redis缓存一致性解决方案</h2><p>Redis缓存一致性解决方案主要思考的是删除缓存和更新数据库的先后顺序</p><p>先删除缓存后更新数据库存在的问题是可能会数据不一致，一般使用延时双删来解决，即先删除缓存，再更新数据库，休眠X秒后再次淘汰缓存。第二次删除可能导致吞吐率降低，可以考虑进行异步删除。</p><p>先更新数据库后删除缓存存在的问题是会可能会更新失败，可以采用延时删除。但由于读比写快，发生这一情况概率较小。</p><p>但是无论哪种策略，都可能存在删除失败的问题，解决方案是用中间件canal订阅binlog日志提取需要删除的key，然后另写一段非业务代码去获取key并尝试删除，若删除失败就把删除失败的key发送到消息队列，然后进行删除重试。</p><h2 id="12-Redis内存淘汰策略"><a href="#12-Redis内存淘汰策略" class="headerlink" title="12. Redis内存淘汰策略"></a>12. Redis内存淘汰策略</h2><p>当内存不足时按设定好的策略进行淘汰，策略有(1)淘汰最久没使用的（2）淘汰一段时间内最少使用的（3）淘汰快要过期的</p><h1 id="八、场景题"><a href="#八、场景题" class="headerlink" title="八、场景题"></a>八、场景题</h1><h2 id="1-Java如何实现统计在线人数的功能？"><a href="#1-Java如何实现统计在线人数的功能？" class="headerlink" title="1. Java如何实现统计在线人数的功能？"></a>1. Java如何实现统计在线人数的功能？</h2><p>博主写了另外一篇文章：<a href="http://t.csdn.cn/Q1S4h">http://t.csdn.cn/Q1S4h</a></p><h2 id="2-电商网站可以分成哪些模块（或订单模块要完成哪些功能）？"><a href="#2-电商网站可以分成哪些模块（或订单模块要完成哪些功能）？" class="headerlink" title="2. 电商网站可以分成哪些模块（或订单模块要完成哪些功能）？"></a>2. 电商网站可以分成哪些模块（或订单模块要完成哪些功能）？</h2><p>用户模块（用户账户、会员等级、收货信息）、订单模块（订单编号、类型信息、状态信息、时间信息等）、商品模块（店铺信息、数量、价格等）、支付模块（支付方式、支付时间、支付单号等）、物流模块（物流公司、物流单号、物流状态等）</p><h1 id="九-其他（RabitMQ、数据结构与算法、nginx、git、jwt登录等…）"><a href="#九-其他（RabitMQ、数据结构与算法、nginx、git、jwt登录等…）" class="headerlink" title="九.其他（RabitMQ、数据结构与算法、nginx、git、jwt登录等…）"></a>九.其他（RabitMQ、数据结构与算法、nginx、git、jwt登录等…）</h1><h2 id="1-RabbitMQ如何保证消息不丢失？"><a href="#1-RabbitMQ如何保证消息不丢失？" class="headerlink" title="1.  RabbitMQ如何保证消息不丢失？"></a>1.  RabbitMQ如何保证消息不丢失？</h2><p>发送端：</p><p>（1）创建一个消息状态表，开启RabbitMQ的confirm机制，当收到MQ回传的ACK以更新消息状态</p><p>（2）开启定时任务，隔断时间重新发送状态表中超时的任务，多次投递失败进行报警。</p><p>消费端：</p><p>（1）为了避免消息重复消费，要增加一张消息处理表，消费者拿到消息时判断消息处理表中当前消息是否已经存在，已经存在就抛弃，不存在就进行消费并放入记录表，消费和放入记录表要放在一个事务当中。</p><p>（2）开启手动ack模式，在消费者处理完业务后才返回ACK，避免消息还没有处理完就ACK。</p><p> 具体可以看博主另外一篇文章：(152条消息) RabbitMQ消息丢失的场景，如何保证消息不丢失？（详细讲解，一文看懂）_十八岁讨厌Java的博客-CSDN博客</p><h2 id="2-RabbitMQ如何保证消费顺序"><a href="#2-RabbitMQ如何保证消费顺序" class="headerlink" title="2.  RabbitMQ如何保证消费顺序"></a>2.  RabbitMQ如何保证消费顺序</h2><p>RabbitMQ消费顺序乱了是因为消费者集群拿到消息后对消息处理速度不同导致的，比如可能将增删改变成了增改删。</p><p>解决方法：为RabbitMQ创建多个Queue,每个消费者只监听其中一个Queue,同一类型的消息都放在一个queue中，同一个 queue 的消息是一定会保证有序的。</p><h2 id="3-设计模式六大原则"><a href="#3-设计模式六大原则" class="headerlink" title="3.  设计模式六大原则"></a>3.  设计模式六大原则</h2><p>（1）单一职责原则：一个类或者一个方法只负责一项职责，尽量做到类只有一个行为引起变化；</p><p>（2）里氏替换原则：子类可以扩展父类的功能，但不能改变原有父类的功能</p><p>（3）依赖倒置原则：高层模块不应该依赖底层模块，两者都应该依赖接口或抽象类</p><p>（4）接口隔离原则：建立单一接口，尽量细化接口</p><p>（5）迪米特原则：只关心其它对象能提供哪些方法，不关心过多内部细节</p><p>（6）开闭原则：对于拓展是开放，对于修改是封闭的</p><h2 id="4-设计模式分类"><a href="#4-设计模式分类" class="headerlink" title="4.  设计模式分类"></a>4.  设计模式分类</h2><p>创建型模式：主要是描述对象的创建，代表有单例、原型模式、工厂方法、抽象工厂、建造者模式</p><p>结构型模式：主要描述如何将类或对象按某种布局构成更大的结构，代表有代理、适配器、装饰</p><p>行为型模式：描述类或对象之间如何相互协作共同完成单个对象无法完成的任务，代表有模板方法模式、策略模式、观察者模式、备忘录模式</p><h2 id="5-排序算法的时间复杂度"><a href="#5-排序算法的时间复杂度" class="headerlink" title="5.  排序算法的时间复杂度"></a>5.  排序算法的时间复杂度</h2><p>交换排序：冒泡排序（n^2,稳定）,快速排序(nlogn，不稳定)</p><p>选择排序：直接选择排序（n^2,不稳定），堆排序(nlogn,不稳定s)，</p><p>插入排序：直接插入排序（n^2,稳定），希尔排序(N^1.25，不稳定)</p><p>归并排序(nlogn，稳定)</p><h2 id="6-大量数据排名，采用什么数据结构"><a href="#6-大量数据排名，采用什么数据结构" class="headerlink" title="6.  大量数据排名，采用什么数据结构"></a>6.  大量数据排名，采用什么数据结构</h2><p>当数据很大时，并且有序程度低时，堆排序最快;当数据很大时，并且有序程度高时，快速排序最快</p><h2 id="7-二叉树和堆之间联系或区别"><a href="#7-二叉树和堆之间联系或区别" class="headerlink" title="7.  二叉树和堆之间联系或区别"></a>7.  二叉树和堆之间联系或区别</h2><p>堆是一种特殊的二叉树，所有父结点都比子结点要小的完全二叉树我们称为最小堆，所有父结点都比子结点要大，这样的完全二叉树称为最大堆。</p><h2 id="8-平衡二叉树不平衡如何调整？"><a href="#8-平衡二叉树不平衡如何调整？" class="headerlink" title="8.  平衡二叉树不平衡如何调整？"></a>8.  平衡二叉树不平衡如何调整？</h2><p>按照不平衡的情况有四种调整方法，分别是LR、RL、LL、RR调整</p><p>当不平衡的子树以当前节点为第一个节点往下再数到第三个节点的路径是先左再右时使用LR调整，LR是先将第二个节点旋转到第三个节点的左边，将第一个节点移动到第三个节点的右边；</p><p>RL与LR相反，RR是把第一个节点移到第三个节点左边，RR与LL相反</p><h2 id="9-hash表冲突的解决方法"><a href="#9-hash表冲突的解决方法" class="headerlink" title="9.  hash表冲突的解决方法"></a>9.  hash表冲突的解决方法</h2><p>开放地址法：有线性探测法和平方探测法，当发生冲突时，继续往后找</p><p>再哈希法：构造多个哈希函数，发生冲突后使用下一个函数</p><p>链地址法：将hash值相同的记录用链表链接起来</p><p>建立公共溢出区：将哈希表分为基础表和益处表两部分，发生冲突的填入益处表</p><h2 id="10-cookie和session的联系"><a href="#10-cookie和session的联系" class="headerlink" title="10. cookie和session的联系"></a>10. cookie和session的联系</h2><p>因为http协议是无状态的，无法识别两次请求是否来自同一个客户端，于是就有了cookie和session的概念。</p><p>cookies:是存放在客户浏览器中，每次http请求都会携带，可以用来告知服务端两个请求是否来自同一浏览器，cookied的单个数据大小和存储个数是有限制的，不同浏览器限制不同，cookie的安全性较低。</p><p>session：当客户端第一次请求服务器时服务器为这个请求分配的一块区域，的存储结构为ConcurrentHashMap，服务器会将sessionId返回给客户端并存入cookie。相比cookie他的安全性更高，但失效时间较短</p><p>接下来客户端每次请求带着cookie，服务端会从中获取sessionId来进行匹配，用这套机制就实现了服务器和客户端进行有记忆的对话。</p><h2 id="11-Nginx反向代理是什么，负载均衡算法有哪些？"><a href="#11-Nginx反向代理是什么，负载均衡算法有哪些？" class="headerlink" title="11. Nginx反向代理是什么，负载均衡算法有哪些？"></a>11. Nginx反向代理是什么，负载均衡算法有哪些？</h2><p>反向代理是用来代理服务器接收请求的，然后将请求转发给内部网络的服务器，并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。</p><p>负载均衡算法有：轮询（默认）、带权轮询、ip_hash（按ip哈希结果分配，能解决session共享问题）、url_hash(按访问的URL的哈希结果分配)、fair（根据服务端响应时间分配，响应时间短优先）</p><h1 id="九、秒杀项目相关问题："><a href="#九、秒杀项目相关问题：" class="headerlink" title="九、秒杀项目相关问题："></a>九、秒杀项目相关问题：</h1><h2 id="1-项目流程"><a href="#1-项目流程" class="headerlink" title="1.  项目流程"></a>1.  项目流程</h2><p>​    用户点击下单按钮时，进行三次判断：先判断请求路径是否合法,因为做了动态URL；再判断用户是否已经下单过，就是看redis缓存中有没有用户下单信息；最后判断库存，这里进行了redis库存预减，由于判断库存和预减库存不是原子性操作，所以用lua脚本来执行这一段代码。然后从这里开始使用分布式锁，锁id为用户id+商品id,防止一个用户发送多次请求让redis多次预减。</p><p>   Redis扣减成功后，进行异步下单，直接将正在处理返回给前端，将用户id和商品Id发送RabbitMQ中，负责下单的业务会从消息队列中拿出消息，去执行以下操作：</p><p>1.减库存，减库存时用where 库存&gt;0防止超卖</p><p>2.订单表中生成记录，订单表中的用户id和商品id添加了联合唯一索引防止超卖</p><p> 减库存和增加订单放在一个事务内保证一致性</p><p>3.将用户id和订单id缓存到redis中用来最初对用户重复下单的判断</p><p>4.释放分布式锁，根据value去判断锁是不是当前线程的，判断和删除锁不是原子性操作，所以封装到了lua脚本中</p><ol start="2"><li>提升qps的操作</li></ol><p>（1）页面动静分离，静态页面缓存到redis</p><p>（2）分布式锁拦截不同用户的重复</p><p>（3）限流算法</p><p>（4）验证码限流</p><p>（5）rabbitMq流量削峰</p><p>（6）接口隐藏</p><p>微学院相关问题</p><p>1.如何用springSecurity做的认证授权？</p><p>在数据库中有五张表，分别是菜单表，角色表，用户表，他们是多对多的关系，所以还有角色菜单表，角色用户表</p><p>登录后进入认证过滤器，获取用户名和密码，根据用户名查询用户具有的权限并把用户名和对应权限信息放到redis，JWT生成token后放入cookie,每次调用接口时携带</p><p>然后执行授权过滤器,从header中获取token解析出用户名，根据用户名从redis中获取权限列表，然后springSecurity就能够判断当前请求是否有权限访问</p><p>2.前后端联调经常遇到的问题：</p><p>1.请求方式不匹配</p><p>2.json、x-wwww-form-urlencoded混乱的错误</p><p>3.前后端参数不一致，空指针异常，数据类型不匹配</p><p>4.mp生成的分布式id是19位，JavsScrip只会处理16位，将id生成策略改为String类型</p><p>5.跨域问题：跨域问题是在访问协议、ip地址、端口号这三个有任何一个不一样，相互访问就会出现跨域，可以通过Spring注解解决跨域的 @CrossOrigin，也可以使用nginx反向代理、网关</p><p>6.maven加载项目时，默认不会加载src-java文件夹的xml类型文件，可以 将xml放到resources文件夹下，也可以在yaml和pom中添加配置 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>八股文面试题</title>
      <link href="/2024/05/16/%E5%85%AB%E8%82%A1%E6%96%87%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2024/05/16/%E5%85%AB%E8%82%A1%E6%96%87%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="一、MySQL数据库"><a href="#一、MySQL数据库" class="headerlink" title="一、MySQL数据库"></a>一、MySQL数据库</h2><h3 id="1-在MySQL中如何定位慢查询"><a href="#1-在MySQL中如何定位慢查询" class="headerlink" title="1.在MySQL中如何定位慢查询"></a>1.在MySQL中如何定位慢查询</h3><p>做接口测试的时候，可以在系统中部署运维的监控系统Skywalking，在展示的报表中可以看到具体哪一个接口慢，这里可以看到SQL的具体执行时间，所以可以定位到哪一个SQL出的问题</p><p>然后MySQL中也提供了慢日志查询的功能，可以在MySQl的系统文件中开启这个功能，两个参数，一个是开启慢日志查询，一个是设置SQL语句执行时间超过多少就会被记录</p><h3 id="2-如何分析这个执行的很慢的SQL语句"><a href="#2-如何分析这个执行的很慢的SQL语句" class="headerlink" title="2.如何分析这个执行的很慢的SQL语句"></a>2.如何分析这个执行的很慢的SQL语句</h3><p>可以在SQL语句前面加个EXPLAIN（MySQL的自动执行计划）来查看这条SQL的执行情况，比如看key和key_len看看是不是使用了索引，或者索引是不是失效了，看type字段看看sql是不是有优化空间，是不是存在全索引扫描或者全表扫描，看extra是不是有回表扫描的情况，这个可以通过添加索引或者修改返回字段来解决</p><h3 id="3-什么是索引"><a href="#3-什么是索引" class="headerlink" title="3.什么是索引"></a>3.什么是索引</h3><p>索引是帮助MySQL高效获取数据的数据结构。就是来提高数据检索效率，降低数据库IO成本，也可以通过索引对数据排序，来降低CPU的消耗</p><h3 id="4-索引的底层数据结构、"><a href="#4-索引的底层数据结构、" class="headerlink" title="4.索引的底层数据结构、"></a>4.索引的底层数据结构、</h3><p>MySQL底层默认搜索引擎是InnoDB，使用B+树的数据结构来存储索引，选B+树一个是因为阶数多，路径短，一个是只有叶子节点存指针和数据，非叶子节点都只存指针，三一个是叶子节点是双向链表，方便扫库和区间查询</p><h3 id="5-B树和B-树的区别"><a href="#5-B树和B-树的区别" class="headerlink" title="5.B树和B+树的区别"></a>5.B树和B+树的区别</h3><ol><li><p>B树的节点都存数据，B+树只有叶子节点存</p></li><li><p>范围查询，B+树效率更高，因为B+树叶子节点是双向链表</p></li></ol><h3 id="6-聚簇索引和非聚簇索引"><a href="#6-聚簇索引和非聚簇索引" class="headerlink" title="6.聚簇索引和非聚簇索引"></a>6.聚簇索引和非聚簇索引</h3><p>聚簇索引有且只有一个，一般使用主键索引作为聚簇索引，数据跟索引放到一起</p><p>非聚簇索引也就是二级索引，数据和索引分开放，叶子节点保存的是对应的主键</p><h3 id="7-回表查询"><a href="#7-回表查询" class="headerlink" title="7.回表查询"></a>7.回表查询</h3><p>就是查询返回的字段不在索引字段中，需要拿着二级索引查到的主键，到聚簇索引中找到一整行的数据，然会在返回需要的字段</p><h3 id="8-覆盖索引"><a href="#8-覆盖索引" class="headerlink" title="8.覆盖索引"></a>8.覆盖索引</h3><p>就是说需要查询返回的字段正好在使用的索引中，比如说直接找主键值，就直接使用聚簇索引，一次把整行数据都返回，效率高</p><h3 id="9-MySQL超大分页怎么解决"><a href="#9-MySQL超大分页怎么解决" class="headerlink" title="9.MySQL超大分页怎么解决"></a>9.MySQL超大分页怎么解决</h3><p>超大分页就是说数据量很大的时候，使用了limit分页查询，然后要对数据进行排序，这效率很低，这时候可以用覆盖索引跟子查询解决</p><p>就是说先用子查询找到你要查的那一页的id，然后覆盖索引走聚簇索引，直接能把这些id对应的数据都拿到</p><h3 id="10-索引的创建原则"><a href="#10-索引的创建原则" class="headerlink" title="10.索引的创建原则"></a>10.索引的创建原则</h3><ul><li>数据量很大必须，这个得看业务，十几万几十万？</li><li>查询比较频繁的，比如说排序或者分组什么的</li><li>尽量创建联合索引，走覆盖索引效率高</li><li>要是字段很长可以看着弄个前缀索引</li></ul><h3 id="11-索引失效的情况"><a href="#11-索引失效的情况" class="headerlink" title="11.索引失效的情况"></a>11.索引失效的情况</h3><ol><li>比如说没遵循最左匹配法则</li><li>或者模糊查询%在前面，感觉这种也算(1)</li><li>在添加索引的字段上运算或者类型转换</li><li>复合索引中使用范围查询，右边的条件索引失效</li></ol><h3 id="12-优化SQL"><a href="#12-优化SQL" class="headerlink" title="12.优化SQL"></a>12.优化SQL</h3><ol><li>优化表的设计，字段的类型选用啥的</li><li>索引优化，比如说联合索引包含的字段什么的</li><li>SQL语句优化，使用SELECT * 容易导致索引失效，二级索引什么的</li><li>主从复制、读写分离，不让写入数据影响读的操作</li><li>分库分表</li></ol><h3 id="13-事务的特性"><a href="#13-事务的特性" class="headerlink" title="13.事务的特性"></a>13.事务的特性</h3><p>ACID</p><p>A：原子性（Automicity）要么都成功，要么都失败</p><p>C：一致性（Consistency）数据一致，比如说发生数据交换的时候，一边减少另一边就一定要增加</p><p>I：隔离性（Isolation）事务在发生时，不受其他事务影响、</p><p>D：持久性（Durability）事务提交后，数据持久化，就是保存了</p><h3 id="14-并发事务带来的问题"><a href="#14-并发事务带来的问题" class="headerlink" title="14.并发事务带来的问题"></a>14.并发事务带来的问题</h3><p>脏读：就是说A事务修改了数据还没提交就被B事务读到了</p><p>不可重复读：A事务先读一次数据，B事务修改数据然后提交，A事务又读一次数据，A事务两次读的数据不一样</p><p>幻读：就是A事务先读几行数据，B事务添加了几行数据，A事务再查询的时候发现多了几行数据</p><h3 id="15-怎么解决并发问题？MySQL的隔离级别"><a href="#15-怎么解决并发问题？MySQL的隔离级别" class="headerlink" title="15.怎么解决并发问题？MySQL的隔离级别"></a>15.怎么解决并发问题？MySQL的隔离级别</h3><p>未提交读（read uncommitted）解决不了任何问题</p><p>读已提交（read committed）只解决脏读</p><p>可重复读（repeatable read）解决脏读、不可重复读，也是MySQL默认隔离级别</p><p>串行化（serializable）：解决所有问题，但性能低</p><h3 id="16-undo-log和redo-log的区别"><a href="#16-undo-log和redo-log的区别" class="headerlink" title="16.undo log和redo log的区别"></a>16.undo log和redo log的区别</h3><p>redo log日志记录的时数据页的物理变化，服务宕机的时候用来同步数据，undo log主要记录逻辑日志，事务回滚时使用逆操作来回复原来的数据</p><p>redo log保证事务的持久性，undo log保证事务的原子性和一致性</p><h3 id="17-解决MVCC，怎么保证事务的隔离性"><a href="#17-解决MVCC，怎么保证事务的隔离性" class="headerlink" title="17.解决MVCC，怎么保证事务的隔离性"></a>17.解决MVCC，怎么保证事务的隔离性</h3><p>事务的隔离性由锁和MVCC实现</p><p>MVCC是多版本并发控制，就是维护一个数据的多个版本，是读写操作没有冲突</p><p>MVCC底层分成三个部分：隐藏字段、undo log日志、readView读视图</p><p>隐藏字段有</p><ol><li>rex_id（事务id），记录每一次事务操作id，自增的</li><li>roll_pointer（回滚指针），指向上一个版本的事务版本记录地址</li></ol><p>undo log 记录回滚日志，存储老版本数据，并形成一个版本链，通过roll_pointer</p><p>readView 就是通过一些规则判断出访问哪个版本的数据。rc隔离级别下，每次执行快照读时都生成一次readView；rr隔离级别只有第一次执行快照读时生成readView</p><h3 id="18-主从同步原理"><a href="#18-主从同步原理" class="headerlink" title="18.主从同步原理"></a>18.主从同步原理</h3><p>MySQL主从复制核心是二进制日志，其中记录了所有DDL和DML语句。</p><p>主从同步具体过程：</p><ol><li>Master主库提交事务时，把变更数据记录在二进制文件Binlog中</li><li>从库读取主库的二进制文件Binlog，写入从库的中继日志Relay Log</li><li>slave重做中级日志中的事件，以此改变从库的数据</li></ol><h3 id="19-分库分表"><a href="#19-分库分表" class="headerlink" title="19.分库分表"></a>19.分库分表</h3><p>水平分库：将一个库的数据拆分到多个库中，解决数据量大和高并发，库都相同</p><p>水平分表：解决单表存储和性能问题</p><p>垂直分库：根据业务进行拆分，高并发下提高磁盘IO和网络连接数</p><p>垂直分表：冷热数据分离，多表互不影响</p><h2 id="二、Spring框架"><a href="#二、Spring框架" class="headerlink" title="二、Spring框架"></a>二、Spring框架</h2><h3 id="1-Spring框架中的单例bean时线程安全的吗"><a href="#1-Spring框架中的单例bean时线程安全的吗" class="headerlink" title="1.Spring框架中的单例bean时线程安全的吗"></a>1.Spring框架中的单例bean时线程安全的吗</h3><p>不是线程安全的</p><p>多用户同时请求一个服务时，Spring容器会给每一个请求分配一个线程，多个线程会并发执行这个请求对应的业务逻辑，而Spring框架并没有对单例bean进行任何多线程的封装处理</p><h3 id="2-什么是AOP"><a href="#2-什么是AOP" class="headerlink" title="2.什么是AOP"></a>2.什么是AOP</h3><p>面向切面编程，</p><h3 id="3-Spring中的事务怎么实现"><a href="#3-Spring中的事务怎么实现" class="headerlink" title="3.Spring中的事务怎么实现"></a>3.Spring中的事务怎么实现</h3><p>本质是通过AOP对一个方法前后进行拦截，在执行方法前开启事务，之后根据执行情况提交或者回滚事务</p><h3 id="4-Spring中事务失效的情况"><a href="#4-Spring中事务失效的情况" class="headerlink" title="4.Spring中事务失效的情况"></a>4.Spring中事务失效的情况</h3><ol><li>异常捕获处理：就是自己处理了异常没有抛出，比如try catch，这种时候手动抛出就行</li><li>抛出检查异常，配置roll back for属性为Exception，其实就是默认检查抛出某一类异常，而新的异常不在这类里，就扩大范围</li><li>非public方法导致的异常，将方法改成public</li></ol><h3 id="5-Spring中bean的生命周期"><a href="#5-Spring中bean的生命周期" class="headerlink" title="5.Spring中bean的生命周期"></a>5.Spring中bean的生命周期</h3><ol><li>通过BeanDefinition获取bean的定义信息</li><li>调用构造函数实例化bean</li><li>bean的依赖注入</li><li>处理Aware接口（BeanNameAware、BeanFactoryAware、ApplicationContextAware）</li><li>Bean的后置处理器BeanPoatProcessor-前置</li><li>初始化方法（InitializingBean、init-method）</li><li>Bean的后置处理器BeanPostProcessor-后置</li><li>销毁bean</li></ol><h3 id="6-构造方法出现循环依赖怎么解决"><a href="#6-构造方法出现循环依赖怎么解决" class="headerlink" title="6.构造方法出现循环依赖怎么解决"></a>6.构造方法出现循环依赖怎么解决</h3><p>A依赖于B，B依赖于A，构造函数注入</p><p>因为bean声明周期中构造函数是第一个执行的，所以spring框架并不能解决问题</p><p>使用@lazy懒加载，什么时候需要对象在进行bean对象的创建</p><h3 id="7-SpringMVC的执行流程"><a href="#7-SpringMVC的执行流程" class="headerlink" title="7.SpringMVC的执行流程"></a>7.SpringMVC的执行流程</h3><ol><li>用户发送请求到前端控制器DisPatcherServlet</li><li>DisPatcherSerclet收到请求调用HandlerMapping（处理映射器）</li><li>HandlerMapping找到具体的处理器，生成处理器对象以及处理器拦截器（如果有），在一起返回给DisPatcherServlet</li><li>dispatcherServlet调用handlerAdapter（处理器适配器）</li><li>HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）</li><li>方法上添加了@ResponseBody</li><li>通过HttpMessageConverter来返回结果转换为JSON并相应</li></ol><h3 id="8-Spring框架的常见注解"><a href="#8-Spring框架的常见注解" class="headerlink" title="8.Spring框架的常见注解"></a>8.Spring框架的常见注解</h3><p>@component、@Controller、@Service、@Repository</p><p>@Autowired、@Import</p><h3 id="9-Springboot的自动装配"><a href="#9-Springboot的自动装配" class="headerlink" title="9.Springboot的自动装配"></a>9.Springboot的自动装配</h3><ol><li>springboot项目中的引导类上有个注解@SpringBootApplication，他对三个注解进行封装:@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan</li><li>其中@EnableAutoConfiguration是实现自动化配置的核心注解，就是通过@import注解导入对应的配置选择器。内部读取了相关jar包的classpath路径下META-INF&#x2F;spring.factories文件中配置的全类名，在这些配置类中定义的bean对根据条件注解所指定的条件来决定是否需要将其导入Spring容器中</li><li>条件判断会有像@ConditionalOnClass这样的注解，判断是否有对象的class文件，有就加载这个类，把这个配置的所有Bean放入spring容器中使用</li></ol><h2 id="三、MyBatis"><a href="#三、MyBatis" class="headerlink" title="三、MyBatis"></a>三、MyBatis</h2><h3 id="1-MyBatis的执行流程"><a href="#1-MyBatis的执行流程" class="headerlink" title="1.MyBatis的执行流程"></a>1.MyBatis的执行流程</h3><ol><li>读取MyBatis的配置文件：mybatis-config.xml加载运行环境和映射文件</li><li>构建会话工厂SqlSessionFactory</li><li>会话工厂创建SqlSession对象（包含了执行SQL语句的所有方法）</li><li>操作数据库的接口，Executor执行器，同时负责查询缓存的维护</li><li>Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</li><li>输入参数映射</li><li>输出参数映射</li></ol><h3 id="2-Mybatis是否支持延迟加载"><a href="#2-Mybatis是否支持延迟加载" class="headerlink" title="2.Mybatis是否支持延迟加载"></a>2.Mybatis是否支持延迟加载</h3><ul><li>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要时就不加载</li><li>Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载</li><li>在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false，默认关闭</li></ul><h3 id="3-延迟加载的底层原理"><a href="#3-延迟加载的底层原理" class="headerlink" title="3.延迟加载的底层原理"></a>3.延迟加载的底层原理</h3><ol><li>使用CGLIB创建目标对象的代理对象</li><li>当调用目标方法时，进入拦截器invoke方法，发现目标方法时null值，执行sql查询</li><li>获取数据以后，调用set方法设置属性值，在继续查询目标方法，就有值了</li></ol><h3 id="4-Mybatis的一级、二级缓存"><a href="#4-Mybatis的一级、二级缓存" class="headerlink" title="4.Mybatis的一级、二级缓存"></a>4.Mybatis的一级、二级缓存</h3><ul><li>一级缓存：基于PerpetualCache的HashMap本地缓存，存储作用域时Session，当会话进行flush或close之后，改Session中的所有Cache清空，默认打开一级缓存</li><li>二级缓存：基于namespace和mapper的作用域起作用的，不依赖于SQL session，默认使用PerpetualCache，HashMap存储。要单独开启，一个是核心配置，一个是mapper映射文件</li></ul><h3 id="5-Mybatis的二级缓存什么时候会清理缓存中的数据"><a href="#5-Mybatis的二级缓存什么时候会清理缓存中的数据" class="headerlink" title="5.Mybatis的二级缓存什么时候会清理缓存中的数据"></a>5.Mybatis的二级缓存什么时候会清理缓存中的数据</h3><p>当某一个作用域（一级缓存Session&#x2F;二级缓存Namespaces）进行了新增、修改、删除操作后，默认该作用域下所有select中的缓存将被clear</p><h2 id="四、Java基础"><a href="#四、Java基础" class="headerlink" title="四、Java基础"></a>四、Java基础</h2><h3 id="1-接口和抽象类的区别"><a href="#1-接口和抽象类的区别" class="headerlink" title="1.接口和抽象类的区别"></a>1.接口和抽象类的区别</h3><p>相同点：</p><ul><li>继承抽象类或者实现接口的子类都必须重写或者说实现其中的抽象方法</li><li>他俩都不能被实例化</li></ul><p>不同点：</p><ul><li>抽象类中可以有普通方法和代码块，而接口中只能有抽象方法、静态方法和默认方法</li><li>抽象类中的成员变量可以是多种类型的，而接口中只能是public static final类型，还必须赋值</li><li>抽象类中可以有构造方法，接口没有</li></ul><h3 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.重载和重写的区别"></a>2.重载和重写的区别</h3><p>重载发生在同一个类中，就是方法名相同，参数列表、返回值类型、权限修饰符都可以不同</p><p>重写发生在具有继承关系的子类中，方法名、参数列表、返回值类型、权限修饰符都相同，重写方法的权限修饰符要大于父类，声明异常的范围要小于父类，然后private和final的方法不能重写</p><h3 id="3-和equals的区别"><a href="#3-和equals的区别" class="headerlink" title="3.&#x3D;&#x3D;和equals的区别"></a>3.&#x3D;&#x3D;和equals的区别</h3><ul><li>当&#x3D;&#x3D;作用于基本数据类型时，比较的是值，作用于引用数据类型时，比较的是内存地址</li><li>equals方法在Object类中，Object是所有类的直接或者间接父类，没有重写过的equals方法比较的是两者之前的内存地址，经过String类重写过的，比较的是字符值，重写equals后也要重写hashcode方法</li></ul><h3 id="4-异常处理机制"><a href="#4-异常处理机制" class="headerlink" title="4.异常处理机制"></a>4.异常处理机制</h3><ol><li>try catch finally ：捕获异常，finally中的代码一定会在最后执行，捕获异常以后程序也继续执行</li><li>throws：抛出异常，一般用在方法的声明处，就是throws + 异常类型，会把异常抛给方法的调用者，出现异常后，程序终止</li><li>throw：手动抛出异常，一般在代码里，后面跟着new 异常类型</li></ol><h3 id="5-HashMap的实现原理"><a href="#5-HashMap的实现原理" class="headerlink" title="5.HashMap的实现原理"></a>5.HashMap的实现原理</h3><ol><li>在jdk1.8以后，hashmap的底层使用数组+链表+红黑树的机制，hashmap的特点是线程不安全，key不重复，key和value都可以为null</li><li>扩容机制：hashmap的数组容量为16，负载因子为0.75，当hashmap中的元素个数超过容量*负载因子时，就会进行扩容，就是创建一个容量是原来两倍的数组，然后把原数组的值都复制过来。当数组长度大于64或者链表长度大于8时，链表变成红黑树，小于6变回来</li><li>存取原理：计算key的hash值，进行二次hash，得到key在数组中的位置。如果这个位置有值，就通过equals进行比较，结果为true，就覆盖这个值，结果为false，就尾插法插入这个位置挂的链表，头插法在并发扩容的情况下会发生数据循环</li></ol><h3 id="6-怎么使用线程安全的hashmap"><a href="#6-怎么使用线程安全的hashmap" class="headerlink" title="6.怎么使用线程安全的hashmap"></a>6.怎么使用线程安全的hashmap</h3><ol><li>使用hashtable</li><li>使用ConcurrentHashMap</li><li>使用Collections.synchronizedHashMap方法</li></ol><h3 id="7-ConCurrentHashMap怎么保证线程安全"><a href="#7-ConCurrentHashMap怎么保证线程安全" class="headerlink" title="7.ConCurrentHashMap怎么保证线程安全"></a>7.ConCurrentHashMap怎么保证线程安全</h3><ul><li>1.7中采用分段锁，就是将一个map分成16个段，每一个段都是一个hashmap，每次操作都对其中的一个段加锁</li><li>1.8采用CAS+synchronized，每次插入数据的时候看数组下标是不是第一次插入，是的话就用CAS方式插入，判断数组是不是在进行扩容，是的话就线程参与扩容。删除元素用synchronized修饰，保证并发下移除元素的线程安全</li></ul><h3 id="8-HashMap和HashTable的区别"><a href="#8-HashMap和HashTable的区别" class="headerlink" title="8.HashMap和HashTable的区别"></a>8.HashMap和HashTable的区别</h3><ol><li>hashtable中每个方法都有synchronized修饰，因此线程安全，效率低</li><li>hashtable中key不允许为null</li><li>hashtable中key只进行一次hash，hashmap两次</li><li>hashtable底层是链表+数组，hashmap底层链表+数组+红黑树</li></ol><h3 id="9-ArrayList和LinkedList区别"><a href="#9-ArrayList和LinkedList区别" class="headerlink" title="9.ArrayList和LinkedList区别"></a>9.ArrayList和LinkedList区别</h3><ul><li>arraylist底层是动态数组，默认容量为10，元素个数达到上限开始扩容为原来的1.5倍，在内存中连续的，查找快，插入慢</li><li>linkedlist底层是链表，没有扩容机制，在内存中是离散的，查找慢，插入快</li></ul><h3 id="10-怎么保证ArrayList的线程安全"><a href="#10-怎么保证ArrayList的线程安全" class="headerlink" title="10.怎么保证ArrayList的线程安全"></a>10.怎么保证ArrayList的线程安全</h3><ol><li>Collections.synchronizedlist方法</li><li>使用Vector，底层都是动态数组，每个方法都加了synchronized</li></ol><h3 id="11-String、StringBuilder、StringBuffer的区别"><a href="#11-String、StringBuilder、StringBuffer的区别" class="headerlink" title="11.String、StringBuilder、StringBuffer的区别"></a>11.String、StringBuilder、StringBuffer的区别</h3><ul><li>String是char[]数组，线程安全的，使用fianl修饰，每次改变string都会生成一个新的string，在把指针指向新string</li><li>StringBuffer是线程安全的，也是synchronized，可对字符串进行操作</li><li>StringBuilder是线程不安全的，可对字符串进行操作</li><li>少数据量用String，单线程大数据量用String Builder，多线程大数据量用StringBuffer</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java基础-笔记</title>
      <link href="/2024/04/15/Java%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/04/15/Java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="Java基本语法"><a href="#Java基本语法" class="headerlink" title="Java基本语法"></a>Java基本语法</h2><h3 id="语言概述"><a href="#语言概述" class="headerlink" title="语言概述"></a>语言概述</h3><h4 id="整体语言概述"><a href="#整体语言概述" class="headerlink" title="整体语言概述"></a>整体语言概述</h4><p><img src="/../image/JavaPic/Java%E6%95%B4%E4%BD%93%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0.awebp"></p><h4 id="Java语言概述"><a href="#Java语言概述" class="headerlink" title="Java语言概述"></a>Java语言概述</h4><h5 id="基础常识："><a href="#基础常识：" class="headerlink" title="基础常识："></a>基础常识：</h5><p>软件：即一系列按照特定顺序组织的计算机数据和指令的集合。分为<code>系统软件</code>和<code>应用软件</code>。</p><ul><li>系统软件：windows、mac os、linux、unix、android、ios，…</li><li>应用软件：word、ppt、画图板</li></ul><p>人机交互方式：图形化界面 vs 命令行方式</p><p>应用程序 &#x3D; 算法 + 数据结构</p><h5 id="计算机语言的发展迭代史"><a href="#计算机语言的发展迭代史" class="headerlink" title="计算机语言的发展迭代史"></a>计算机语言的发展迭代史</h5><p>第一代：机器语言</p><p>第二代：汇编语言</p><p>第三代：高级语言</p><ul><li>面向过程：C、Pascal、Fortran</li><li>面向对象：Java、JS、Python、Scala</li></ul><blockquote><p><strong>Java语言版本迭代概述</strong></p><p>1991年 Green项目，开发语言最初命名为Oak (橡树)</p><p>1994年，开发组意识到Oak 非常适合于互联网</p><p>1996年，发布JDK 1.0，约8.3万个网页应用Java技术来制作</p><p>1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最</p><p>1998年，发布JDK 1.2，同年发布企业平台J2EE</p><p>1999年，Java分成J2SE、J2EE和J2ME，JSP&#x2F;Servlet技术诞生</p><p>2004年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性，更名为JDK 5.0</p><p>2005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME</p><p>2009年，Oracle公司收购SUN，交易价格74亿美元</p><p>2011年，发布JDK 7.0</p><p>2014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本</p><p>2017年，发布JDK 9.0，最大限度实现模块化</p><p>2018年3月，发布JDK 10.0，版本号也称为18.3</p><p>2018年9月，发布JDK 11.0，版本号也称为18.9</p></blockquote><h5 id="Java语言应用的领域"><a href="#Java语言应用的领域" class="headerlink" title="Java语言应用的领域"></a>Java语言应用的领域</h5><p>Java Web开发：后台开发</p><p>大数据开发：数据挖掘</p><p>Android应用程序开发：客户端开发</p><h5 id="Java语言的特点"><a href="#Java语言的特点" class="headerlink" title="Java语言的特点"></a>Java语言的特点</h5><p>面向对象性：</p><ul><li>两个要素：类、对象；</li><li>三个特征：封装、继承、多态；</li></ul><p>健壮性：① 去除了C语言中的指针 ②自动的垃圾回收机制 –&gt;仍然会出现内存溢出、内存泄漏</p><p>跨平台型：write once,run anywhere（一次编译，到处运行），归功于JVM（Java编译器）</p><p><img src="/../image/JavaPic/Java%E7%A8%8B%E5%BA%8F.awebp"></p><h4 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h4><h5 id="JDK、JRE、JVM的关系"><a href="#JDK、JRE、JVM的关系" class="headerlink" title="JDK、JRE、JVM的关系"></a>JDK、JRE、JVM的关系</h5><p><img src="/../image/JavaPic/%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB.awebp"></p><h5 id="JDK的下载、安装"><a href="#JDK的下载、安装" class="headerlink" title="JDK的下载、安装"></a>JDK的下载、安装</h5><p>下载：官网，GitHub</p><p>安装：傻瓜式安装：JDK 、JRE</p><p>注意：安装软件的路径中不能包含中文、空格</p><h5 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h5><p>path环境变量：windows操作系统执行命令时所要搜寻的路径</p><p>为什么要配置path：希望java的开发工具（<code>javac.exe</code>，<code>java.exe</code>)在任何的文件路径下都可以执行成功。</p><p><img src="/../image/JavaPic/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F.awebp"></p><h4 id="第一个Java程序"><a href="#第一个Java程序" class="headerlink" title="第一个Java程序"></a>第一个Java程序</h4><p>编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建一个java源文件：HelloWorld.java</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloChina</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello,World!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译：</p><p><code>javac HelloWorld.java</code></p><p>运行：</p><p><code>java HelloWord</code></p><p>常见问题：</p><p><img src="/../image/JavaPic/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.awebp"></p><p>总结：</p><p>① java程序编写-编译-运行的过程</p><ul><li>编写：我们将编写的java代码保存在以”.java”结尾的源文件中</li><li>编译：使用javac.exe命令编译我们的java源文件。格式：javac 源文件名.java</li><li>运行：使用java.exe命令解释运行我们的字节码文件。 格式：java 类名</li></ul><p>② 在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。而且要求声明为public的类的类名必须与源文件名相同。</p><p>③ 程序的入口是main()方法。格式是固定的。</p><p>④ 输出语句：</p><ul><li><code>System.out.println()</code>：先输出数据，然后换行；</li><li><code>System.out.print()</code>：只输出数据；</li></ul><p>⑤ 每一行执行语句都以<code>;</code>结束。</p><p>⑥ 编译的过程：编译以后，会生成一个或多个字节码文件。字节码文件的文件名与java源文件中的类名相同。</p><h4 id="注释与API文档"><a href="#注释与API文档" class="headerlink" title="注释与API文档"></a>注释与API文档</h4><ol><li>注释:Comment</li></ol><ul><li>单行注释：<code>//注释内容</code></li><li>多行注释：<code>/* 注释内容 */</code></li><li>文档注释：<code>/**  注释内容  */</code></li></ul><p><strong>作用：</strong></p><p>① 对所写的程序进行解释说明，增强可读性。方便自己，方便别人</p><p>② 调试所写的代码</p><p><strong>特点：</strong> </p><p>① 单行注释和多行注释，注释了的内容不参与编译。换句话说，编译以后生成的 <code>.class</code> 结尾的字节码文件中不包含注释掉的信息 </p><p>② 注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</p><p>③ 多行注释不可以嵌套使用</p><p>Java API 文档：</p><ul><li>API: application programming interface。习惯上：将语言提供的类库，都称为API.</li><li>API文档：针对于提供的类库如何使用，给的一个说明书。类似于《新华字典》</li></ul><p>良好的编程风格</p><ul><li><p>正确的注释和注释风格</p><ul><li><p>使用文档注释来注释整个类或整个方法</p></li><li><p>如果注释方法中的某一个步骤，使用单行或多行注释。</p></li></ul></li><li><p>正确的缩进和空白</p></li><li><p>使用一次tab操作，实现缩进</p></li><li><p>运算符两边习惯性各加一个空格。比如：2 + 4 * 5。</p></li></ul><p>块的风格</p><ul><li><p>行尾风格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args)</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>次行风格</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String args)</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>命名风格</p><ul><li><p>包名：多单词组成时所有字母都小写：<code>xxxyyyzzz</code></p></li><li><p>类名、接口名：多单词组成时，所有单词的首字母大写： <code>XxxYyyZzz</code>(大驼峰式)</p></li><li><p>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写： <code>xxxYyyZzz</code>(小驼峰式)</p></li><li><p>常量名：所有字母都大写。多单词时每个单词用下划线连接： <code>XXX_YYY_ZZZ</code></p></li></ul><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="关键字与标识符"><a href="#关键字与标识符" class="headerlink" title="关键字与标识符"></a>关键字与标识符</h4><h5 id="java关键字的使用"><a href="#java关键字的使用" class="headerlink" title="java关键字的使用"></a>java关键字的使用</h5><p>定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）</p><p>特点：关键字中所字母都为小写</p><p><img src="/../image/JavaPic/%E5%85%B3%E9%94%AE%E5%AD%97-1.awebp"></p><p><img src="/../image/JavaPic/%E5%85%B3%E9%94%AE%E5%AD%97-2.awebp"></p><h5 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h5><p>现Java版本尚未使用，但以后版本可能会作为关键字使用。</p><p>具体哪些保留字：<code>goto</code> 、<code>const</code></p><p>注意：命名标识符时要避免使用这些保留字</p><h5 id="标识符的使用"><a href="#标识符的使用" class="headerlink" title="标识符的使用"></a>标识符的使用</h5><p>定义：凡是自己可以起名字的地方都叫标识符。</p><p>涉及到的结构：包名、类名、接口名、变量名、方法名、常量名</p><ul><li><p><em>规则：(必须要遵守。否则，编译不通过)</em></p><ul><li><p>由26个英文字母大小写，0-9, _或$组成。</p></li><li><p>数字不可以开头。</p></li><li><p>不可以使用关键字和保留字，但能包含关键字和保留字。</p></li><li><p>Java中严格区分大小写，长度无限制。</p></li><li><p>标识符不能包含空格。</p></li></ul></li><li><p><em>规范：（可以不遵守，不影响编译和运行。但是要求大家遵守）</em></p><ul><li><p>包名：多单词组成时所有字母都小写：<code>xxxyyyzzz</code></p></li><li><p>类名、接口名：多单词组成时，所有单词的首字母大写： <code>XxxYyyZzz</code>(大驼峰式)</p></li><li><p>变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写： <code>xxxYyyZzz</code>(小驼峰式)</p></li><li><p>常量名：所有字母都大写。多单词时每个单词用下划线连接： <code>XXX_YYY_ZZZ</code></p></li></ul></li></ul><blockquote><p>注意点： 在起名字时，为了提高阅读性，要尽量意义，“见名知意”。</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">1.介绍</span><br><span class="line">软件中随处可见命名。我们给变量、函数、参数、类和包命名。我们给源代码及源代码所在目录命名。</span><br><span class="line">这么多命名要做，不妨做好它。下文列出了取个好名字的几条简单规则。</span><br><span class="line"></span><br><span class="line">2.名副其实,见名知意</span><br><span class="line">变量名太随意，haha、list1、ok、theList 这些都没啥意义</span><br><span class="line"></span><br><span class="line">3.避免误导</span><br><span class="line">包含List、import、java等类名、关键字或特殊字；</span><br><span class="line">字母o与数字0，字母l与数字1等</span><br><span class="line">提防使用不同之处较小的名称。比如：XYZControllerForEfficientHandlingOfStrings与XYZControllerForEfficientStorageOfStrings</span><br><span class="line"></span><br><span class="line">4.做有意义的区分</span><br><span class="line">反面教材，变量名：a1、a2、a3</span><br><span class="line">避免冗余，不要出现Variable、表字段中避免出现table、字符串避免出现nameString，直接name就行，知道是字符串类型</span><br><span class="line">再比如：定义了两个类：Customer类和CustomerObject类，如何区分？</span><br><span class="line">定义了三个方法：getActiveAccount()、getActiveAccounts()、getActiveAccountInfo()，如何区分？</span><br><span class="line"></span><br><span class="line">5.使用读得出来的名称</span><br><span class="line">不要使用自己拼凑出来的单词，比如：xsxm(学生姓名)；genymdhms(生成日期，年、月、日、时、分、秒)</span><br><span class="line">所谓的驼峰命名法，尽量使用完整的单词</span><br><span class="line"></span><br><span class="line">6.使用可搜索的名称</span><br><span class="line">一些常量，最好不直接使用数字，而指定一个变量名，这个变量名可以便于搜索到.</span><br><span class="line">比如：找MAX_CLASSES_PER_STUDENT很容易，但想找数字7就麻烦了。</span><br><span class="line"></span><br><span class="line">7.避免使用编码</span><br><span class="line">7.1 匈牙利语标记法:即变量名表明该变量数据类型的小写字母开始。例如，szCmdLine的前缀sz表示“以零结束的字符串”。</span><br><span class="line">7.2 成员前缀:避免使用前缀，但是Android中一个比较好的喜欢用m表示私有等，个人感觉比较好</span><br><span class="line">7.3 接口和实现:作者不喜欢把接口使用I来开头，实现也希望只是在后面添加Imp</span><br><span class="line"></span><br><span class="line">8.避免思维映射</span><br><span class="line">比如传统上惯用单字母名称做循环计数器。所以就不要给一些非计数器的变量命名为：i、j、k等</span><br><span class="line"></span><br><span class="line">9.类名</span><br><span class="line">类名与对象名应该是名词与名词短语。如Customer、WikiPage、Account和AddressParser。避免使用Data或Info这样的类名。</span><br><span class="line">不能使动词。比如：Manage、Process</span><br><span class="line"></span><br><span class="line">10.方法名</span><br><span class="line">方法名应当是动词或者动词短语。如postPayment、deletePage或save</span><br><span class="line"></span><br><span class="line">11.别扮可爱</span><br><span class="line">有的变量名叫haha、banana</span><br><span class="line">别用eatMyShorts()表示abort()</span><br><span class="line"></span><br><span class="line">12.每个概念对应一个词</span><br><span class="line">项目中同时出现controllers与managers，为什么不统一使用其中一种？</span><br><span class="line">对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。</span><br><span class="line"></span><br><span class="line">13.别用双关语</span><br><span class="line">有时可能使用add并不合适，比例insert、append。add表示完整的新添加的含义。     </span><br><span class="line"></span><br><span class="line">14. 使用解决方案领域名称</span><br><span class="line">看代码的都是程序员，所以尽量用那些计算机科学术语、算法名、模式名、数学术语，</span><br><span class="line">依据问题所涉领域来命名不算是聪明的做法。</span><br><span class="line"></span><br><span class="line">2.15 使用源自所涉问题领域的名称</span><br><span class="line">如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉问题领域而来的名称吧。</span><br><span class="line">至少，负责维护代码的程序员就能去请教领域专家了。</span><br><span class="line"></span><br><span class="line">2.16 添加有意义的语境</span><br><span class="line">可以把相关的变量放到一个类中，使用这个类来表明语境。</span><br><span class="line"></span><br><span class="line">2.17 不要添加没用的语境</span><br><span class="line">名字中带有项目的缩写，这样完全没有必要。比如有一个名为“加油站豪华版”（Gas Station Deluxe）的项目，</span><br><span class="line">在其中给每个类添加GSD前缀就不是什么好策略。</span><br><span class="line"></span><br><span class="line">2.18 最后的话</span><br><span class="line">取好名字最难的地方在于需要良好的描述技巧和共有文化背景。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h4><h5 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h5><p>按数据类型：</p><p><img src="/../image/JavaPic/%E6%8C%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB.awebp"></p><ul><li>整型：<code>byte</code> (1字节&#x3D;8bit) \  <code>short</code> (2字节) \  <code>int</code> (4字节) \  <code>long</code> (8字节)</li></ul><p>​① <code>byte</code> 范围：-128 ~ 127</p><p>​② 声明 <code>long</code> 型变量，必须以 <code>l</code> 或 <code>L</code> 结尾</p><p>​③ 通常，定义整型变量时，使用 <code>int</code> 型。</p><p>​④整型的常量，默认类型是：<code>int</code> 型</p><ul><li>浮点型：<code>float </code>(4字节) \ <code>double</code> (8字节)</li></ul><p>​① 浮点型，表示带小数点的数值</p><p>​② <code>float</code> 表示数值的范围比long还大</p><p>​③ 定义 <code>float</code> 类型变量时，变量要以 <code>f</code> 或 <code>F</code> 结尾</p><p>​④ 通常，定义浮点型变量时，使用 <code>double</code> 型。</p><p>​⑤ 浮点型的常量，默认类型为：<code>double</code></p><ul><li>字符型：<code>char</code> (1字符 &#x3D; 2字节)</li></ul><p>​① 定义 <code>char</code> 型变量，通常使用一对’’,内部只能写一个字符</p><p>​② 表示方式：1.声明一个字符 2.转义字符 3.直接使用 Unicode 值来表示字符型常量</p><ul><li>布尔型：<code>boolean</code></li></ul><p>​① 只能取两个值之一：<code>true</code> 、 <code>false</code></p><p>​② 常常在条件判断、循环结构中使用</p><p>按照声明位置：</p><p><img src="/../image/JavaPic/%E6%8C%89%E5%A3%B0%E6%98%8E%E4%BD%8D%E7%BD%AE%E5%88%86%E7%B1%BB.awebp"></p><h5 id="定义变量的格式："><a href="#定义变量的格式：" class="headerlink" title="定义变量的格式："></a>定义变量的格式：</h5><ul><li>数据类型 变量名 &#x3D; 变量值；</li><li>数据类型 变量名，变量名 &#x3D; 变量值；</li></ul><h5 id="变量使用的注意点："><a href="#变量使用的注意点：" class="headerlink" title="变量使用的注意点："></a>变量使用的注意点：</h5><p>​① 变量必须先声明，后使用；</p><p>​② 变量都定义在其作用域内。在作用域内，它是有效的，出了作用域，就失效了；</p><p>​③ 同一个作用域内，不可以声明两个同名的变量；</p><h5 id="基本数据类型变量间运算规则"><a href="#基本数据类型变量间运算规则" class="headerlink" title="基本数据类型变量间运算规则"></a>基本数据类型变量间运算规则</h5><p>① 涉及到的基本数据类型：除了 <code>boolean</code> 之外的其他7种</p><p>② 自动类型转换(只涉及7种基本数据类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> 、<span class="type">char</span> 、<span class="type">short</span> --&gt; <span class="type">int</span> --&gt; <span class="type">long</span> --&gt; <span class="type">float</span> --&gt; <span class="type">double</span></span><br></pre></td></tr></table></figure><blockquote><p>结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</p><p>特别的：当byte、char、short三种类型的变量做运算时，结果为int型</p><p>说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</p></blockquote><p>③ 强制类型转换(只涉及7种基本数据类型）：自动类型提升运算的逆运算。需要使用强转符：<code>()</code></p><blockquote><p>注意点：强制类型转换，可能导致精度损失。</p></blockquote><p>④ <code>String</code> 与8种基本数据类型间的运算</p><ul><li>String属于引用数据类型，翻译为：字符串</li><li>声明String类型变量时，使用一对 <code>&quot;&quot;</code></li><li>String可以和8种基本数据类型变量做运算，且运算只能是连接运算：<code>+</code></li><li>运算的结果仍然是String类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">123</span>;<span class="comment">//编译错误</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>)s1;<span class="comment">//编译错误</span></span><br></pre></td></tr></table></figure><h4 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h4><h5 id="编程中涉及的进制及表示方式："><a href="#编程中涉及的进制及表示方式：" class="headerlink" title="编程中涉及的进制及表示方式："></a>编程中涉及的进制及表示方式：</h5><p>二进制(binary)： 0&#x2F;1，满2进1以0b或0B开头。</p><p>十进制 (decimal)：0-9，满10进1。</p><p>八进制(octal)：0-7，满8进1，以数字0开头表示。</p><p>十六进制(hex)：0-9及A-F，满16进1，以0x或0X开头表示。此处的A-F不区分大小写如：0x21AF+1&#x3D;0X21B0</p><h5 id="二进制的使用说明："><a href="#二进制的使用说明：" class="headerlink" title="二进制的使用说明："></a>二进制的使用说明：</h5><p>计算机底层的存储方式：所有数字在计算机底层都以二进制形式存在。</p><p>二进制数据的存储方式：所有的数值，不管正负，底层都以补码的方式存储。</p><blockquote><p>原码、反码、补码的说明：</p></blockquote><ul><li>正数：三码合一</li><li>负数：<ul><li>负数的原码：直接将一个数值换成二进制数。最高位是符号位。</li><li>负数的反码：是对原码按位取反，只是最高位（符号位）确定为1。</li><li>负数的补码：其反码加1。</li></ul></li></ul><h5 id="进制之间的转化："><a href="#进制之间的转化：" class="headerlink" title="进制之间的转化："></a>进制之间的转化：</h5><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p>算术运算符： <code>+ - + - * / % (前)++ (后)++ (前)-- (后)-- +</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//除号：/</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">result1</span> <span class="operator">=</span> num1 / num2;</span><br><span class="line">System.out.println(result1);<span class="comment">//2</span></span><br><span class="line"><span class="comment">// %:取余运算</span></span><br><span class="line"><span class="comment">//结果的符号与被模数的符号相同</span></span><br><span class="line"><span class="comment">//开发中，经常使用%来判断能否被除尽的情况。</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m1 % n1 = &quot;</span> + m1 % n1);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">m2</span> <span class="operator">=</span> -<span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m2 % n2 = &quot;</span> + m2 % n2);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">m3</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> -<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m3 % n3 = &quot;</span> + m3 % n3);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">m4</span> <span class="operator">=</span> -<span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n4</span> <span class="operator">=</span> -<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m4 % n4 = &quot;</span> + m4 % n4);</span><br><span class="line"><span class="comment">//(前)++ :先自增1，后运算</span></span><br><span class="line"><span class="comment">//(后)++ :先运算，后自增1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b1</span> <span class="operator">=</span> ++a1;</span><br><span class="line">System.out.println(<span class="string">&quot;a1 = &quot;</span> + a1 + <span class="string">&quot;,b1 = &quot;</span> + b1);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b2</span> <span class="operator">=</span> a2++;</span><br><span class="line">System.out.println(<span class="string">&quot;a2 = &quot;</span> + a2 + <span class="string">&quot;,b2 = &quot;</span> + b2);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a3</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">++a3;<span class="comment">//a3++;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b3</span> <span class="operator">=</span> a3;</span><br><span class="line"><span class="comment">//(前)-- :先自减1，后运算</span></span><br><span class="line"><span class="comment">//(后)-- :先运算，后自减1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">a4</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b4</span> <span class="operator">=</span> a4--;<span class="comment">//int b4 = --a4;</span></span><br><span class="line">System.out.println(<span class="string">&quot;a4 = &quot;</span> + a4 + <span class="string">&quot;,b4 = &quot;</span> + b4);</span><br></pre></td></tr></table></figure><blockquote><ol><li>(前)++ :先自增1，后运算 (后)++ :先运算，后自增1</li><li>(前)– :先自减1，后运算 (后)– :先运算，后自减1</li><li>连接符：+：只能使用在String与其他数据类型变量之间使用。</li></ol></blockquote><h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><p>赋值运算符：<code>= += -= *= /= %=</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i2,j2;</span><br><span class="line"><span class="comment">//连续赋值</span></span><br><span class="line">i2 = j2 = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//***************</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">10</span>,j3 = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">num1 += <span class="number">2</span>;<span class="comment">//num1 = num1 + 2;</span></span><br><span class="line">System.out.println(num1);<span class="comment">//12</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">num2 %= <span class="number">5</span>;<span class="comment">//num2 = num2 % 5;</span></span><br><span class="line">System.out.println(num2);</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//s1 = s1 + 2;//编译失败</span></span><br><span class="line">s1 += <span class="number">2</span>;<span class="comment">//结论：不会改变变量本身的数据类型</span></span><br><span class="line">System.out.println(s1);</span><br></pre></td></tr></table></figure><blockquote><p>【特别说明的】 1.运算的结果不会改变变量本身的数据类型</p></blockquote><p>① 开发中，如果希望变量实现+2的操作，有几种方法？(前提：<code>int num = 10;</code>)</p><ul><li>方式一：<code>num = num + 2;</code></li><li>方式二：<code>num += 2;</code> (推荐)</li></ul><p>② 开发中，如果希望变量实现+1的操作，有几种方法？(前提：<code>int num = 10;</code>)</p><ul><li>方式一：<code>num = num + 1;</code></li><li>方式二：<code>num += 1;</code></li><li>方式三：<code>num++;</code> (推荐)</li></ul><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><p>比较运算符（关系运算符）: <code>== != &gt; &lt; &gt;= &lt;= instanceof</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(i == j);<span class="comment">//false</span></span><br><span class="line">System.out.println(i = j);<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">System.out.println(b2 == b1);<span class="comment">//false</span></span><br><span class="line">System.out.println(b2 = b1);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>【特别说明的】</strong></p><ul><li>比较运算符的结果是 <code>boolean</code> 类型；</li><li><code>&lt; &gt;= &lt;=</code> :只能使用在数值类型的数据之间；</li><li><code>==</code> 和 <code>!=</code>: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Account</span> <span class="variable">acct1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="type">Account</span> <span class="variable">acct2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">1000</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> (acct1 == acct2);<span class="comment">//比较两个Account是否是同一个账户。</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> (acct1 != acct2);<span class="comment">//</span></span><br></pre></td></tr></table></figure><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>逻辑运算符：<code>&amp; &amp;&amp; | || ! ^</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//区分&amp; 与 &amp;&amp;</span></span><br><span class="line"><span class="comment">//相同点1：&amp; 与  &amp;&amp; 的运算结果相同</span></span><br><span class="line"><span class="comment">//相同点2：当符号左边是true时，二者都会执行符号右边的运算</span></span><br><span class="line"><span class="comment">//不同点：当符号左边是false时，&amp;继续执行符号右边的运算。&amp;&amp;不再执行符号右边的运算。</span></span><br><span class="line"><span class="comment">//开发中，推荐使用&amp;&amp;</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">b1 = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b1 &amp; (num1++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">b2 = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b2 &amp;&amp; (num2++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>|</code> 与 <code>||</code> 的区别</strong></p><p>相同点1：<code>|</code> 与 <code>||</code> 的运算结果相同；</p><p>相同点2：当符号左边是false时，二者都会执行符号右边的运算；</p><p>不同点：当符号左边是true时，<code>|</code> 继续执行符号右边的运算，而 <code>||</code> 不再执行符号右边的运算；</p><p>开发中，推荐使用<code>||</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">b3 = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b3 | (num3++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num3 = &quot;</span> + num3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">b4 = <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b4 || (num4++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num4 = &quot;</span> + num4);</span><br></pre></td></tr></table></figure><blockquote><p>【特别说明的】</p><p>逻辑运算符操作的都是 <code>boolean</code> 类型的变量。而且结果也是 <code>boolean</code> 类型</p></blockquote><h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><p>位运算符：<code>&lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ~</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">21</span>;</span><br><span class="line">i = -<span class="number">21</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;i &lt;&lt; 2 :&quot;</span> + (i &lt;&lt; <span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;i &lt;&lt; 3 :&quot;</span> + (i &lt;&lt; <span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;i &lt;&lt; 27 :&quot;</span> + (i &lt;&lt; <span class="number">27</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;m &amp; n :&quot;</span> + (m &amp; n));</span><br><span class="line">System.out.println(<span class="string">&quot;m | n :&quot;</span> + (m | n));</span><br><span class="line">System.out.println(<span class="string">&quot;m ^ n :&quot;</span> + (m ^ n));</span><br></pre></td></tr></table></figure><blockquote><p>【面试题】 你能否写出最高效的2 * 8的实现方式？ 答案：2 &lt;&lt; 3 或 8 &lt;&lt; 1</p></blockquote><blockquote><p><strong>【特别说明的】</strong></p><ul><li>位运算符操作的都是整型的数据</li><li><code>&lt;&lt;</code> ：在一定范围内，每向左移1位，相当于 * 2 &gt;&gt;:在一定范围内，每向右移1位，相当于 &#x2F; 2</li></ul></blockquote><blockquote><p>！！！<strong>交换两个变量的值</strong></p></blockquote><p>① 借用临时变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num1;</span><br><span class="line">num1 = num2;</span><br><span class="line">num2 = temp;</span><br></pre></td></tr></table></figure><p>② 加减交换:节省内存，但是会超出存储范围，而且只能适用于数值型运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = num1 + num2;</span><br><span class="line">num2 = num1 - num2;</span><br><span class="line">num1 = num1 - num2; </span><br></pre></td></tr></table></figure><p>③ 使用位运算符：只适用于数值型运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;</span><br></pre></td></tr></table></figure><h5 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h5><p>三元运算符：<code>(条件表达式) ? 表达式1 : 表达式2</code></p><p>① 获取两个整数的较大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> (a &gt; b) ? a : b;</span><br></pre></td></tr></table></figure><p>② 获取三个数的最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> (a &gt; b) ? a : b;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> (temp &gt; c) ? temp : c;</span><br></pre></td></tr></table></figure><blockquote><p><strong>【特别说明】</strong></p><p><strong>说明:</strong></p><p>① 条件表达式的结果为boolean类型</p><p>② 根据条件表达式真或假，决定执行表达式1，还是表达式2. 如果表达式为true，则执行表达式1。 如果表达式为false，则执行表达式2。</p><p>③ 表达式1 和表达式2要求是一致的。</p><p>④ 三元运算符可以嵌套使用</p><p>⑤ 凡是可以使用三元运算符的地方，都可以改写为if-else反之，不成立。</p><p>⑥ 如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。</p></blockquote><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><blockquote><p>分支结构</p></blockquote><h5 id="if-else条件判断结构"><a href="#if-else条件判断结构" class="headerlink" title="if-else条件判断结构"></a>if-else条件判断结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">结构一：</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结构二：二选一</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结构三：n选一</span><br><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">执行表达式n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>else 结构是可选的。</li><li>针对于条件表达式：<ul><li>如果多个条件表达式之间是“互斥”关系(或没有交集的关系),哪个判断和执行语句声明在上面还是下面，无所谓。</li><li>如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构声明在上面。</li><li>如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小的声明在范围大的上面。否则，范围小的就没机会执行了。</li></ul></li><li>if-else结构是可以相互嵌套的。</li><li>如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。</li></ul><h5 id="switch-case选择结构"><a href="#switch-case选择结构" class="headerlink" title="switch-case选择结构"></a>switch-case选择结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">执行语句<span class="number">1</span>;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">执行语句<span class="number">2</span>;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">执行语句n;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用说明：</strong></p><p>① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句；当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止；</p><p>② break,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构；</p><p>③ switch结构中的表达式，只能是如下的6种数据类型之一：</p><p><code>byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)</code> ④ case 之后只能声明常量。不能声明范围；</p><p>⑤ break关键字是可选的；</p><p>⑥ default:相当于if-else结构中的else，default结构是可选的，而且位置是灵活的；</p><p><code>如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并；</code></p><p><code>break在switch-case中是可选的；</code></p><blockquote><p>循环结构</p></blockquote><h5 id="循环结构的四要素"><a href="#循环结构的四要素" class="headerlink" title="循环结构的四要素"></a>循环结构的四要素</h5><p>① 初始化条件</p><p>② 循环条件 —&gt;是boolean类型</p><p>③ 循环体</p><p>④ 迭代条件</p><p>说明：通常情况下，循环结束都是因为②中循环条件返回false了。</p><h5 id="三种循环结构："><a href="#三种循环结构：" class="headerlink" title="三种循环结构："></a>三种循环结构：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for循环结构</span></span><br><span class="line"><span class="keyword">for</span>(①;②;④)&#123;</span><br><span class="line">③</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//while循环结构</span></span><br><span class="line">①</span><br><span class="line"><span class="keyword">while</span>(②)&#123;</span><br><span class="line">③;</span><br><span class="line">④;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ②</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//do-while循环结构</span></span><br><span class="line">①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">③;</span><br><span class="line">④;</span><br><span class="line">&#125;<span class="keyword">while</span>(②);</span><br><span class="line"><span class="comment">//执行过程：① - ③ - ④ - ② - ③ - ④ - ... - ②</span></span><br></pre></td></tr></table></figure><p>说明：写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</p><p>for和while循环总结：</p><ol><li>开发中，基本上我们都会从for、while中进行选择，实现循环结构。</li><li>for循环和while循环是可以相互转换的！ 区别：for循环和while循环的初始化条件部分的作用范围不同。</li><li>我们写程序，要避免出现死循环。</li></ol><p>说明：</p><ol><li>do-while循环至少会执行一次循环体！</li><li>开发中，使用for和while更多一些。较少使用do-while</li><li>数组循环比遍历通常用for循环</li><li>触发条件复杂的用while循环</li></ol><h5 id="无限循环结构-while-true-或-for"><a href="#无限循环结构-while-true-或-for" class="headerlink" title="无限循环结构: while(true) 或 for(;;)"></a>无限循环结构: while(true) 或 for(;;)</h5><p>总结：如何结束一个循环结构？</p><p>方式一：当循环条件是false时</p><p>方式二：在循环体中，执行break</p><h5 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h5><p>嵌套循环:将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环</p><p>内层循环：循环结构A</p><p>外层循环：循环结构B</p><p>说明：</p><p>① 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次；</p><p>② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次；</p><p>③ 外层循环控制行数，内层循环控制列数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//练习一：</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">******</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= <span class="number">4</span>;j++ )&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">6</span>;i++)&#123;</span><br><span class="line">        System.out.print(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//练习二：</span></span><br><span class="line"><span class="comment">/*i(行号)j(*的个数)</span></span><br><span class="line"><span class="comment">*11</span></span><br><span class="line"><span class="comment">**22</span></span><br><span class="line"><span class="comment">***33</span></span><br><span class="line"><span class="comment">****44</span></span><br><span class="line"><span class="comment">*****55</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">5</span>;i++)&#123;<span class="comment">//控制行数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= i;j++)&#123;<span class="comment">//控制列数</span></span><br><span class="line">        System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充: 衡量一个功能代码的优劣：</p><ol><li>正确性</li><li>可读性</li><li>健壮性</li><li>高效率与低存储：时间复杂度 、空间复杂度 （衡量算法的好坏）</li></ol><p>1.2.6 关键字：break 和 continue</p><p>break和continue关键字的使用</p><table><thead><tr><th></th><th><strong>使用范围</strong></th><th><strong>循环中的作用（不同点）</strong></th><th><strong>相同点</strong></th></tr></thead><tbody><tr><td>break</td><td>switch-case 循环结构中</td><td>结束当前循环</td><td>关键字后面不能声明执行语句</td></tr><tr><td>continue</td><td>循环结构中</td><td>结束当次循环</td><td>关键字后面不能声明执行语句</td></tr></tbody></table><p>补充：带标签的break和continue的使用</p><p>return在方法中讲。</p><h4 id="补充-：-Scanner类的应用"><a href="#补充-：-Scanner类的应用" class="headerlink" title="补充 ： Scanner类的应用"></a>补充 ： Scanner类的应用</h4><p>如何从键盘获取不同类型的变量：需要使用Scanner类</p><p>具体实现步骤：</p><ol><li>导包：<code>import java.util.Scanner;</code></li><li>Scanner的实例化：<code>Scanner scan = new Scanner(System in);</code></li><li>调用Scanner类的相关方法（<code>next() / nextXxx()</code>），来获取指定类型的变量；</li></ol><blockquote><p>注意： 需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：<code>InputMisMatchException</code> 导致程序终止</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.导包：import java.util.Scanner;</span></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScannerTest</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//2.Scanner的实例化</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.调用Scanner类的相关方法</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的姓名：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scan.next();</span><br><span class="line">System.out.println(name);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的芳龄：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">System.out.println(age);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的体重：&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> scan.nextDouble();</span><br><span class="line">System.out.println(weight);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;你是否相中我了呢？(true/false)&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isLove</span> <span class="operator">=</span> scan.nextBoolean();</span><br><span class="line">System.out.println(isLove);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于char型的获取，Scanner没有提供相关的方法。只能获取一个字符串</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入你的性别：(男/女)&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> scan.next();<span class="comment">//&quot;男&quot;</span></span><br><span class="line"><span class="type">char</span> <span class="variable">genderChar</span> <span class="operator">=</span> gender.charAt(<span class="number">0</span>);<span class="comment">//获取索引为0位置上的字符</span></span><br><span class="line">System.out.println(genderChar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-数组"><a href="#Java-数组" class="headerlink" title="Java-数组"></a>Java-数组</h2><h3 id="数组的概述"><a href="#数组的概述" class="headerlink" title="数组的概述"></a>数组的概述</h3><h4 id="数组的理解"><a href="#数组的理解" class="headerlink" title="数组的理解"></a>数组的理解</h4><p>数组(Array)，是多个相同类型数据一定顺序排列的集合，并使用一个名字命名，并通过编号的 方式对这些数据进行统一管理。</p><h4 id="数组相关的概念"><a href="#数组相关的概念" class="headerlink" title="数组相关的概念"></a>数组相关的概念</h4><p>数组名 元素 角标、下标、索引 数组的长度：元素的个数</p><h4 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h4><ol><li>数组是序排列的</li><li>数组属于引用数据类型的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型</li><li>创建数组对象会在内存中开辟一整块连续的空间</li><li>数组的长度一旦确定，就不能修改。</li></ol><h4 id="数组的分类"><a href="#数组的分类" class="headerlink" title="数组的分类"></a>数组的分类</h4><p>① 按照维数：一维数组、二维数组、。。。</p><p>② 按照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组</p><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ol><li>数据与数据之间的逻辑关系：集合（关系很弱）、一对一（数组里面的元素）、一对多（二叉树）、多对多（社交网络）</li><li>数据的存储结构： 线性表：顺序表（比如：数组）、链表、栈、队列 树形结构：二叉树 图形结构：图</li></ol><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><h4 id="一维数组的声明与初始化"><a href="#一维数组的声明与初始化" class="headerlink" title="一维数组的声明与初始化"></a>一维数组的声明与初始化</h4><p>正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;<span class="comment">//声明</span></span><br><span class="line">num = <span class="number">10</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;<span class="comment">//声明 + 初始化</span></span><br><span class="line"><span class="type">int</span>[] ids;<span class="comment">//声明</span></span><br><span class="line"><span class="comment">//1.1 静态初始化:数组的初始化和数组元素的赋值操作同时进行</span></span><br><span class="line">ids = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>&#125;;</span><br><span class="line"><span class="comment">//1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>[] arr4 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//类型推断</span></span><br></pre></td></tr></table></figure><p>错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int[] arr1 = new int[];</span></span><br><span class="line"><span class="comment">//int[5] arr2 = new int[5];</span></span><br><span class="line"><span class="comment">//int[] arr3 = new int[3]&#123;1,2,3&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="一维数组元素的引用"><a href="#一维数组元素的引用" class="headerlink" title="一维数组元素的引用"></a>一维数组元素的引用</h4><p>角标调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的角标（或索引从0开始的，到数组的长度-1结束。</span></span><br><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;王铭&quot;</span>;</span><br><span class="line">names[<span class="number">1</span>] = <span class="string">&quot;王赫&quot;</span>;</span><br><span class="line">names[<span class="number">2</span>] = <span class="string">&quot;张学良&quot;</span>;</span><br><span class="line">names[<span class="number">3</span>] = <span class="string">&quot;孙居龙&quot;</span>;</span><br><span class="line">names[<span class="number">4</span>] = <span class="string">&quot;王宏志&quot;</span>;<span class="comment">//charAt(0)</span></span><br></pre></td></tr></table></figure><h4 id="数组的属性"><a href="#数组的属性" class="headerlink" title="数组的属性"></a>数组的属性</h4><p>length</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(names.length);<span class="comment">//5</span></span><br><span class="line">System.out.println(ids.length);</span><br></pre></td></tr></table></figure><blockquote><p>说明： 数组一旦初始化，其长度就是确定的。arr.length 数组长度一旦确定，就不可修改。</p></blockquote><h4 id="一维数组的遍历"><a href="#一维数组的遍历" class="headerlink" title="一维数组的遍历"></a>一维数组的遍历</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; names.length;i++)&#123;</span><br><span class="line">System.out.println(names[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一维数组元素的默认初始化值"><a href="#一维数组元素的默认初始化值" class="headerlink" title="一维数组元素的默认初始化值"></a>一维数组元素的默认初始化值</h4><ul><li>数组元素是整型：0</li><li>数组元素是浮点型：0.0</li><li>数组元素是char型：0或’\u0000’，而非’0’</li><li>数组元素是boolean型：false</li><li>数组元素是引用数据类型：null</li></ul><h4 id="一维数组的内存结构"><a href="#一维数组的内存结构" class="headerlink" title="一维数组的内存结构"></a>一维数组的内存结构</h4><p><img src="/../image/JavaPic/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.awebp"></p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><h4 id="如何理解二维数组"><a href="#如何理解二维数组" class="headerlink" title="如何理解二维数组"></a>如何理解二维数组</h4><p>数组属于引用数据类型 数组的元素也可以是引用数据类型 一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组。</p><h4 id="二维数组的初始化与声明"><a href="#二维数组的初始化与声明" class="headerlink" title="二维数组的初始化与声明"></a>二维数组的初始化与声明</h4><p>正确：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;<span class="comment">//一维数组</span></span><br><span class="line"><span class="comment">//静态初始化</span></span><br><span class="line"><span class="type">int</span>[][] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//动态初始化1</span></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">//动态初始化2</span></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="comment">//也是正确的写法：</span></span><br><span class="line"><span class="type">int</span>[] arr4[] = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[] arr5[] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;&#125;;<span class="comment">//类型推断</span></span><br></pre></td></tr></table></figure><p>错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String[][] arr4 = new String[][4];</span></span><br><span class="line"><span class="comment">//String[4][3] arr5 = new String[][];</span></span><br><span class="line"><span class="comment">//int[][] arr6 = new int[4][3]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;</span></span><br></pre></td></tr></table></figure><h4 id="如何调用二维数组元素"><a href="#如何调用二维数组元素" class="headerlink" title="如何调用二维数组元素"></a>如何调用二维数组元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arr1[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">//2</span></span><br><span class="line">System.out.println(arr2[<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">arr3[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line">System.out.println(arr3[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">System.out.println(arr3[<span class="number">0</span>]);<span class="comment">//</span></span><br></pre></td></tr></table></figure><h4 id="二维数组的属性"><a href="#二维数组的属性" class="headerlink" title="二维数组的属性"></a>二维数组的属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arr4.length);<span class="comment">//3</span></span><br><span class="line">System.out.println(arr4[<span class="number">0</span>].length);<span class="comment">//3</span></span><br><span class="line">System.out.println(arr4[<span class="number">1</span>].length);<span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="遍历二维数组元素"><a href="#遍历二维数组元素" class="headerlink" title="遍历二维数组元素"></a>遍历二维数组元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr4.length;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr4[i].length;j++)&#123;</span><br><span class="line">System.out.print(arr4[i][j] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二维数组元素的默认初始化值"><a href="#二维数组元素的默认初始化值" class="headerlink" title="二维数组元素的默认初始化值"></a>二维数组元素的默认初始化值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* 规定：二维数组分为外层数组的元素，内层数组的元素</span><br><span class="line">* <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line">* 外层元素：arr[<span class="number">0</span>],arr[<span class="number">1</span>]等</span><br><span class="line">* 内层元素：arr[<span class="number">0</span>][<span class="number">0</span>],arr[<span class="number">1</span>][<span class="number">2</span>]等</span><br><span class="line">* </span><br><span class="line">*   ⑤ 数组元素的默认初始化值 </span><br><span class="line">*   针对于初始化方式一：比如：<span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line">*      外层元素的初始化值为：地址值</span><br><span class="line">*      内层元素的初始化值为：与一维数组初始化情况相同</span><br><span class="line">*      </span><br><span class="line">*   针对于初始化方式二：比如：<span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line">*   外层元素的初始化值为：<span class="literal">null</span></span><br><span class="line">*      内层元素的初始化值为：不能调用，否则报错。</span><br></pre></td></tr></table></figure><h4 id="二维数组的内存结构"><a href="#二维数组的内存结构" class="headerlink" title="二维数组的内存结构"></a>二维数组的内存结构</h4><p><img src="/../image/JavaPic/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.awebp"></p><h3 id="数组的常见算法"><a href="#数组的常见算法" class="headerlink" title="数组的常见算法"></a>数组的常见算法</h3><h4 id="数组的创建与元素赋值"><a href="#数组的创建与元素赋值" class="headerlink" title="数组的创建与元素赋值"></a>数组的创建与元素赋值</h4><p>杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.新建二位数组，动态初始化</span></span><br><span class="line"><span class="type">int</span>[][] yangHui = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][];</span><br><span class="line"><span class="comment">// 2.为二维数组赋值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yangHui.length; i++) &#123;</span><br><span class="line">    yangHui[i] = <span class="keyword">new</span> <span class="title class_">int</span>[i + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 2.1为首末元素赋值</span></span><br><span class="line">    yangHui[i][<span class="number">0</span>] = yangHui[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 2.2为其余元素赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; yangHui[i].length - <span class="number">1</span>; j++) &#123;<span class="comment">//</span></span><br><span class="line">        yangHui[i][j] = yangHui[i - <span class="number">1</span>][j - <span class="number">1</span>] + yangHui[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.打印输出二维数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; yangHui.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; yangHui[i].length; j++) &#123;<span class="comment">// 第0个位置没有元素</span></span><br><span class="line">        System.out.print(yangHui[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="针对于数值型的数组"><a href="#针对于数值型的数组" class="headerlink" title="针对于数值型的数组"></a>针对于数值型的数组</h4><p>最大值、最小值、总和、平均数等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.找到数组中的最大值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">maxArr</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (maxArr &lt; arr[i]) &#123;</span><br><span class="line">        maxArr = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组中的最大值为：&quot;</span> + maxArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.找到数组中的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">minArr</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (minArr &gt; arr[i]) &#123;</span><br><span class="line">        minArr = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组中的最小值为：&quot;</span> + minArr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.找到数组中的平均数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    num += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组的平均数为：&quot;</span> + (num / arr.length));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.求总和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    num1 += arr[i];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;数组的总和为：&quot;</span> + num1);</span><br></pre></td></tr></table></figure><h4 id="数组的赋值与复制"><a href="#数组的赋值与复制" class="headerlink" title="数组的赋值与复制"></a>数组的赋值与复制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.数组的赋值</span></span><br><span class="line">String[] str1 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">str1 = str;</span><br><span class="line">str1[<span class="number">2</span>] = <span class="string">&quot;AA&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">    System.out.print(str[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><ul><li><p>赋值</p><p>如何理解：如何理解：将array1保存的数组的地址值赋给了array2，使得array1和array2共同指向堆空间中的同一个数组实体。</p><p><img src="/../image/JavaPic/%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC.awebp"></p></li><li><p>复制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.1数组的复制</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str1.length; i++) &#123;</span><br><span class="line">    str1[i] = str[i];</span><br><span class="line">    System.out.print(str1[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何理解：我们通过new的方式，给array2在堆空间中新开辟了数组的空间。将array1数组中的元素值一个一个的赋值到array2数组中。</p><p><img src="/../image/JavaPic/%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6.awebp"></p></li></ul><h4 id="数组元素的反转"><a href="#数组元素的反转" class="headerlink" title="数组元素的反转"></a>数组元素的反转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length / <span class="number">2</span>;i++)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[arr.length - i -<span class="number">1</span>];</span><br><span class="line">    arr[arr.length - i -<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = arr.length - <span class="number">1</span>;i &lt; j;i++,j--)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组中指定元素的查找：搜索、检索"><a href="#数组中指定元素的查找：搜索、检索" class="headerlink" title="数组中指定元素的查找：搜索、检索"></a>数组中指定元素的查找：搜索、检索</h4><ul><li><p>线性查找</p><p>实现思路：通过遍历的方式，一个一个的数据进行比较、查找。 适用性：具有普遍适应性</p></li><li><p>二分法查找</p><p>实现思路：每次比较中间值，折半的方式检索。 适用性：（前提：数组必须有序）</p></li></ul><h4 id="数组的排序算法"><a href="#数组的排序算法" class="headerlink" title="数组的排序算法"></a>数组的排序算法</h4><blockquote><p>十大排序算法</p></blockquote><ul><li>选择排序：<ul><li>直接选择排序、堆排序</li></ul></li><li>交换排序：<ul><li>冒泡排序、快速排序</li></ul></li><li>插入排序：<ul><li>直接插入排序、折半插入排序、希尔排序</li></ul></li><li>归并排序</li><li>桶排序</li><li>基数排序</li></ul><p>理解：</p><p>1）衡量排序算法的优劣：时间复杂度、空间复杂度、稳定性</p><p>2）排序的分类：内部排序 与 外部排序（需要借助磁盘）</p><p>3）不同排序算法的时间复杂度</p><p><img src="/../image/JavaPic/%E4%B8%8D%E5%90%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.awebp"></p><p>冒泡排序的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">21</span>, <span class="number">43</span>, <span class="number">64</span>, <span class="number">76</span>, <span class="number">878</span>, <span class="number">432</span>, <span class="number">21</span> &#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">              <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                  <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                  arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                  arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">          System.out.print(arr[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="Arrays工具类的使用"><a href="#Arrays工具类的使用" class="headerlink" title="Arrays工具类的使用"></a>Arrays工具类的使用</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>① 定义在java.util包下。 ② Arrays:提供了很多操作数组的方法。</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr1[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">21</span>, <span class="number">43</span>, <span class="number">542</span>, <span class="number">432</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr2[] = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">32</span>, <span class="number">43</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">76</span>, <span class="number">54</span>, <span class="number">68</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.Arrays.equals(arr1, arr2):判断数组是否相等</span></span><br><span class="line">System.out.println(Arrays.equals(arr1, arr2));</span><br><span class="line"><span class="comment">// 2.Arrays.toString(arr1):输出数组信息</span></span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.Arrays.fill(arr1, 2):将指定值填充到数组中</span></span><br><span class="line">Arrays.fill(arr1, <span class="number">2</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"><span class="comment">// 4.Arrays.sort(arr2):对数组进行排序</span></span><br><span class="line">Arrays.sort(arr2);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br><span class="line"><span class="comment">// 5.Arrays.binarySearch(arr2, 1):堆排序好的数组用二分法检索指定值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr2, <span class="number">1</span>);</span><br><span class="line">System.out.println(index);</span><br></pre></td></tr></table></figure><h3 id="数组的常见异常"><a href="#数组的常见异常" class="headerlink" title="数组的常见异常"></a>数组的常见异常</h3><h4 id="数组角标越界异常"><a href="#数组角标越界异常" class="headerlink" title="数组角标越界异常"></a>数组角标越界异常</h4><p>ArrayIndexOutOfBoundsException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(arr[-<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h4><p>NullPointerException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：</span></span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr1 = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr1[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：</span></span><br><span class="line"><span class="type">int</span>[][] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line">System.out.println(arr2[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况：</span></span><br><span class="line">String[] arr3 = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;;</span><br><span class="line">arr3[<span class="number">0</span>] = <span class="literal">null</span>;</span><br><span class="line">System.out.println(arr3[<span class="number">0</span>].toString());</span><br></pre></td></tr></table></figure><blockquote><p>提示：一旦程序出现异常，未处理时，就终止执行。</p></blockquote><h2 id="Java-异常处理"><a href="#Java-异常处理" class="headerlink" title="Java-异常处理"></a>Java-异常处理</h2><h3 id="异常的定义"><a href="#异常的定义" class="headerlink" title="异常的定义"></a>异常的定义</h3><p>在Java语言中，将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）</p><h4 id="异常的体系结构"><a href="#异常的体系结构" class="headerlink" title="异常的体系结构"></a>异常的体系结构</h4><p>Java程序在执行过程中所发生的异常事件可分为两类：</p><ul><li><p><code>Error</code>： Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如： <code>StackOverflowError</code> 和OOM。一般不编写针对性的代码进行处理。</p></li><li><pre><code>Exception<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：其它因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。如：</span><br><span class="line"></span><br><span class="line">  - 空指针访问</span><br><span class="line">  - 试图读取不存在的文件</span><br><span class="line">  - 网络连接中断</span><br><span class="line">  - 数组角标越界</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">异常的体系结构</span><br><span class="line"> * java.lang.Throwable</span><br><span class="line"> * |-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line"> * |-----java.lang.Exception:可以进行异常的处理</span><br><span class="line"> * |------编译时异常(checked)不会生成字节码文件</span><br><span class="line"> * |-----IOException</span><br><span class="line"> * |-----FileNotFoundException</span><br><span class="line"> * |-----ClassNotFoundException</span><br><span class="line"> * |------运行时异常(unchecked,RuntimeException)</span><br><span class="line"> * |-----NullPointerException//空指针异常</span><br><span class="line"> * |-----ArrayIndexOutOfBoundsException//数组角标越界</span><br><span class="line"> * |-----ClassCastException//类型转化异常</span><br><span class="line"> * |-----NumberFormatException//编码格式异常</span><br><span class="line"> * |-----InputMismatchException//输入不匹配</span><br><span class="line"> * |-----ArithmeticException//算术异常</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>java中异常类的继承关系</p><p><img src="/../image/JavaPic/Java%E4%B8%AD%E5%BC%82%E5%B8%B8%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.awebp"></p><h4 id="按照异常发生的时间可以分为两类"><a href="#按照异常发生的时间可以分为两类" class="headerlink" title="按照异常发生的时间可以分为两类"></a>按照异常发生的时间可以分为两类</h4><ul><li><p>编译时异常：执行 <code>javac.exe</code> 命令时，可能出现的异常：</p><p>指编译器要求必须处置的异常。即程序在运行时由于外界因素造成的一般性异常。编译器要求Java程序必须捕获或声明所有编译时异常对于这类异常，如果程序不处理，可能会带来意想不到的结果。</p></li><li><p>运行时异常：执行 <code>java.exe</code> 命令时，出现的异常：</p><p>指编译器不要求强制处置的异常。一般是指编程时的逻辑错误，是程序员应该积极避免其出现的异常。 <code>java. lang. Runtime Exception</code> 类及它的子类都是运行时异常。对于这类异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。</p><p><img src="/../image/JavaPic/Java%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.awebp"></p></li></ul><h4 id="常见的异常类型"><a href="#常见的异常类型" class="headerlink" title="常见的异常类型"></a>常见的异常类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line"><span class="comment">//ArithmeticException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputMismatchException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">    System.out.println(score);</span><br><span class="line"></span><br><span class="line">    scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line">    <span class="comment">//int[] arr = new int[10];</span></span><br><span class="line">    <span class="comment">//System.out.println(arr[10]);</span></span><br><span class="line">    <span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NullPointerException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//int[] arr = null;</span></span><br><span class="line">    <span class="comment">//System.out.println(arr[3]);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    str = <span class="literal">null</span>;</span><br><span class="line">    System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line">    <span class="comment">//FileInputStream fis = new FileInputStream(file);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//int data = fis.read();</span></span><br><span class="line">    <span class="comment">//while(data != -1)&#123;</span></span><br><span class="line">    <span class="comment">//System.out.print((char)data);</span></span><br><span class="line">    <span class="comment">//data = fis.read();</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//fis.close();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h3><h4 id="Java异常处理的抓抛模型"><a href="#Java异常处理的抓抛模型" class="headerlink" title="Java异常处理的抓抛模型"></a>Java异常处理的抓抛模型</h4><p>**过程一：”抛”**程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出对象以后，其后的代码就不再执行。</p><p>关于异常对象的产生：</p><ul><li>系统自动生成的异常对象</li><li>手动的生成一个异常对象，并抛出（<code>throw</code>）</li></ul><p>**过程二：”抓”**可以理解为异常的处理方式：① <code>try-catch-finally</code> ② <code>throws</code></p><h4 id="异常梳理方式一：try-catch-finally"><a href="#异常梳理方式一：try-catch-finally" class="headerlink" title="异常梳理方式一：try-catch-finally"></a>异常梳理方式一：try-catch-finally</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式3</span></span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//一定会执行的代码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>finally</code> 是可选的。</p></li><li><p>使用 <code>try</code> 将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去 <code>catch</code> 中进行匹配</p></li><li><p>一旦 <code>try</code> 中的异常对象匹配到某一个 <code>catch</code> 时，就进入 <code>catch</code> 中进行异常的处理。一旦处理完成，就跳出当前的 <code>try-catch</code> 结构（在没写 <code>finally</code> 的情况。继续执行其后的代码）</p></li><li><p><code>catch</code>中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓；<code>catch</code>中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则会报错</p></li><li><p>常用的异常对象处理的方式： ① <code>String getMessage()</code> ② <code>printStackTrace()</code></p></li><li><p>在<code>try</code> 结构中声明的变量，再出了 <code>try</code> 结构以后，就不能再被调用</p></li><li><p><code>try-catch-finally</code> 结构可以嵌套</p></li></ul><blockquote><p><strong>如何看待代码中的编译时异常和运行时异常？</strong></p><ul><li>使用 <code>try-catch-finally</code> 处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用 <code>try-catch-finally</code> 将一个编译时可能出现的异常，延迟到运行时出现。</li><li>开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写 <code>try-catch-finally</code> 了。但是针对于编译时异常，一定要考虑异常的处理。</li></ul></blockquote><ul><li><p><code>finally</code> 是可选的</p></li><li><p><code>finally</code> 中声明的是一定会被执行的代码。即使catch中又出现异常了，<code>try</code> 中包含 <code>return</code> 语句，或者<code>catch</code>中 <code>return</code> 包含语句等情况，<code>finally</code> 中的代码也会被执行。</p></li><li><p>像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放的代码，就需要声明在 <code>finally</code> 中。</p></li></ul><h4 id="异常处理方式二：throws抛出"><a href="#异常处理方式二：throws抛出" class="headerlink" title="异常处理方式二：throws抛出"></a>异常处理方式二：throws抛出</h4><p><code>throws + 异常类型</code> 写在方法的声明处。指明此方法执行时，可能会抛出的异常类型。 一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足 <code>throws</code> 后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</p><h4 id="对比两种处理方式"><a href="#对比两种处理方式" class="headerlink" title="对比两种处理方式"></a>对比两种处理方式</h4><p><code>try-catch-finally</code> 真正的将异常给处理掉了。 <code>throws</code> 的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。</p><h4 id="开发中如何选择"><a href="#开发中如何选择" class="headerlink" title="开发中如何选择"></a>开发中如何选择</h4><ul><li><p>如果父类中被重写的方法没 <code>throws</code> 方式处理异常，则子类重写的方法也不能使用 <code>throws</code>，意味着如果子类重写的方法中异常，必须使用 <code>try-catch-finally</code> 方式处理。</p></li><li><p>执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用<code>throws</code> 的方式进行处理。而执行的方法a可以考虑使用 <code>try-catch-finally</code> 方式进行处理。</p></li></ul><blockquote><p>补充： 方法重写的规则之一： 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p></blockquote><h3 id="手动抛出异常对象"><a href="#手动抛出异常对象" class="headerlink" title="手动抛出异常对象"></a>手动抛出异常对象</h3><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><p>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的 <code>throw</code> 一个异常类的对象。</p><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p><code>throw</code> 和 <code>throws</code>区别： <code>throw</code> 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内。 <code>throws</code> 属于异常处理的一种方式，声明在方法的声明处。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.id = id;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//手动抛出异常对象</span></span><br><span class="line">            <span class="comment">//throw new RuntimeException(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">            <span class="comment">//throw new Exception(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;不能输入负数&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><h4 id="如何自定义异常类"><a href="#如何自定义异常类" class="headerlink" title="如何自定义异常类"></a>如何自定义异常类</h4><ul><li>继承于现的异常结构：<code>RuntimeException 、Exception</code></li><li>提供全局常量：<code>serialVersionUID</code>（对类的唯一标识）</li><li>提供重载的构造器</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7034897193246939L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h2><h3 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h3><h4 id="为什么引入封装性"><a href="#为什么引入封装性" class="headerlink" title="为什么引入封装性"></a>为什么引入封装性</h4><p>我们程序设计追求“高内聚，低耦合”</p><ul><li>高内聚：类的内部数据操作细节自己完成，不允许外部干涉</li><li>低耦合：仅对外暴露少量的方法用于使用。</li></ul><p>隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露岀来。这就是封装性的设计思想。</p><h4 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><p>当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到属性的数据类型和存储范围的制约。除此之外，没其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setName()同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private)。此时，针对于属性就体现了封装性。</p><h4 id="封装性思想具体的代码体现"><a href="#封装性思想具体的代码体现" class="headerlink" title="封装性思想具体的代码体现"></a>封装性思想具体的代码体现</h4><p>体现一：</p><p>将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>体现二：不对外暴露的私有的方法</p><p>体现三：单例模式（将构造器私有化）</p><p>体现四：如果不希望类在包外被调用，可以将类设置为缺省的。</p><h4 id="Java规定的四种权限修饰符"><a href="#Java规定的四种权限修饰符" class="headerlink" title="Java规定的四种权限修饰符"></a>Java规定的四种权限修饰符</h4><p>通过对不同的方法属性设置不同的权限修饰符来达到对类进行封装的目的。</p><ul><li>权限从小到大顺序为：private &lt; 缺省 &lt; protected &lt; public</li><li>具体的修饰范围：</li></ul><table><thead><tr><th><strong>修饰符</strong></th><th><strong>类内部</strong></th><th><strong>同一个包</strong></th><th><strong>不同包的子类</strong></th><th><strong>同一个工程</strong></th></tr></thead><tbody><tr><td>private</td><td>Yes</td><td></td><td></td><td></td></tr><tr><td>（缺省）</td><td>Yes</td><td>Yes</td><td></td><td></td></tr><tr><td>protected</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td>public</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></tbody></table><p><img src="/../image/JavaPic/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6.awebp"></p><p><strong>权限修饰符可用来修饰的结构说明</strong>：</p><ul><li>4种权限都可以用来修饰<strong>类的内部结构</strong>：属性、方法、构造器、内部类</li><li><strong>修饰类</strong>，只能使用：缺省、public</li></ul><h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><h4 id="引入继承性的好处"><a href="#引入继承性的好处" class="headerlink" title="引入继承性的好处"></a>引入继承性的好处</h4><ul><li>减少了代码的冗余，提高了代码的复用性</li><li>便于功能的扩展</li><li>为之后多态性的使用，提供了前提</li></ul><p><img src="/../image/JavaPic/%E7%BB%A7%E6%89%BF%E6%80%A7.awebp"></p><h4 id="继承性的格式"><a href="#继承性的格式" class="headerlink" title="继承性的格式"></a>继承性的格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125;</span><br><span class="line"> *    A:子类、派生类、subclass</span><br><span class="line"> *    B:父类、超类、基类、superclass</span><br></pre></td></tr></table></figure><p>判断是否要进行继承：A is a B,若成立，则B继承A</p><h4 id="子类继承父类以后有哪些不同"><a href="#子类继承父类以后有哪些不同" class="headerlink" title="子类继承父类以后有哪些不同"></a>子类继承父类以后有哪些不同</h4><p>子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已。</p><p>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。</p><h4 id="Java中继承性的说明"><a href="#Java中继承性的说明" class="headerlink" title="Java中继承性的说明"></a>Java中继承性的说明</h4><ol><li>一个类可以被多个子类继承。</li><li>Java中类的单继承性：一个类只能有一个父类</li><li>子父类是相对的概念。</li><li>子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类</li><li>子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法</li></ol><p><img src="/../image/JavaPic/Java%E4%B8%AD%E7%BB%A7%E6%89%BF%E6%80%A7%E7%9A%84%E8%AF%B4%E6%98%8E.awebp"></p><h4 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h4><h5 id="java-lang-Object类的理解"><a href="#java-lang-Object类的理解" class="headerlink" title="java.lang.Object类的理解"></a>java.lang.Object类的理解</h5><p>是Java中所有类的父类，类似于二叉树中的根节点，定义了一些通用的方法。</p><ol><li>如果我们没显式的声明一个类的父类的话，则此类继承于java.lang.Object类</li><li>所的java类（除java.lang.Object类之外都直接或间接的继承于java.lang.Object类</li><li>意味着，所的java类具有java.lang.Object类声明的功能。</li><li>java.lang.Object类中定义的一些方法</li></ol><table><thead><tr><th><strong>方法名</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>public Object()</td><td>构造方法</td><td>构造器</td></tr><tr><td>public boolean equals( Object obj)</td><td>普通方法</td><td>对象比较</td></tr><tr><td>public int hashCode()</td><td>普通方法</td><td>获取Hash码</td></tr><tr><td>public String toString()</td><td>普通方法</td><td>对象打印时调用</td></tr></tbody></table><h5 id="java-lang-Object类的说明"><a href="#java-lang-Object类的说明" class="headerlink" title="java.lang.Object类的说明"></a>java.lang.Object类的说明</h5><ol><li><p>Object类是所Java类的根父类</p></li><li><p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</p></li><li><p>Object类中的功能(属性、方法)就具通用性。</p><ul><li><p>属性：无</p></li><li><p>方法：equals() &#x2F; toString() &#x2F; getClass() &#x2F;hashCode() &#x2F; clone() &#x2F; finalize()</p><p>wait() 、 notify()、notifyAll()</p></li></ul></li><li><p>Object类只声明了一个空参的构造器</p></li><li><p>数组也作为 Object类的子类出现，可以调用 Object类中声明的方法</p></li></ol><h5 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h5><ul><li>是一个方法，而非运算符</li><li>只能适用于引用数据类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>使用说明</strong></p></blockquote><p>Object类中定义的equals()和&#x3D;&#x3D;的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p><p>像&#x3D;&#x3D;String、Date、File、包装类&#x3D;&#x3D;等都重写了Object类中的equals()方法。&#x3D;&#x3D;重写&#x3D;&#x3D;以后，比较的不是两个引用的地址是否相同，而是&#x3D;&#x3D;比较两个对象的”实体内容”是否相同&#x3D;&#x3D;。</p><p>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对Object类中的equals()进行重写.</p><p>重写的原则：比较两个对象的实体内容是否相同.</p><blockquote><p><strong>手动重写举例：</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="comment">//重写其equals()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="built_in">this</span>)&#123;<span class="comment">//判断形参和比较对象的引用地址是否相同，相同直接返回true</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(obj <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line"><span class="type">User</span> <span class="variable">u</span> <span class="operator">=</span> (User)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.age == u.age &amp;&amp; <span class="built_in">this</span>.name.equals(u.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>自动生成的</strong>，自动生成快捷键ctrl+alt+S,选择自动生成hashCode和equals方法</p></blockquote><p><img src="/../image/JavaPic/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90equals.awebp"></p><blockquote><p><strong>自动生成的代码：</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span> == obj)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (getClass() != obj.getClass())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">Person</span> <span class="variable">other</span> <span class="operator">=</span> (Person) obj;</span><br><span class="line"><span class="keyword">if</span> (age != other.age)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (other.name != <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!name.equals(other.name))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>回顾 &#x3D;&#x3D; 运算符的使用：</strong></p></blockquote><p>&#x3D;&#x3D; ：运算符</p><ol><li><p>可以使用在基本数据类型变量和引用数据类型变量中</p></li><li><p>如果比较的是基本数据类型变量：</p><p>比较两个变量保存的数据是否相等。（不一定类型要相同）</p></li><li><p>如果比较的是引用数据类型变量：</p><p>比较两个对象的地址值是否相同,即两个引用是否指向同一个对象实体</p></li></ol><blockquote><p><strong>使用说明</strong></p></blockquote><ul><li>&#x3D;&#x3D; 符号使用时，必须保证符号左右两边的变量类型一致。</li><li>基本数据类型用&#x3D;&#x3D;，引用数据类型用equals</li></ul><h5 id="toString-方法"><a href="#toString-方法" class="headerlink" title="toString()方法"></a>toString()方法</h5><blockquote><p><strong>toString()的使用:</strong></p></blockquote><ul><li><p>当我们输出一个对象的引用时，实际上就是调用当前对象的toString()方法</p></li><li><p>Object类中toString()的定义：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息。</p></li><li><p>自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p></li></ul><blockquote><p><strong>重写toString()</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动实现</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Customer [name=&quot;</span> + name + <span class="string">&quot;, age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子类对象实例化全过程"><a href="#子类对象实例化全过程" class="headerlink" title="子类对象实例化全过程"></a>子类对象实例化全过程</h4><h5 id="1-从结果上看：继承性"><a href="#1-从结果上看：继承性" class="headerlink" title="1. 从结果上看：继承性"></a>1. 从结果上看：继承性</h5><p>子类继承父类以后，就获取了父类中声明的属性或方法。 创建子类的对象，在堆空间中，就会加载所父类中声明的属性。</p><h5 id="2-从过程上看："><a href="#2-从过程上看：" class="headerlink" title="2. 从过程上看："></a>2. 从过程上看：</h5><p>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，…直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用。</p><p><img src="/../image/JavaPic/%E5%AD%90%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96.awebp"></p><h5 id="3-强调说明："><a href="#3-强调说明：" class="headerlink" title="3. 强调说明："></a>3. 强调说明：</h5><p>虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p><p><img src="/../image/JavaPic/%E5%AD%90%E7%B1%BB%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%BA%95%E5%B1%82.awebp"></p><h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><h4 id="多态性的理解"><a href="#多态性的理解" class="headerlink" title="多态性的理解"></a>多态性的理解</h4><p>可以理解为一个事物的多种形态。比如数据库的连接方式，我们定义好了数据库的连接，也规定了连接时的步骤，但是我们并不知道用户会采用什么数据库，在没有多态以前我们只能针对不同的数据库写不同的连接方法，而有了多态以后我们只需要定义好数据库的类并书写好连接方法，让所有的数据库继承数据库类并重写数据库连接方法。</p><p>这样我们在调用的时候只需要通过声明数据库类并指向数据库的子类的方式，<strong>（即数据库类的引用指向继承了数据库类的具体实现类的对象）</strong>就可以进行数据库连接。而不是需要针对不同的数据库书写不同的连接方式。</p><h4 id="何为多态性"><a href="#何为多态性" class="headerlink" title="何为多态性"></a>何为多态性</h4><p>对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）</p><p>编译时和运行时类型不一致，产生了多态</p><blockquote><p><strong>代码举例：</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure><h4 id="多态性的使用：虚拟方法调用"><a href="#多态性的使用：虚拟方法调用" class="headerlink" title="多态性的使用：虚拟方法调用"></a>多态性的使用：虚拟方法调用</h4><p>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</p><p>总结：编译，看左边；运行，看右边。</p><p>对象的多态：在Java中，子类的对象可以替代父类的对象使用</p><ul><li>一个变量只能有一种确定的数据类型</li><li>一个引用类型变量可能指向（引用）多种不同类型的对象</li></ul><blockquote><h5 id="多态性的使用前提："><a href="#多态性的使用前提：" class="headerlink" title="多态性的使用前提："></a>多态性的使用前提：</h5></blockquote><p>① 类的继承关系 ② 方法的重写</p><blockquote><h5 id="多态性的应用举例："><a href="#多态性的应用举例：" class="headerlink" title="多态性的应用举例："></a>多态性的应用举例：</h5></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">举例一：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">(Animal animal)</span>&#123;<span class="comment">//Animal animal = new Dog();</span></span><br><span class="line">animal.eat();</span><br><span class="line">animal.shout();</span><br><span class="line">&#125;</span><br><span class="line">举例二：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">举例三：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Driver</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doData</span><span class="params">(Connection conn)</span>&#123;<span class="comment">//conn = new MySQlConnection(); / conn = new OracleConnection();</span></span><br><span class="line"><span class="comment">//规范的步骤去操作数据</span></span><br><span class="line"><span class="comment">//conn.method1();</span></span><br><span class="line"><span class="comment">//conn.method2();</span></span><br><span class="line"><span class="comment">//conn.method3();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="多态性使用的注意点："><a href="#多态性使用的注意点：" class="headerlink" title="多态性使用的注意点："></a>多态性使用的注意点：</h5></blockquote><ul><li>对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</li><li>个引用类型变量如果声明为父类的类型，但实际引用的是子类对象，那么该变量就&#x3D;&#x3D;不能&#x3D;&#x3D;再访问子类中添加的属性和方法</li></ul><blockquote><h5 id="多态使用总结"><a href="#多态使用总结" class="headerlink" title="多态使用总结"></a>多态使用总结</h5></blockquote><p>多态的作用：提高了代码的通用性，常称作接口重用</p><p>使用前提：①需要存在继承或者实现关系 ②有方法的重写</p><p>成员方法：</p><ul><li>编译时：要查看引用变量所声明的类中是否有所调用的方法</li><li>运行时：调用实际new的对象所属的类中的重写方法</li></ul><p>成员变量：不具备多态性，只看引用变量所声明的类</p><h4 id="关于向上转型与向下转型"><a href="#关于向上转型与向下转型" class="headerlink" title="关于向上转型与向下转型"></a>关于向上转型与向下转型</h4><p>向上转型：多态</p><blockquote><h5 id="为什么使用向下转型："><a href="#为什么使用向下转型：" class="headerlink" title="为什么使用向下转型："></a>为什么使用向下转型：</h5></blockquote><p>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型。</p><blockquote><h5 id="如何实现向下转型："><a href="#如何实现向下转型：" class="headerlink" title="如何实现向下转型："></a>如何实现向下转型：</h5></blockquote><p>使用强制类型转换符：()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Man</span>();</span><br><span class="line"></span><br><span class="line">Man m1=（Man）p2；<span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure><blockquote><h5 id="使用时的注意点："><a href="#使用时的注意点：" class="headerlink" title="使用时的注意点："></a>使用时的注意点：</h5></blockquote><p>① 使用强转时，可能出现ClassCastException的异常。</p><p>② 为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</p><p>③ 只有对象A是B的子类实例化对象或者在下层的子类，才能向下转型</p><blockquote><h5 id="instanceof的使用："><a href="#instanceof的使用：" class="headerlink" title="instanceof的使用："></a>instanceof的使用：</h5></blockquote><p>① a instanceof A:&#x3D;&#x3D;判断对象a&#x3D;&#x3D;是否是&#x3D;&#x3D;类A的实例&#x3D;&#x3D;。如果是，返回true；如果不是，返回false。</p><p>② 如果 a instanceof A返回true,则 a instanceof B也返回true.其中，类B是类A的父类。</p><p>③ 要求a所属的类与类A必须是子类和父类的关系，否则编译错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p instanceif Man<span class="comment">//左边是变量名，右边是类的类型</span></span><br></pre></td></tr></table></figure><p><img src="/../image/JavaPic/%E5%A4%9A%E6%80%81%E6%80%A7-%E8%BD%AC%E5%9E%8B.awebp"></p><h4 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h4><blockquote><p><strong>谈谈你对多态性的理解？</strong></p></blockquote><p>实现代码的通用性。</p><p>举例：</p><ul><li>Object类中定义的public boolean equals(Object obj){ }</li><li>JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server）</li><li>抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）</li></ul><blockquote><p>多态是编译时行为还是运行时行为？运行时行为？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="built_in">this</span>.count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sub</span> <span class="keyword">extends</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="built_in">this</span>.count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldMethodTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Sub</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sub</span>();</span><br><span class="line">System.out.println(s.count);<span class="comment">//20</span></span><br><span class="line">s.display();<span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="type">Base</span> <span class="variable">b</span> <span class="operator">=</span> s;<span class="comment">//多态性</span></span><br><span class="line"><span class="comment">//==：对于引用数据类型来讲，比较的是两个引用数据类型变量的地址值是否相同</span></span><br><span class="line">System.out.println(b == s);<span class="comment">//true</span></span><br><span class="line">System.out.println(b.count);<span class="comment">//10</span></span><br><span class="line">b.display();<span class="comment">//20</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java中的类"><a href="#Java中的类" class="headerlink" title="Java中的类"></a>Java中的类</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><h4 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h4><ul><li>面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</li><li>面向对象：强调具备了功能的对象，以类&#x2F;对象为最小单位，考虑谁来做。–唯物主义（物质决定意识）</li></ul><h4 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h4><p>类：对一类事物的描述，是抽象的、概念上的定义</p><p>对象：是实际存在的该类事物的每个个体，因而也称为实例(instance)</p><blockquote><p>面向对象程序设计的重点是类的设计，设计类就是设计类的成员。</p><p>二者的关系：对象，是由类new出来的，派生出来的。</p></blockquote><h4 id="面向对象思想实现的规则"><a href="#面向对象思想实现的规则" class="headerlink" title="面向对象思想实现的规则"></a>面向对象思想实现的规则</h4><ol><li>创建类，设计类的成员</li><li>创建类的对象</li><li>通过<code>对象.属性</code> 或 <code>对象.方法</code>调用对象的结构</li></ol><p>补充：几个概念的使用说明</p><ul><li>属性 &#x3D; 成员变量 &#x3D; field &#x3D; 域、字段</li><li>方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D; method</li><li>创建类的对象 &#x3D; 类的实例化 &#x3D; 实例化类</li></ul><h4 id="对象的创建与对象的内存解析"><a href="#对象的创建与对象的内存解析" class="headerlink" title="对象的创建与对象的内存解析"></a>对象的创建与对象的内存解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p3</span> <span class="operator">=</span> p1;<span class="comment">//没有新创建一个对象，共用一个堆空间中的对象实体。</span></span><br><span class="line"><span class="comment">/*说明：</span></span><br><span class="line"><span class="comment">*如果创建了一个类的多个对象，则每个对象都独立的拥有一套类的属性。（非static的）</span></span><br><span class="line"><span class="comment">*意味着：如果我们修改一个对象的属性a，则不影响另外一个对象属性a的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/../image/JavaPic/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90-1.awebp"></p><p><img src="/../image/JavaPic/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90-2.awebp"></p><h4 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h4><p>编译完源程序以后，生成一个或多个字节码文件。我们使用JVM中的类的加载器和解释器对生成的字节码文件进行解释运行。意味着，需要将字节码文件对应的类加载到内存中，涉及到内存解析。</p><p><img src="/../image/JavaPic/JVM.awebp"></p><p>虚拟机栈：即为平时提到的栈结构。<em><strong>我们将局部变量存储在栈结构中</strong></em></p><p>虚拟机堆：我们将new出来的结构（比如：数组、对象）加载在对空间中。</p><p>补充：对象的属性（非static的）加载在堆空间中。</p><p>方法区：类的加载信息、常量池、静态域</p><h4 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h4><p>我们创建的对象，没显式的赋给一个变量名。即为匿名对象</p><p>特点：匿名对象只能调用一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().sendEmail();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().playGame();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().price = <span class="number">1999</span>;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Phone</span>().showPrice();<span class="comment">//0.0</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PhoneMall</span> <span class="variable">mall</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhoneMall</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象的使用</span></span><br><span class="line">mall.show(<span class="keyword">new</span> <span class="title class_">Phone</span>());</span><br><span class="line">其中，</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneMall</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Phone phone)</span>&#123;</span><br><span class="line">        phone.sendEmail();</span><br><span class="line">        phone.playGame();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="万物皆可对象"><a href="#万物皆可对象" class="headerlink" title="万物皆可对象"></a>万物皆可对象</h4><p>在Java语言范畴中，我们都将功能、结构等封装到类中，通过类的实例化，来调用具体的功能结构</p><ul><li>Scanner,String等</li><li>文件：File</li><li>网络资源：URL</li></ul><p>涉及到Java语言与前端HTML、后端的数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。</p><h3 id="类的结构之一：属性"><a href="#类的结构之一：属性" class="headerlink" title="类的结构之一：属性"></a>类的结构之一：属性</h3><h4 id="属性-vs-局部变量"><a href="#属性-vs-局部变量" class="headerlink" title="属性 vs 局部变量"></a>属性 vs 局部变量</h4><h6 id="相同点："><a href="#相同点：" class="headerlink" title="相同点："></a>相同点：</h6><ul><li>定义变量的格式：数据类型 变量名 &#x3D; 变量值</li><li>先声明，后使用</li><li>变量都其对应的作用域</li></ul><h6 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h6><ul><li><p>在类中声明的位置的不同</p><ul><li><p>属性：直接定义在类的一对{}内</p></li><li><p>局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量。</p></li></ul></li><li><p>关于权限修饰符的不同</p><ul><li><p>属性：可以在声明属性时，指明其权限，使用权限修饰符。</p></li><li><p>常用的权限修饰符：private、public、缺省、protected —&gt;封装性</p></li><li><p>目前，声明属性时，使用缺省就可以。</p></li><li><p>局部变量：不可以使用权限修饰符。</p></li></ul></li><li><p>默认初始化值的情况：</p><ul><li><p>属性：类的属性，根据其类型，都默认初始化值。</p></li><li><p>整型（byte、short、int、long：0）</p></li><li><p>浮点型（float、double：0.0）</p></li><li><p>字符型（char：0 （或’\u0000’））</p></li><li><p>布尔型（boolean：false）</p></li><li><p>引用数据类型（类、数组、接口：null）</p></li><li><p>局部变量：没默认初始化值。</p><ul><li>意味着，我们在调用局部变量之前，一定要显式赋值。</li><li>特别地：形参在调用时，我们赋值即可。</li></ul></li></ul></li><li><p>在内存中加载的位置：</p><ul><li><p>属性：加载到堆空间中 （非static）</p></li><li><p>局部变量：加载到栈空间</p></li></ul></li></ul><h4 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h4><ul><li><p>方式一：按照数据类型：</p><p><img src="/../image/JavaPic/%E6%8C%89%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F.awebp"></p></li><li><p>方式二：按照在类中声明的位置：</p><p><img src="/../image/JavaPic/%E6%8C%89%E7%B1%BB%E4%B8%AD%E5%A3%B0%E6%98%8E%E4%BD%8D%E7%BD%AE%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F.awebp"></p></li></ul><h3 id="类的结构之二：方法"><a href="#类的结构之二：方法" class="headerlink" title="类的结构之二：方法"></a>类的结构之二：方法</h3><p>定义：描述类应该具的功能。</p><h4 id="方法举例"><a href="#方法举例" class="headerlink" title="方法举例"></a>方法举例</h4><blockquote><p><strong>JDK中的方法：</strong></p></blockquote><ul><li>Math类：<code>sqrt()</code> <code>random()</code> …</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scanner类：`nextXxx()` ...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays类：`sort()`    `binarySearch()`    `toString()`     `equals()`   ...</span><br></pre></td></tr></table></figure><blockquote><p><strong>自定义的方法：</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.printly(<span class="string">&quot;我要吃饭！！！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getNation</span><span class="params">(String nation)</span>&#123;</span><br><span class="line">    System.out.printly(<span class="string">&quot;当前地点为&quot;</span> + nation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>方法的声明：</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 返回值类型  方法名(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">方法体</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：static、final、abstract 来修饰的方法，后面再聊。</p><h4 id="方法的说明"><a href="#方法的说明" class="headerlink" title="方法的说明"></a>方法的说明</h4><blockquote><h5 id="关于权限修饰符："><a href="#关于权限修饰符：" class="headerlink" title="关于权限修饰符："></a>关于权限修饰符：</h5></blockquote><p>Java规定的4种权限修饰符：private、public、缺省、protected</p><blockquote><h5 id="返回值类型："><a href="#返回值类型：" class="headerlink" title="返回值类型："></a>返回值类型：</h5></blockquote><ul><li><p><strong>如果方法有返回值</strong>，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用return关键字来返回指定类型的变量或常量：<code>return 数据</code>。</p></li><li><p><strong>如果方法没返回值</strong>，则方法声明时，使用void来表示。通常，没返回值的方法中，就不需要使用return。如果使用的话，只能使用 <code>return;</code> 表示结束此方法的意思。</p></li></ul><blockquote><h5 id="方法命名规范"><a href="#方法命名规范" class="headerlink" title="方法命名规范"></a>方法命名规范</h5></blockquote><ul><li>属于标识符，遵循标识符的规则和规范，“见名知意”</li><li>方法名应遵循小驼峰命名 <code>aaaBbbCcc</code></li><li>方法名最好使用英文单词，不要使用拼音或者缩写</li><li>更多规范要求请参考《Java开发手册》</li></ul><blockquote><h5 id="关于形参列表"><a href="#关于形参列表" class="headerlink" title="关于形参列表"></a>关于形参列表</h5></blockquote><p>方法可以声明0个，1个，或多个形参。</p><p>也可以使用可变形参，但可变形参必须放到最后，详细说明请查看本章第五部分。</p><p>格式：<code>数据类型1 形参1</code> <code>数据类型2 形参2</code> …..</p><blockquote><h5 id="方法体"><a href="#方法体" class="headerlink" title="方法体"></a>方法体</h5></blockquote><p>是方法中功能的体现，通过循环分支、条件判断等语句完成复杂的逻辑关系。</p><p>方法中可以调用其他方法，同类中可以直接调用，不同类中通过类的实例化对象调用。</p><p>注意：方法中不可以定义新的方法</p><h4 id="方法的使用"><a href="#方法的使用" class="headerlink" title="方法的使用"></a>方法的使用</h4><ul><li>同类中的方法可以直接调用当前类的属性或方法，不同类中通过类的实例化对象调用。</li><li>特殊的：方法A中又调用了自身—递归方法。（自身调用）</li></ul><h4 id="方法的重载"><a href="#方法的重载" class="headerlink" title="方法的重载"></a>方法的重载</h4><blockquote><h5 id="重载的概念"><a href="#重载的概念" class="headerlink" title="重载的概念"></a>重载的概念</h5></blockquote><p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p><p><strong>“两同一不同”:</strong></p><ul><li>相同：同一个类、相同方法名</li><li>参数列表不同：参数个数不同，参数类型不同</li></ul><blockquote><h5 id="构成重载的实例："><a href="#构成重载的实例：" class="headerlink" title="构成重载的实例："></a>构成重载的实例：</h5></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 举例一：Arrays类中重载的sort() / binarySearch()；PrintStream中的println()</span></span><br><span class="line"><span class="comment">// 举例二：</span></span><br><span class="line"><span class="comment">// 如下的4个方法构成了重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">double</span> d1,<span class="type">double</span> d2)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(String s ,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> i,String s)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>不构成重载的实例：</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如下的3个方法不能与上述4个方法构成重载</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="重载方法判断"><a href="#重载方法判断" class="headerlink" title="重载方法判断"></a>重载方法判断</h5></blockquote><ul><li><strong>如何判断是否构成方法重载？</strong></li></ul><p>​严格按照定义判断：两同一不同。跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系！</p><ul><li><strong>如何确定类中某一个方法的调用：</strong></li></ul><p>​①方法名 —&gt; ②参数列表</p><h4 id="可变个数形参方法"><a href="#可变个数形参方法" class="headerlink" title="可变个数形参方法"></a>可变个数形参方法</h4><blockquote><h5 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a>使用说明</h5></blockquote><p>JDK 5.0新增的内容</p><p>JDK 5.0以前：采用数组形参来定义方法，传入多个同一类型变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a， String[] books)</span>;</span><br></pre></td></tr></table></figure><p>JDK 5.0以后：采用可变个数形参来定义方法，传入多个同一类型变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a， String ... books)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>可变个数形参的格式：<code>数据类型 ... 变量名</code></p></li><li><p>当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，…..</p></li><li><p>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</p></li><li><p>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</p></li><li><p>可变个数形参在方法的形参中，<em><strong>必须声明在末尾。</strong></em></p></li><li><p>可变个数形参在方法的形参中***,最多只能声明一个可变形参***。</p></li></ul><blockquote><h5 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h5></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show(String)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String ... strs)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;show(String ... strs)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">        System.out.println(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//  public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//      </span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"><span class="comment">// 调用时：可变形参与数组类似</span></span><br><span class="line">test.show(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">test.show(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">test.show();</span><br><span class="line"></span><br><span class="line">test.show(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>,<span class="string">&quot;BB&quot;</span>,<span class="string">&quot;CC&quot;</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="Java的值传递机制"><a href="#Java的值传递机制" class="headerlink" title="Java的值传递机制"></a>Java的值传递机制</h4><blockquote><h5 id="针对方法内变量的赋值举例："><a href="#针对方法内变量的赋值举例：" class="headerlink" title="针对方法内变量的赋值举例："></a>针对方法内变量的赋值举例：</h5></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;***********基本数据类型：****************&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> m;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">n = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;m = &quot;</span> + m + <span class="string">&quot;, n = &quot;</span> + n);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;***********引用数据类型：****************&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Order</span> <span class="variable">o1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">o1.orderId = <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Order</span> <span class="variable">o2</span> <span class="operator">=</span> o1;<span class="comment">//赋值以后，o1和o2的地址值相同，都指向了堆空间中同一个对象实体。</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;o1.orderId = &quot;</span> + o1.orderId + <span class="string">&quot;,o2.orderId = &quot;</span> +o2.orderId);</span><br><span class="line"></span><br><span class="line">o2.orderId = <span class="number">1002</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;o1.orderId = &quot;</span> + o1.orderId + <span class="string">&quot;,o2.orderId = &quot;</span> +o2.orderId);</span><br></pre></td></tr></table></figure><p>规则： 如果变量是基本数据类型，此时赋值的是变量所保存的数据值。 如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</p><blockquote><h5 id="针对于方法的参数概念"><a href="#针对于方法的参数概念" class="headerlink" title="针对于方法的参数概念"></a>针对于方法的参数概念</h5></blockquote><p>形参：<em><strong>方法定义时</strong></em>，声明的小括号内的参数 实参：<em><strong>方法调用时</strong></em>，实际传递给形参的数据</p><blockquote><p>Java中参数传递机制：值传递机制</p></blockquote><ul><li><p><strong>规则：</strong></p><ul><li><p>如果参数是<em><strong>基本数据类型</strong></em>，此时实参赋给形参的是实参真实存储的数据值。</p></li><li><p>如果参数是<em><strong>引用数据类型</strong></em>，此时实参赋给形参的是实参存储数据的地址值。</p></li></ul></li><li><p><strong>推广：</strong></p><ul><li><p>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。</p></li><li><p>如果变量是引用数据类型，此时赋值的是变量所保存的数据</p></li></ul></li></ul><blockquote><h5 id="内存解析："><a href="#内存解析：" class="headerlink" title="内存解析："></a>内存解析：</h5></blockquote><p>内存解析画法要点：</p><p>1.内存结构：栈（局部变量）、堆（new出来的结构：对象（非static成员变量）、数组 </p><p>2.变量：成员变量 vs 局部变量（方法内、方法形参、构造器内、构造器形参、代码块内）</p><p><img src="/../image/JavaPic/%E7%B1%BB%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90-1.awebp"></p><p><img src="/../image/JavaPic/%E7%B1%BB%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90-2.awebp"></p><h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><p>递归方法：一个方法体内调用它自身。</p><p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。 递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1：计算1-n之间所自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2：计算1-n之间所自然数的乘积:n!</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * getSum1(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例3：已知一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),</span></span><br><span class="line"><span class="comment">//其中n是大于0的整数，求f(10)的值。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//          return f(n + 2) - 2 * f(n + 1);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例4：斐波那契数列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例5：汉诺塔问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例6：快排</span></span><br></pre></td></tr></table></figure><h4 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h4><blockquote><h5 id="什么是方法的重写-override-或-overwrite-？"><a href="#什么是方法的重写-override-或-overwrite-？" class="headerlink" title="什么是方法的重写(override 或 overwrite)？"></a>什么是方法的重写(override 或 overwrite)？</h5></blockquote><p>子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.</p><blockquote><h5 id="重写的应用："><a href="#重写的应用：" class="headerlink" title="重写的应用："></a>重写的应用：</h5></blockquote><p>重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。</p><blockquote><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;&#125;<span class="comment">//求面积</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cylinder</span> <span class="keyword">extends</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;&#125;<span class="comment">//求表面积</span></span><br><span class="line">&#125;</span><br><span class="line">**********************************************</span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amt)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CheckAccount</span> <span class="keyword">extends</span> <span class="title class_">Account</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> amt)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="重写的规则："><a href="#重写的规则：" class="headerlink" title="重写的规则："></a>重写的规则：</h5></blockquote><p><strong>声明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p><ol><li>子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</li><li>子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</li></ol><p>特殊情况：子类不能重写父类中声明为private权限的方法</p><ul><li><p>返回值类型：</p><ul><li><p>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</p></li><li><p>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</p></li><li><p>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</p></li></ul></li><li><p>子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p></li></ul><p>子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写，要么都声明为static的（不是重写)。</p><p>开发中一般保持子父类一致</p><blockquote><h5 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h5></blockquote><p><strong>区分方法的重写和重载？</strong></p><ul><li><p>二者的概念：</p><ul><li><p>方法的重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.</p></li><li><p>方法的重载：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</p></li></ul></li><li><p>重载和重写的具体规则：重载：两同一不同，重写</p></li><li><p>重载：不表现为多态性。 重写：表现为多态性。</p></li><li><p>从编译和运行的角度看：</p><ul><li><p>重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。</p></li><li><p>所以对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；</p></li><li><p>而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。</p></li></ul></li></ul><h3 id="类的结构之三：构造器"><a href="#类的结构之三：构造器" class="headerlink" title="类的结构之三：构造器"></a>类的结构之三：构造器</h3><h4 id="构造器（或构造方法）：Constructor"><a href="#构造器（或构造方法）：Constructor" class="headerlink" title="构造器（或构造方法）：Constructor"></a>构造器（或构造方法）：Constructor</h4><p>构造器的作用：（只要造对象就得用构造器）</p><ol><li>创建对象</li><li>初始化对象的信息</li></ol><h4 id="使用说明-2"><a href="#使用说明-2" class="headerlink" title="使用说明"></a>使用说明</h4><ul><li><p>如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器</p></li><li><p>定义构造器的格式：<code>权限修饰符 类名(形参列表)&#123; &#125;</code></p></li><li><p>一个类中定义的<em><strong>多个构造器</strong></em>，彼此构成重载</p></li><li><p>一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</p></li><li><p>一个类中，<em><strong>至少会有一个构造器</strong></em>。</p></li></ul><h4 id="构造器举例"><a href="#构造器举例" class="headerlink" title="构造器举例"></a>构造器举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器不等于方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Person().....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n)</span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String n,<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    name = n;</span><br><span class="line">    age = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造器默认权限和类的权限一致</p><h4 id="属性赋值顺序"><a href="#属性赋值顺序" class="headerlink" title="属性赋值顺序"></a>属性赋值顺序</h4><p>总结：属性赋值的先后顺序</p><p>① 默认初始化</p><p>② 显式初始化</p><p>③ 构造器中初始化</p><p>④ 通过”对象.方法” 或 “对象.属性”的方式，赋值</p><p>以上操作的先后顺序：① - ② - ③ - ④</p><h4 id="JavaBean的概念"><a href="#JavaBean的概念" class="headerlink" title="JavaBean的概念"></a>JavaBean的概念</h4><p>所谓JavaBean，是指符合如下标准的Java类：</p><ul><li>类是公共的</li><li>一个<em><strong>无参</strong></em>的公共的构造器</li><li>属性，且对应的get、set方法</li></ul><h3 id="类的结构之四：代码块"><a href="#类的结构之四：代码块" class="headerlink" title="类的结构之四：代码块"></a>类的结构之四：代码块</h3><p>代码块(初始化块)（重要性较属性、方法、构造器差一些）</p><h4 id="代码块的作用"><a href="#代码块的作用" class="headerlink" title="代码块的作用"></a>代码块的作用</h4><p>用来初始化类、对象的信息</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>代码块要是使用修饰符，只能使用static 分类：静态代码块 vs 非静态代码块</p><h4 id="静态代码块-vs-非静态代码块"><a href="#静态代码块-vs-非静态代码块" class="headerlink" title="静态代码块 vs 非静态代码块"></a>静态代码块 vs 非静态代码块</h4><blockquote><p><strong>静态代码块：</strong></p></blockquote><ul><li>内部可以输出语句</li><li>随着类的加载而执行,而且只执行一次</li><li>作用：初始化类的信息</li><li>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</li><li>静态代码块的执行要优先于非静态代码块的执行</li><li>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</li></ul><blockquote><p><strong>非静态代码块：</strong></p></blockquote><ul><li><p>内部可以输出语句</p></li><li><p>随着对象的创建而执行</p></li><li><p>每创建一个对象，就执行一次非静态代码块</p></li><li><p>作用：可以在创建对象时，对对象的属性等进行初始化</p></li><li><p>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</p></li><li><p>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</p></li></ul><p>注意：实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：由父及子，静态先行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Root</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mid</span> <span class="keyword">extends</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="comment">//通过this调用同一类中重载的构造器</span></span><br><span class="line">        <span class="built_in">this</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span></span><br><span class="line">                           + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Mid</span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//通过super调用父类中有一个字符串参数的构造器</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;调用父类构造器&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeafTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Leaf</span>(); </span><br><span class="line">        <span class="comment">//new Leaf();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;11111111111&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;22222222222&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;33333333333&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;44444444444&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;55555555555&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;66666666666&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">// 由父及子 静态先行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;77777777777&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;************************&quot;</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Father</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="属性赋值的顺序"><a href="#属性赋值的顺序" class="headerlink" title="属性赋值的顺序"></a>属性赋值的顺序</h4><p>① 默认初始化</p><p>② 显式初始化&#x2F;⑤在代码块中赋值</p><p>③ 构造器中初始化</p><p>④ 有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</p><p>执行的先后顺序：① - ② &#x2F; ⑤ - ③ - ④</p><h3 id="类的结构之五"><a href="#类的结构之五" class="headerlink" title="类的结构之五"></a>类的结构之五</h3><p>内部类：类的第五个成员</p><h4 id="内部类的定义"><a href="#内部类的定义" class="headerlink" title="内部类的定义"></a>内部类的定义</h4><p>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类。</p><h4 id="内部类的分类"><a href="#内部类的分类" class="headerlink" title="内部类的分类"></a>内部类的分类</h4><p>成员内部类（静态、非静态 ） 局部内部类(方法内、代码块内、构造器内)</p><h4 id="成员内部类的理解"><a href="#成员内部类的理解" class="headerlink" title="成员内部类的理解"></a>成员内部类的理解</h4><p>一方面，作为外部类的成员：</p><ul><li>调用外部类的结构</li><li>可以被static修饰</li><li>可以被4种不同的权限修饰</li></ul><p>另一方面，作为一个类：</p><ul><li>类内可以定义属性、方法、构造器等</li><li>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</li><li>可以被abstract修饰</li></ul><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><blockquote><p><strong>如何创建成员内部类的对象？(静态的，非静态的)</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建静态的Dog内部类的实例(静态的成员内部类):</span></span><br><span class="line">Person.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建非静态的Bird内部类的实例(非静态的成员内部类):</span></span><br><span class="line"><span class="comment">// Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> p.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br></pre></td></tr></table></figure><blockquote><p><strong>如何在成员内部类中调用外部类的结构？</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态成员内部类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">            System.out.println(<span class="built_in">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">            System.out.println(Person.<span class="built_in">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line">            <span class="comment">//Person.this.eat();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="局部内部类的使用"><a href="#局部内部类的使用" class="headerlink" title="局部内部类的使用"></a>局部内部类的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个实现了Comparable接口的类的对象</span></span><br><span class="line"><span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">    <span class="comment">//方式一：</span></span><br><span class="line">    <span class="comment">//      class MyComparable implements Comparable&#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//          @Override</span></span><br><span class="line">    <span class="comment">//          public int compareTo(Object o) &#123;</span></span><br><span class="line">    <span class="comment">//              return 0;</span></span><br><span class="line">    <span class="comment">//          &#125;</span></span><br><span class="line">    <span class="comment">//          </span></span><br><span class="line">    <span class="comment">//      &#125;</span></span><br><span class="line">    <span class="comment">//      </span></span><br><span class="line">    <span class="comment">//      return new MyComparable();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Comparable</span>()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><p>在局部内部类的方法中（比如：show如果<strong>调用局部内部类所声明的方法</strong>(比如：method)中的<strong>局部变量</strong>(比如：num)的话,要求此局部变量声明为final的。</p><p>原因：局部内部类也会生成字节码文件，在调用所属类的局部变量时，因为是两个类，所以不能修改所属类的属性，因此所属类将属性设置为final的为内部类调用提供一个副本，而内部类不能进行修改。</p><ul><li>jdk 7及之前版本：要求此局部变量显式的声明为final的</li><li>jdk 8及之后的版本：可以省略final的声明</li></ul><p>总结：成员内部类和局部内部类，在编译以后，都会生成字节码文件。 格式：成员内部类：<code>外部类$内部类名.class</code> 局部内部类：<code>外部类$数字 内部类名.class</code></p><h2 id="Java中的关键字"><a href="#Java中的关键字" class="headerlink" title="Java中的关键字"></a>Java中的关键字</h2><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>使用在方法体中，用于：① 结束方法② 针对于返回值类型的方法，使用”return 数据”方法返回所要的数据。</p><p>return关键字后面不可以声明执行语句。</p><p>在异常处理中try-catch-finally的结构中，如果try或catch中的结构中写了return，但是finally中的结构仍会执行。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>this理解为：当前对象 或 当前正在创建的对象，可以调用的结构：<em><strong>属性、方法；构造器</strong></em></p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><blockquote><h5 id="this调用属性、方法："><a href="#this调用属性、方法：" class="headerlink" title="this调用属性、方法："></a>this调用属性、方法：</h5></blockquote><p>在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果<em><strong>方法的形参和类的属性同名时</strong></em>，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</p><p>在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略”this.”。特殊情况下，如果<em><strong>构造器的形参和类的属性同名</strong></em>时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。</p><blockquote><h5 id="this调用构造器："><a href="#this调用构造器：" class="headerlink" title="this调用构造器："></a>this调用构造器：</h5></blockquote><p>① 我们在类的构造器中，可以显式的使用***”this(形参列表)”***方式，调用本类中指定的其他构造器</p><p>② 构造器中不能通过”this(形参列表)”方式调用自己</p><p>③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了”this(形参列表)”</p><p>④ 规定：”this(形参列表)”<em><strong>必须声明在当前构造器的首行</strong></em></p><p>⑤ **构造器内部，最多只能声明一个”this(形参列表)”**，用来调用其他的构造器</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>super 关键字可以理解为：父类的，可以用来调用的结构：<em><strong>属性、方法、构造器</strong></em></p><ul><li>尤其当子父类出现同名成员时，可以用supe表明调用的是父类中的成员</li><li>super的追溯不仅限于直接父类</li><li>super和this的用法相像，this代表本类对象的引用， super代表父类的内存空间的标识</li></ul><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><blockquote><h5 id="super调用属性、方法："><a href="#super调用属性、方法：" class="headerlink" title="super调用属性、方法："></a>super调用属性、方法：</h5></blockquote><p>与this关键字使用方式相同，只不过调用的是父类的属性</p><blockquote><h5 id="在子类的方法或构造器中使用"><a href="#在子类的方法或构造器中使用" class="headerlink" title="在子类的方法或构造器中使用"></a>在子类的方法或构造器中使用</h5></blockquote><p>通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</p><p><strong>特殊情况</strong></p><ul><li>当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性。</li><li>当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法。</li></ul><blockquote><h5 id="super调用构造器："><a href="#super调用构造器：" class="headerlink" title="super调用构造器："></a>super调用构造器：</h5></blockquote><ul><li><p>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</p></li><li><p>“super(形参列表)”的使用，必须声明在子类构造器的首行！</p></li><li><p>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现</p></li><li><p>在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</p></li><li><p>在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</p></li></ul><h4 id="this与super的区别"><a href="#this与super的区别" class="headerlink" title="this与super的区别"></a>this与super的区别</h4><table><thead><tr><th><strong>区别点</strong></th><th><strong>this</strong></th><th><strong>super</strong></th></tr></thead><tbody><tr><td>访问属性</td><td>访问本类中的属性，如果本类没有此属性则从父类中继续查找</td><td>直接访问父类中的属性</td></tr><tr><td>调用方法</td><td>访问本类中的方法，如果本类没有此方法则从父类中继续查找</td><td>直接访问父类中的方法</td></tr><tr><td>调用构造器</td><td>调用本类构造器，必须放在构造器的首行</td><td>调用父类构造器，必须放在子类构造器的首行</td></tr></tbody></table><h3 id="package-import"><a href="#package-import" class="headerlink" title="package&#x2F;import"></a>package&#x2F;import</h3><h4 id="package-概述"><a href="#package-概述" class="headerlink" title="package 概述"></a>package 概述</h4><ol><li>为了更好的实现项目中类的管理，提供包的概念</li><li>使用package声明类或接口所属的包，声明在源文件的首行</li><li>包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”</li><li>每”.”一次，就代表一层文件目录。</li></ol><h4 id="包结构应用举例"><a href="#包结构应用举例" class="headerlink" title="包结构应用举例"></a>包结构应用举例</h4><blockquote><p><strong>MVC设计模式</strong></p></blockquote><p><img src="/../image/JavaPic/MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.awebp"></p><h4 id="JDK中的主要包"><a href="#JDK中的主要包" class="headerlink" title="JDK中的主要包"></a>JDK中的主要包</h4><ul><li><p>java. lang–包含一些Java语言的核心类，如 String、Math、 integer、 System和Thread，提供常用功能</p></li><li><p>java. net–包含执行与网络相关的操作的类和接口</p></li><li><p>java.io–包含能提供多种输入&#x2F;输出功能的类</p></li><li><p>java util–包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。</p></li><li><p>java. text–包含了一些java格式化相关的类</p></li><li><p>java.sql–包含了java进行JDBC数据库编程的相关类&#x2F;接口</p></li><li><p>java. awt–包含了构成抽象窗口工具集 (abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面GU）。 B&#x2F;S C&#x2F;S</p></li></ul><h4 id="import-的使用"><a href="#import-的使用" class="headerlink" title="import 的使用"></a>import 的使用</h4><ul><li><p>在源文件中显式的使用import结构导入指定包下的类、接口</p></li><li><p>声明在包的声明和类的声明之间</p></li><li><p>如果需要导入多个结构，则并列写出即可</p></li><li><p>可以使用”xxx.*”的方式，表示可以导入xxx包下的所结构</p></li><li><p>如果使用的类或接口是java.lang包下定义的，则可以省略import结构</p></li><li><p>如果使用的类或接口是本包下定义的，则可以省略import结构</p></li><li><p>如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。</p></li><li><p>使用”xxx.*”方式表明可以调用xxx包下的所结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入</p></li><li><p>import static:导入指定类或接口中的静态结构:属性或方法。</p></li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>主要用来修饰类的内部结构，如：属性、方法、代码块、内部类</p><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><blockquote><h5 id="static修饰属性：静态变量（或类变量）"><a href="#static修饰属性：静态变量（或类变量）" class="headerlink" title="static修饰属性：静态变量（或类变量）"></a>static修饰属性：静态变量（或类变量）</h5></blockquote><p>属性是否使用static修饰，可分为：静态属性 vs 非静态属性(实例变量)</p><ul><li>实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</li><li>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</li></ul><p><strong>static修饰属性的其他说明：</strong></p><ul><li>静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用</li><li>静态变量的加载要早于对象的创建。</li><li>由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</li></ul><table><thead><tr><th></th><th><strong>类变量</strong></th><th><strong>实例变量</strong></th></tr></thead><tbody><tr><td>类</td><td>yes</td><td>no</td></tr><tr><td>对象</td><td>yes</td><td>yes</td></tr></tbody></table><p><strong>静态属性举例：System.out; Math.PI;</strong></p><p><strong>静态变量内存解析</strong></p><p><img src="/../image/JavaPic/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.awebp"></p><blockquote><h5 id="static修饰方法：静态方法、类方法"><a href="#static修饰方法：静态方法、类方法" class="headerlink" title="static修饰方法：静态方法、类方法"></a>static修饰方法：静态方法、类方法</h5></blockquote><ul><li>随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</li><li>静态方法中，只能调用静态的方法或属性</li><li>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</li></ul><table><thead><tr><th></th><th><strong>静态方法</strong></th><th><strong>非静态方法</strong></th></tr></thead><tbody><tr><td>类</td><td>yes</td><td>no</td></tr><tr><td>对象</td><td>yes</td><td>yes</td></tr></tbody></table><p><strong>使用的注意点：</strong></p><ul><li>在静态的方法内，不能使用this关键字、super关键字</li><li>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</li></ul><blockquote><h5 id="如何判定属性和方法应该使用static关键字："><a href="#如何判定属性和方法应该使用static关键字：" class="headerlink" title="如何判定属性和方法应该使用static关键字："></a>如何判定属性和方法应该使用static关键字：</h5></blockquote><p><strong>关于属性：</strong></p><ul><li>属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</li><li>类中的常量也常常声明为static</li></ul><p><strong>关于方法：</strong></p><ul><li>操作静态属性的方法，通常设置为static的</li><li>工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</li></ul><p><strong>使用举例：</strong>记录创建的圆的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;<span class="comment">//自动赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">()</span>&#123;</span><br><span class="line">id = init++;</span><br><span class="line">total++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>();</span><br><span class="line"><span class="comment">//id = init++;</span></span><br><span class="line"><span class="comment">//total++;</span></span><br><span class="line"><span class="built_in">this</span>.radius = radius;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> total;<span class="comment">//记录创建的圆的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">init</span> <span class="operator">=</span> <span class="number">1001</span>;<span class="comment">//static声明的属性被所对象所共享</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getRadius</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRadius</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getTotal</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><blockquote><h5 id="设计模式的说明"><a href="#设计模式的说明" class="headerlink" title="设计模式的说明"></a>设计模式的说明</h5></blockquote><p>设计模式是在大量的实践中总结和理论化之后优的代码结构、编程风格、以及解决问题的思考方式。</p><p><strong>常用设计模式 — 23种经典的设计模式 GOF</strong></p><ul><li>创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</li><li>结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</li><li>行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</li></ul><blockquote><h5 id="单例模式-1"><a href="#单例模式-1" class="headerlink" title="单例模式"></a>单例模式</h5></blockquote><p>所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">饿汉式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.内部创建类的对象</span></span><br><span class="line"><span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">饿汉式<span class="number">2</span>：使用了静态代码块</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两种方式的对比</strong>：</p><ul><li>饿汉式：上来就创建对象<ul><li>坏处：对象加载时间过长。</li><li>好处：饿汉式是线程安全的</li></ul></li><li>懒汉式：什么时候用什么时候造对象<ul><li>好处：延迟对象的创建。</li><li>目前的写法坏处：线程不安全。—&gt;到多线程内容时，再修改</li></ul></li></ul><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p><strong>可以用来修饰：类、方法、变量</strong></p><ol><li><p>final 用来修饰一个类:此类不能被其他类所继承。</p><p>比如：String类、System类、StringBuffer类</p></li><li><p>final 用来修饰方法：表明此方法不可以被重写</p><p>比如：Object类中getClass();</p></li><li><p>final 用来修饰变量：此时的”变量”就称为是一个常量</p><ul><li>final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</li><li>final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</li></ul></li><li><p>static final 用来修饰属性：全局常量</p></li></ol><h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>abstract: 抽象的，可以用来修饰：类、方法</p><h4 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h4><blockquote><h5 id="abstract修饰类：抽象类"><a href="#abstract修饰类：抽象类" class="headerlink" title="abstract修饰类：抽象类"></a>abstract修饰类：抽象类</h5></blockquote><ul><li>此类不能实例化</li><li>抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</li><li>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 —&gt;抽象的使用前提：继承性</li></ul><blockquote><h5 id="abstract修饰方法：抽象方法"><a href="#abstract修饰方法：抽象方法" class="headerlink" title="abstract修饰方法：抽象方法"></a>abstract修饰方法：抽象方法</h5></blockquote><ul><li>抽象方法只方法的声明，没方法体</li><li>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</li><li>若子类重写了父类中的所的抽象方法后，此子类方可实例化</li><li>若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</li></ul><p><strong>注意点：</strong></p><ul><li>abstract不能用来修饰：属性、构造器等结构</li><li>abstract不能用来修饰私有方法、静态方法（静态方法不能被重写，抽象方法不能调用）、final的方法、final的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Vehicle</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">()</span>;<span class="comment">//计算燃料效率的抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">()</span>;<span class="comment">//计算行驶距离的抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Truck</span> <span class="keyword">extends</span> <span class="title class_">Vehiclel</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">( )</span>&#123;<span class="comment">//写出计算卡车的燃料效率的具体方法&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">( )</span>&#123;<span class="comment">//写出计算卡车行驶距离的具体方法&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">River</span> Barge <span class="keyword">extends</span> <span class="title class_">Vehicle</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcFuelEfficiency</span><span class="params">( )</span>&#123;<span class="comment">//写出计算驳船的燃料效率的具体方法&#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">calcTripDistance</span><span class="params">( )</span>&#123;<span class="comment">//写出计算驳船行驶距离的具体方法&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GeometricObject</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">GeometricObject</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findArea</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3.14</span> * radius * radius;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IO流中设计到的抽象类：InputStream&#x2F;OutputStream &#x2F; Reader &#x2F;Writer。在其内部定义了抽象的read()、write()方法。</p><h4 id="模板方法的设计模式"><a href="#模板方法的设计模式" class="headerlink" title="模板方法的设计模式"></a>模板方法的设计模式</h4><blockquote><h5 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h5></blockquote><p>在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变 部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算某段代码执行所需要花费的时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">spendTime</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.code();<span class="comment">//不确定的部分、易变的部分</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5></blockquote><p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：</p><ul><li>数据库访问的封装</li><li>Junt单元测试</li><li>JavaWeb的 Servlet中关于 doGet&#x2F;doPost方法调用</li><li>Hibernate中模板程序</li><li>Spring中 JDBCTemlate、 Hibernate Template等</li></ul><h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><ol><li>接口使用interface来定义</li><li>Java中，接口和类是并列的两个结构</li></ol><h4 id="使用-5"><a href="#使用-5" class="headerlink" title="使用"></a>使用</h4><ul><li><p>如何定义接口：定义接口中的成员</p></li><li><p>接口中不能定义构造器的！意味着接口不可以实例化</p></li><li><p>Java开发中，接口通过让类去实现(implements)的方式来使用.</p><ul><li><p>如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</p></li><li><p>如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</p></li></ul></li><li><p>Java类可以实现多个接口 —&gt;弥补了Java单继承性的局限性</p></li><li><p>格式：class AA extends BB implements CC,DD,EE</p></li><li><p>接口与接口之间可以继承，而且可以多继承</p></li><li><p>接口的具体使用，体现多态性</p></li><li><p>接口，实际上可以看做是一种规范</p></li></ul><blockquote><p>不同的设备通过USB口接入电脑</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferData</span><span class="params">(USB usb)</span>&#123;<span class="comment">//USB usb = new Flash();</span></span><br><span class="line">usb.start();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;具体传输数据的细节&quot;</span>);</span><br><span class="line"></span><br><span class="line">usb.stop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"><span class="comment">//常量：定义了长、宽、最大最小的传输速度等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flash</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>接口使用上也满足多态性</li><li>接口，实际上就是定义了一种规范</li><li>开发中，体会面向接口编程！</li></ol><h4 id="面向接口编程的思想"><a href="#面向接口编程的思想" class="headerlink" title="面向接口编程的思想"></a>面向接口编程的思想</h4><p><img src="/../image/JavaPic/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B%E7%9A%84%E6%80%9D%E6%83%B3.awebp"></p><p>面向接口编程：我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个 数据库厂商的API。</p><h4 id="Java8中关于接口的新规范"><a href="#Java8中关于接口的新规范" class="headerlink" title="Java8中关于接口的新规范"></a>Java8中关于接口的新规范</h4><ul><li><p>JDK7及以前：只能定义全局常量和抽象方法</p><ul><li><p>全局常量：public static final的，书写时可以省略不写</p></li><li><p>抽象方法：public abstract的</p></li></ul></li><li><p>JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法</p><ul><li><p>Java8中，可以为接口添加静态方法和默认方法。从技术角度来说，这是完全合法的，只是它看起来违反了接口作为一个抽象定义的理念。</p></li><li><p>静态方法：使用 static关键字修饰。</p><p>可以通过接口直接调用静态方法，并执行其方法体。我们经常在相互一起使用的类中使用静态方法。你可以在标准库中找到像 Collection&#x2F;co| ections或者Path&#x2F; Paths这样成对的接口和类。</p></li><li><p>默认方法：默认方法使用 default关键字修饰。</p></li><li><p>可以通过实现类对象来调用。我们在已有的接口中提供新方法的同时，还保持了与旧版本代码的兼容性比如：java8API中对 Collection、List、 Comparator等接口提供了丰富的默认方法。</p></li></ul></li></ul><blockquote><p><strong>JDK 8后接口使用总结</strong></p></blockquote><ul><li><p>知识点1：接口中定义的静态方法，只能通过接口来调用。</p></li><li><p>知识点2：通过实现类的对象，可以调用接口中的默认方法。</p></li><li><p>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</p></li><li><p>知识点3：如果子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt;类优先原则</p></li><li><p>知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</p></li></ul><p>​那么在实现类没重写此方法的情况下，报错。–&gt;接口冲突。</p><p>​这就需要我们必须在实现类中重写此方法</p><ul><li>知识点5：如何在子类(或实现类)的方法中调用父类、接口中被重写的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>&#123;</span><br><span class="line">method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line"><span class="built_in">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line"><span class="comment">//调用接口中的默认方法</span></span><br><span class="line">CompareA.<span class="built_in">super</span>.method3();</span><br><span class="line">CompareB.<span class="built_in">super</span>.method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h4><blockquote><p><strong>抽象类和接口的异同？</strong></p></blockquote><p>相同点：</p><p>​都不能实例化；都可以被继承；都可以包含抽象方法的。</p><p>不同点：</p><p>​抽象类：有构造器。接口：没有构造器</p><p>​1）把抽象类和接口(java7,java8,java9)的定义、内部结构解释说明</p><p>​2）类：单继承性 接口：多继承</p><p>​ 类与接口：多实现</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><blockquote><h5 id="解决的问题-1"><a href="#解决的问题-1" class="headerlink" title="解决的问题"></a>解决的问题</h5></blockquote><p>代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;真实的服务器访问网络&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyServer</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> NetWork work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyServer</span><span class="params">(NetWork work)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.work = work;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;联网之前的检查工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">check();</span><br><span class="line"></span><br><span class="line">work.browse();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5></blockquote><ul><li><p>-安全代理：屏蔽对真实角色的直接访问</p></li><li><p>远程代理：通过代理类处理远程方法调用（RM）</p></li><li><p>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用 proxy来进行大图片的打开。</p></li></ul><blockquote><h5 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h5></blockquote><ul><li>静态代理（静态定义代理类）</li><li>动态代理（动态生成代理类）JDK自带的动态代理，需要反射等知识</li></ul><h4 id="工厂的设计模式"><a href="#工厂的设计模式" class="headerlink" title="工厂的设计模式"></a>工厂的设计模式</h4><blockquote><p><strong>解决的问题</strong></p></blockquote><p>实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</p><blockquote><p><strong>具体模式：</strong></p></blockquote><ul><li>简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</li><li>工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品)</li><li>抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)</li></ul><h2 id="Java之多线程"><a href="#Java之多线程" class="headerlink" title="Java之多线程"></a>Java之多线程</h2><h3 id="程序、进程、线程"><a href="#程序、进程、线程" class="headerlink" title="程序、进程、线程"></a>程序、进程、线程</h3><h4 id="程序（program）"><a href="#程序（program）" class="headerlink" title="程序（program）"></a>程序（program）</h4><p>概念：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。</p><h4 id="进程（process）"><a href="#进程（process）" class="headerlink" title="进程（process）"></a>进程（process）</h4><p>概念：程序的一次执行过程，或是正在运行的一个程序。 说明：进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</p><h4 id="线程（thread）"><a href="#线程（thread）" class="headerlink" title="线程（thread）"></a>线程（thread）</h4><p>概念：进程可进一步细化为线程，是一个程序内部的一条执行路径。 说明：线程作为调度和执行的单位，每个线程拥独立的运行栈和程序计数器(pc)，线程切换的开销小。</p><p><img src="/../image/JavaPic/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B.awebp"></p><blockquote><p><strong>内存结构</strong></p></blockquote><p><img src="/../image/JavaPic/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.awebp"></p><p>进程可以细化为多个线程。 每个线程，拥有自己独立的：栈、程序计数器 多个线程，共享同一个进程中的结构：方法区、堆。</p><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><h4 id="单核CPU与多核CPU"><a href="#单核CPU与多核CPU" class="headerlink" title="单核CPU与多核CPU"></a>单核CPU与多核CPU</h4><p>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。涉及到CPU处理线程的方式，CPU在单位时间（也就是说一个时间片内）内只能处理一个线程，于是就将其他的线程设置为阻塞状态，加入到阻塞队列中，等到处理完成当前线程后从就绪队列中取出新的线程进行处理，由于切换和处理时间很快用户感知不到于是用户便认为CPU在同一时间内处理多个线程。</p><p>多核CPU，才能更好的发挥多线程的效率。（现在的服务器都是多核的）</p><p>一个Java应用程序java.exe，其实至少三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</p><h4 id="并行与并发的理解"><a href="#并行与并发的理解" class="headerlink" title="并行与并发的理解"></a>并行与并发的理解</h4><p>并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。</p><p>并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事</p><h4 id="为什么使用多线程"><a href="#为什么使用多线程" class="headerlink" title="为什么使用多线程"></a>为什么使用多线程</h4><p>当我们在进行商品抢购的时候，在支付按钮上总是有个计时器在进行倒计时，但是我们此时仍然可以进行商品信息的查看，这个计时器和我们浏览商品信息的线程是同时进行的，这样也就实现了抢购场景，增加了用户的体验。</p><blockquote><p>多线程的优点</p></blockquote><ol><li>提高应用程序的响应。对图形化界面更有意义，可增强用户体验。</li><li>提高计算机系统CPU的利用率。</li><li>改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。</li></ol><blockquote><p>应用场景</p></blockquote><ol><li>程序需要同时执行两个或多个任务。</li><li>程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等</li><li>需要一些后台运行的程序时</li></ol><h3 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h3><p>Java语言的JVM允许程序运行多个线程，它通过 java. lang.Thread类来体现</p><h4 id="Thread类的特性"><a href="#Thread类的特性" class="headerlink" title="Thread类的特性"></a>Thread类的特性</h4><p>每个线程都是通过某个特定 Thread对象的run（方法来完成操作的，经常把run()方法的主体称为线程体 通过该 Thread对象的 start（方法来启动这个线程，而非直接调用run</p><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><ul><li><p>Thread()：创建新的 Thread对象</p></li><li><p>Thread（String threadName）：创建线程并指定线程实例名</p></li><li><p>Thread（Runnable target）：指定创建线程的目标对象，它实现了 Runnable接口中的run方法</p></li><li><p>Thread（Runnable target， String name）：创建新的 Thread对象</p></li></ul><h4 id="创建多线程的两种方式"><a href="#创建多线程的两种方式" class="headerlink" title="创建多线程的两种方式"></a>创建多线程的两种方式</h4><blockquote><p>方式一：继承Thread类的方式：</p></blockquote><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run() –&gt; 将此线程执行的操作声明在run()中</li><li>创建Thread类的子类的对象</li><li>通过此对象调用start()：①启动当前线程 ② 调用当前线程的run()</li></ol><p><strong>注意点：</strong></p><ol><li>我们启动一个线程，必须调用start()，不能调用run()的方式启动线程。 如果再启动一个线程，必须重新创建一个Thread子类的对象，调用此对象的start().（注意后面的点）</li><li>如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式</li><li>run（方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。</li><li>想要启动多线程，必须调用 start方法。</li><li>一个线程对象只能调用一次 start()方法启动，如果重复调用了，则将抛出异常“lllegalThreadStateException”.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.继承Thread类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.重run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//3.新建Thread对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//4.调用start方法</span></span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/JavaPic/%E7%BB%A7%E6%89%BFThread%E7%B1%BB.awebp"></p><blockquote><p>方式二：实现Runnable接口的方式：</p></blockquote><ol><li>创建一个实现了Runnable接口的类</li><li>实现类去实现Runnable中的抽象方法：run()</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3. 创建实现类的对象</span></span><br><span class="line">        <span class="type">RunnableTest</span> <span class="variable">runnableTest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunnableTest</span>();</span><br><span class="line">        <span class="comment">//4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableTest);</span><br><span class="line">        <span class="comment">//5. 通过Thread类的对象调用start()</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两种方式的对比：</strong></p><p>开发中优先选择：实现Runnable接口的方式</p><p><strong>原因：</strong></p><ol><li><p>实现的方式没类的单继承性的局限性</p></li><li><p>实现的方式更适合来处理多个线程共享数据的情况。</p></li></ol><p><strong>联系：</strong>public class Thread implements Runnable</p><p><strong>相同点：</strong>两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。 目前两种方式，要想启动线程，都是调用的Thread类中的start()。</p><p><strong>也可以采用创建匿名类的方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Thread类的匿名子类的方式</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Thread类的常用方法"><a href="#Thread类的常用方法" class="headerlink" title="Thread类的常用方法"></a>Thread类的常用方法</h4><blockquote><p>常用方法：</p></blockquote><ul><li><p>start():启动当前线程；调用当前线程的run()，只有Thread类和他的子类才能调用start()方法</p></li><li><p>run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</p></li><li><p>currentThread():静态方法，返回执行当前代码的线程</p></li><li><p>getName():获取当前线程的名字</p></li><li><p>setName():设置当前线程的名字</p></li><li><p>yield():释放当前cpu的执行权</p></li><li><p>join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</p></li><li><p>stop():已过时。当执行此方法时，强制结束当前线程。</p></li><li><p>sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。</p></li><li><p>isAlive():判断当前线程是否存活</p></li></ul><blockquote><p>线程的优先级：</p></blockquote><ul><li>MAX_PRIORITY：10</li><li>MIN _PRIORITY：1</li><li>NORM_PRIORITY：5 –&gt;默认优先级</li></ul><p>获取和设置当前线程的优先级：</p><ul><li>getPriority():获取线程的优先级</li><li>setPriority(int p):设置线程的优先级</li></ul><p>说明：高优先级的线程要抢占低优先级线程CPU的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。</p><p>线程通信：wait() &#x2F; notify() &#x2F; notifyAll() :此三个方法定义在Object类中的。</p><p><strong>线程的分类</strong></p><ul><li>守护线程，如：垃圾回收线程，依赖于主线程而存在</li><li>用户线程，如：main方法的线程</li></ul><h4 id="Thread的生命周期"><a href="#Thread的生命周期" class="headerlink" title="Thread的生命周期"></a>Thread的生命周期</h4><blockquote><p><strong>线程的五种状态：</strong></p></blockquote><ul><li><p>新建：当一个 Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</p></li><li><p>就绪：处于新建状态的线程被star()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源</p></li><li><p>运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run()方法定义了线程的操作和功能</p></li><li><p>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CP∪并临时中止自己的执行，进入阻塞状态</p></li><li><p>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</p></li></ul><p><img src="/../image/JavaPic/Thread%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.awebp"></p><p><strong>说明：</strong></p><ol><li>生命周期关注两个概念：状态、相应的方法</li><li>关注：状态a–&gt;状态b:哪些方法执行了（回调方法） 某个方法主动调用：状态a–&gt;状态b</li><li>阻塞：临时状态，不可以作为最终状态</li><li>死亡：最终状态。</li></ol><h3 id="线程的同步机制"><a href="#线程的同步机制" class="headerlink" title="线程的同步机制"></a>线程的同步机制</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>例子：创建个窗口卖票，总票数为100张.使用实现Runnable接口的方式</p><ul><li>问题：卖票过程中，出现了重票、错票 –&gt;出现了线程的安全问题</li><li>问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票。</li><li>如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变。</li></ul><h4 id="Java解决方案：同步机制"><a href="#Java解决方案：同步机制" class="headerlink" title="Java解决方案：同步机制"></a>Java解决方案：同步机制</h4><p>在Java中，我们通过同步机制，来解决线程的安全问题。</p><blockquote><h5 id="方式一：同步代码块"><a href="#方式一：同步代码块" class="headerlink" title="方式一：同步代码块"></a>方式一：同步代码块</h5></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;<span class="comment">//同步监视器就是需要同步线程的公共对象</span></span><br><span class="line">   <span class="comment">//需要被同步的代码</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ol><li>操作共享数据的代码，即为需要被同步的代码。 –&gt;不能包含代码多了，也不能包含代码少了。</li><li>共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。</li><li>同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。</li><li>要求多个线程必须要共用同一把锁。</li></ol><ul><li>在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。</li><li>在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。</li></ul><p><strong>代码示例：</strong></p><p><strong>继承Runnable接口形式同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号窗口买票，票号为：&quot;</span> + tick--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        thread3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承Thread类形式同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Ticket2</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            <span class="comment">//synchronized (Ticket2.class) &#123;//通过反射调用当前类</span></span><br><span class="line">                <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号窗口买票，票号为&quot;</span> + tick--);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line">        <span class="type">Ticket2</span> <span class="variable">ticket3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket2</span>();</span><br><span class="line"></span><br><span class="line">        ticket1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        ticket2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        ticket3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        ticket1.start();</span><br><span class="line">        ticket2.start();</span><br><span class="line">        ticket3.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="方式二：同步方法"><a href="#方式二：同步方法" class="headerlink" title="方式二：同步方法"></a>方式二：同步方法</h5></blockquote><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String namer)</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Ticket3</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tick</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isFlag) &#123;</span><br><span class="line">            show();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;<span class="comment">//同步show方法，继承Thread类方法一样，只需同步方法即可，同时需要给方法加static关键字，确保不会创建多个对象</span></span><br><span class="line">        <span class="keyword">if</span> (tick &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;号窗口买票，票号为：&quot;</span> + tick--);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isFlag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TicketTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket3</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket3</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ticket);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        thread3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="方式三：Lock锁-—-JDK-5-0新增"><a href="#方式三：Lock锁-—-JDK-5-0新增" class="headerlink" title="方式三：Lock锁 — JDK 5.0新增"></a>方式三：Lock锁 — JDK 5.0新增</h5></blockquote><ul><li><p>从JDK 5.0开始，Java提供了更强大的线程同步机制–通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。</p></li><li><p>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。</p></li><li><p>ReentrantLock类实现了Lock，它拥有与 synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 Reentrantlock，可以显式加锁、释放锁。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReenTrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenTrantLook</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span> <span class="params">()</span>&#123;</span><br><span class="line">        lock.lock<span class="comment">//2.先加锁</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//保证线程同步的代码</span></span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();<span class="comment">//3.后解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：如果同步代码块有异常，要将unlock()写入finally语句块中</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//1.实例化ReentrantLock</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//2.调用锁定方法lock()</span></span><br><span class="line">                lock.lock();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：售票，票号为：&quot;</span> + ticket);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//3.调用解锁方法：unlock()</span></span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Window</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Window</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(w);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;窗口1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;窗口2&quot;</span>);</span><br><span class="line">        t3.setName(<span class="string">&quot;窗口3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="同步方法总结"><a href="#同步方法总结" class="headerlink" title="同步方法总结"></a>同步方法总结</h4><p>在《 Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他仼务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。</p><p><strong>synchronized的锁是什么</strong>：</p><ol><li>任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）</li><li>同步方法的锁：静态方法（类名.class）、非静态方法（this）</li><li>同步代码块：自己指定，很多时候也是指定为this或类名.class</li></ol><p><strong>注意点：</strong></p><ol><li>必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全</li><li>一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎）</li><li>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</li><li>非静态的同步方法，同步监视器是：this</li><li>静态的同步方法，同步监视器是：当前类本身</li></ol><h4 id="同步的范围"><a href="#同步的范围" class="headerlink" title="同步的范围"></a>同步的范围</h4><p><strong>如何找问题，即代码是否存在线程安全？（非常重要</strong>）</p><p>（1）明确哪些代码是多线程运行的代码</p><p>（2）明确多个线程是否有共享数据</p><p>（3）明确多线程运行代码中是否有多条语句操作共享数据</p><p><strong>如何解决呢？（非常重要）</strong></p><p>对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。 即所有操作共享数据的这些语句都要放在同步范围中</p><p><strong>注意点：</strong></p><p>范围太小：没锁住所有有安全问题的代码 范围太大：没发挥多线程的功能。</p><h4 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h4><p><strong>1. synchronized 与 Lock的异同？</strong></p><ol><li><p>相同：二者都可以解决线程安全问题</p></li><li><p>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器</p></li><li><p>Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()）</p></li><li><p>使用的优先顺序：</p><p>Lock—&gt; 同步代码块（已经进入了方法体，分配了相应资源 ) —&gt;同步方法（在方法体之外)</p></li><li><p>利弊： 同步的方式，解决了线程的安全问题。—好处 操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。</p></li></ol><p><strong>2. Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同</strong></p><p>利用同步锁的方式，有三种方式同步代码块、同步方法和用lock方法</p><p><strong>3. synchronized和Lock方式解决线程安全问题的对比</strong></p><ol><li>相同：二者都可以解决线程安全问题</li><li>不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器</li><li>Lock需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()）</li></ol><h4 id="线程安全的单例模式"><a href="#线程安全的单例模式" class="headerlink" title="线程安全的单例模式"></a>线程安全的单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">使用同步机制将单例模式中的懒汉式改写为线程安全的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//方式一：效率稍差</span></span><br><span class="line"><span class="comment">//        synchronized (Bank.class) &#123;</span></span><br><span class="line"><span class="comment">//            if(instance == null)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                instance = new Bank();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            return instance;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//方式二：效率更高</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (Bank.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><ol><li><p>死锁的理解： 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</p></li><li><p>说明：</p><ul><li><p>出现死锁后，不会出现异常，不会出现提示，只是所的线程都处于阻塞状态，无法继续</p></li><li><p>我们使用同步时，要避免出现死锁。</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line"></span><br><span class="line">                s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                s2.append(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(s1);</span><br><span class="line">                    System.out.println(s2);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (s2)&#123;</span><br><span class="line"></span><br><span class="line">                s1.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">                s2.append(<span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (s1)&#123;</span><br><span class="line">                    s1.append(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">                    s2.append(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    System.out.println(s1);</span><br><span class="line">                    System.out.println(s2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程通讯"><a href="#线程通讯" class="headerlink" title="线程通讯"></a>线程通讯</h3><h4 id="线程通信涉及到的三个方法"><a href="#线程通信涉及到的三个方法" class="headerlink" title="线程通信涉及到的三个方法"></a>线程通信涉及到的三个方法</h4><ul><li><p>wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。</p></li><li><p>notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。</p></li><li><p>notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。</p></li></ul><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul><li><p>wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。</p></li><li><p>wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步方法中的同步监视器。</p><p>否则，会出现IllegalMonitorStateException异常</p></li><li><p>wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中。</p></li></ul><p><strong>代码示例：</strong></p><p>使用两个线程打印 1-100，线程1, 线程2 交替打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                object.notify();<span class="comment">//调用notify()方法唤醒线程</span></span><br><span class="line">                <span class="keyword">if</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="comment">//线程休眠</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + number);</span><br><span class="line">                    number++;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        object.wait();<span class="comment">//打印输出一次后调用wait()方法将线程阻塞</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommunicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line"></span><br><span class="line">        thread1.setName(<span class="string">&quot;线程1:&quot;</span>);</span><br><span class="line">        thread2.setName(<span class="string">&quot;线程2:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题-4"><a href="#面试题-4" class="headerlink" title="面试题"></a>面试题</h4><p>sleep() 和 wait()的异同？</p><p>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</p><p>不同点：</p><p>1）两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</p><p>2）调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</p><p>3）关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</p><h4 id="释放锁的操作"><a href="#释放锁的操作" class="headerlink" title="释放锁的操作"></a>释放锁的操作</h4><ul><li><p>当前线程的同步方法、同步代码块执行结束</p></li><li><p>当前线程在同步代码块、同步方法中遇到 break、 return终止了该代码块该方法的继续执行。</p></li><li><p>当前线程在同步代码块、同步方法中出现了未处理的Error或 Exception，导致异常结束。</p></li><li><p>当前线程在同步代码块、同步方法中执行了线程对象的 wait()方法，当前线程暂停，并释放锁</p></li></ul><h4 id="不会释放锁的操作"><a href="#不会释放锁的操作" class="headerlink" title="不会释放锁的操作"></a>不会释放锁的操作</h4><ul><li><p>线程执行同步代码块或同步方法时，程序调用 Thread. sleep()、Thread yield()方法暂停当前线程的执行</p></li><li><p>线程执行同步代码块时，其他线程调用了该线程的 suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）</p></li><li><p>应尽量避免使用 suspend()和 resume()来控制线程</p></li></ul><h3 id="JDK5-0-新增线程创建方式"><a href="#JDK5-0-新增线程创建方式" class="headerlink" title="JDK5.0 新增线程创建方式"></a>JDK5.0 新增线程创建方式</h3><h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><p><strong>实现方法：</strong></p><ol><li>创建一个实现Callable的实现类</li><li>实现call方法，将此线程需要执行的操作声明在call()中</li><li>创建Callable接口实现类的对象</li><li>将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</li><li>将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</li><li>获取Callable中call方法的返回值</li></ol><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">//2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">//4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">//5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">//get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？</strong></p><ol><li>call()可以返回值的。</li><li>call()可以抛出异常，被外面的操作捕获，获取异常的信息</li><li>Callable是支持泛型的</li></ol><h4 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h4><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程对性能影响很大。</p><p><strong>解决方案：</strong></p><p>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</p><p><strong>实现方法：</strong></p><ol><li>提供指定线程数量的线程池</li><li>执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</li><li>关闭连接池</li></ol><p><strong>相关API：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">JDK <span class="number">5.0</span>起提供了线程池相关AP|： Executor Service和 Executors</span><br><span class="line"></span><br><span class="line">Executor Service：真正的线程池接口。常见子类 Thread Poolexecutor</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command）：执行任务/命令，没有返回值，一般用来执行Runnable</span></span><br><span class="line"><span class="params">&lt;T&gt; Future&lt;T&gt; submit（Callable&lt;T&gt;task）：执行任务，有返回值，一般又来执行Callable</span></span><br><span class="line"><span class="params"><span class="keyword">void</span> shutdown()</span>：关闭连接池</span><br><span class="line"></span><br><span class="line">Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池</span><br><span class="line">Executors. newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</span><br><span class="line">Executors.newFⅸedthreadPool(n)；创建一个可重用固定线程数的线程池</span><br><span class="line">EXecutors. newSingleThreadEXecutor()：创建一个只有一个线程的线程池</span><br><span class="line">Executors. <span class="keyword">new</span> <span class="title class_">thread</span> Poo(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</span><br></pre></td></tr></table></figure><p><strong>代码示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//        service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//        service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        service.submit(Callable callable);//适合使用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用线程池的好处：</strong></p><ol><li><p>提高响应速度（减少了创建新线程的时间）</p></li><li><p>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</p></li><li><p>便于线程管理</p><p>corePoolSize：核心池的大小</p><p>maximumPoolSize：最大线程数</p><p>keepAliveTime：线程没任务时最多保持多长时间后会终止</p></li></ol><p><strong>面试题：Java中多线程的创建有几种方式？四种。</strong></p><p>JDK 5.0以前：</p><ul><li>即继承Thread类重run方法</li><li>实现Runnable接口实现run方法</li></ul><p>JDK 5.0以后：</p><ul><li>实现callable接口，实现call方法</li><li>利用线程池</li></ul><h2 id="Java中的常用类"><a href="#Java中的常用类" class="headerlink" title="Java中的常用类"></a>Java中的常用类</h2><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><p><code>java.lang.String</code> 类的使用</p><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>String:字符串，使用一对””引起来表示。</p><ol><li><p>String声明为final的，不可被继承</p></li><li><p>String 实现了 <code>Serializable</code> 接口：表示字符串是支持序列化的。 实现了  <code>Comparable</code> 接口：表示String可以比较大小</p></li><li><p>String内部定义了 <code>final char[] value</code> 用于存储字符串数据</p></li><li><p>String:代表不可变的字符序列。简称：不可变性。</p><p><strong>体现：</strong></p><p>4.1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p><p>4.2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p><p>4.3.当调用String的 <code>replace()</code> 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p></li><li><p>通过字面量的方式（区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中)。</p></li><li><p>字符串常量池中是不会存储相同内容(使用String类的equals()比较，返回true)的字符串的)。</p></li></ol><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>String类：代表字符串。Java程序中的所有字符串字面值（如”abc”）都作为此类的实例实现。 String是一个final类，代表不可变的字符序列。 字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改。 String对象的字符内容是存储在一个字符数组vaue[]中的。</p><p><strong>String源码构造器:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><h4 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h4><blockquote><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5></blockquote><ul><li><p>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p></li><li><p>当对现的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p></li><li><p>当调用String的 <code>replace()</code> 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;<span class="comment">//通过字面量的定义方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line">s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false 比较s1与s2的地址值</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1);<span class="comment">//hello</span></span><br><span class="line">System.out.println(s2);<span class="comment">//def</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">s3 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">System.out.println(s3);<span class="comment">//abcdef</span></span><br><span class="line">System.out.println(s2);<span class="comment">//def</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span><span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4.replace(<span class="string">&quot;t&quot;</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">System.out.println(s4);<span class="comment">//test</span></span><br><span class="line">System.out.println(s5);<span class="comment">//besb</span></span><br></pre></td></tr></table></figure><p><img src="/../image/JavaPic/String%E7%9A%84%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7.awebp"></p><h4 id="String实例化方法"><a href="#String实例化方法" class="headerlink" title="String实例化方法"></a>String实例化方法</h4><ul><li>方式一：通过字面量定义的方式</li><li>方式二：通过new + 构造器的方式</li></ul><blockquote><p><strong>面试题：</strong></p></blockquote><p><code>String s = new String(&quot;abc&quot;);</code> 方式创建对象，在内存中创建了几个对象？</p><p>两个:一个是堆空间中new结构，另一个是<code>char[]</code>对应的常量池中的数据：”abc”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="comment">//通过new + 构造器的方式:此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;javaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p><code>String str1=“abc”;</code> 与 <code>String str2= new String(“abc”);</code> 的区别?</p><p><img src="/../image/JavaPic/%E6%96%B0%E5%BB%BAString%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90-1.awebp"></p><p>新建String对象的内存解析</p><p><img src="/../image/JavaPic/%E6%96%B0%E5%BB%BAString%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90-2.awebp"></p><h4 id="字符串拼接方式赋值对比"><a href="#字符串拼接方式赋值对比" class="headerlink" title="字符串拼接方式赋值对比"></a>字符串拼接方式赋值对比</h4><ol><li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</li><li>只要其中一个是变量，结果就在堆中。</li><li>如果拼接的结果调用 <code>intern()</code> 方法，返回值就在常量池中</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();<span class="comment">//返回值得到的s8使用的常量值中已经存在的“javaEEhadoop”</span></span><br><span class="line">System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">****************************</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;<span class="comment">//s4:常量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s5);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><img src="/../image/JavaPic/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.awebp"></p><h4 id="String使用陷阱"><a href="#String使用陷阱" class="headerlink" title="String使用陷阱"></a>String使用陷阱</h4><ul><li><code>String s1=&quot;a&quot;；</code></li></ul><p>​说明：在字符串常量池中创建了一个字面量为”a”的字符串。</p><ul><li><code>s1=s1+&quot;b&quot;</code></li></ul><p>​说明：实际上原来的“a”字符串对象已经丢弃了，现在在堆空间中产生了一个字符串s1+”b”（也就是”ab”）。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能。</p><ul><li><p><code>String s2=&quot;ab&quot;;</code> 说明：直接在字符串常量池中创建一个字面量为”ab”的字符串。</p></li><li><p><code>String s3=&quot;a&quot;+&quot;b&quot;;</code> 说明：s3指向字符串常量池中已经创建的”ab”的字符串。</p></li><li><p><code>String s4=s1.intern(); </code>说明：堆空间的S1对象在调用 intern()之后，会将常量池中已经存在的”ab”字符串赋值给s4。</p></li></ul><h4 id="String类常用方法"><a href="#String类常用方法" class="headerlink" title="String类常用方法"></a>String类常用方法</h4><blockquote><h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h5></blockquote><p><strong>操作字符：</strong></p><ul><li><p><code>int length()</code>：返回字符串的长度： <code>return value.length</code></p></li><li><p><code>char charAt(int index)</code>： 返回某索引处的字符 <code>return value[index]</code></p></li><li><p><code>boolean isEmpty()</code>：判断是否是空字符串：&#96;return value.length &#x3D;&#x3D; 0</p></li><li><p><code>String toLowerCase()</code>：使用默认语言环境，将 String 中的所字符转换为小写</p></li><li><p><code>String toUpperCase()</code>：使用默认语言环境，将 String 中的所字符转换为大写</p></li><li><p><code>String trim()</code>：返回字符串的副本，忽略前导空白和尾部空白</p></li><li><p><code>boolean equals(Object obj)</code>：比较字符串的内容是否相同</p></li><li><p><code>boolean equalsIgnoreCase(String anotherString)</code>：与 <code>equals()</code> 方法类似，忽略大小写</p></li><li><p><code>String concat(String str)</code>：将指定字符串连接到此字符串的结尾。 等价于用 <code>+</code></p></li><li><p><code>int compareTo(String anotherString)</code>：比较两个字符串的大小</p></li><li><p><code>String substring(int beginIndex)</code>：返回一个新的字符串，它是此字符串的从beginIndex 开始截取到最后的一个子字符串。</p></li><li><p><code>String substring(int beginIndex, int endIndex)</code> ：返回一个新字符串，它是此字符串从 beginIndex 开始截取到 endIndex (不包含)的一个子字符串。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;helloword&quot;</span>;</span><br><span class="line">    System.out.println(s1.length());<span class="comment">//9</span></span><br><span class="line">    System.out.println(s1.charAt(<span class="number">4</span>));<span class="comment">//o</span></span><br><span class="line">    System.out.println(s1.isEmpty());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;HELLOword&quot;</span>;</span><br><span class="line">    System.out.println(s2.toLowerCase());<span class="comment">//hellowod</span></span><br><span class="line">    System.out.println(s2.toUpperCase());<span class="comment">//HELLOWORD</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot; hello word &quot;</span>;</span><br><span class="line">    System.out.println(s3.trim());<span class="comment">//hello word</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;helloword&quot;</span>;</span><br><span class="line">    System.out.println(s4.equals(s1));<span class="comment">//true</span></span><br><span class="line">    System.out.println(s4.equalsIgnoreCase(s2));<span class="comment">//true</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    System.out.println(s5.compareTo(s4));<span class="comment">//-4 相等时返回0，小的时候返回负数</span></span><br><span class="line">    System.out.println(s4.compareTo(s1));<span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    System.out.println(s4.substring(<span class="number">5</span>));<span class="comment">//word</span></span><br><span class="line">    System.out.println(s4.substring(<span class="number">5</span>, <span class="number">9</span>));<span class="comment">//word,取值范围左开右闭</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断字符：</strong></p><ul><li><p><code>boolean endsWith(String suffix)</code>：测试此字符串是否以指定的后缀结束</p></li><li><p><code>boolean startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开始</p></li><li><p><code>boolean startsWith(String prefix, int toffset)</code>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line">    System.out.println(s1.endsWith(<span class="string">&quot;EE&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(s1.startsWith(<span class="string">&quot;a&quot;</span>));<span class="comment">//false</span></span><br><span class="line">    System.out.println(s1.startsWith(<span class="string">&quot;EE&quot;</span>, <span class="number">4</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="查找字符串中的字符"><a href="#查找字符串中的字符" class="headerlink" title="查找字符串中的字符"></a>查找字符串中的字符</h5></blockquote><ul><li><p><code>boolean contains(CharSequence s)：</code>当且仅当此字符串包含指定的 char 值序列时，返回 true</p></li><li><p><code>int indexOf(String str)</code>：返回指定子字符串在此字符串中第一次出现处的索引</p></li><li><p><code>int indexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</p></li><li><p><code>int lastIndexOf(String str)</code>：返回指定子字符串在此字符串中最右边出现处的索引</p></li><li><p><code>int lastIndexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</p></li></ul><p>注：<code>indexOf</code> 和 <code>lastIndexOf</code> 方法如果未找到都是返回-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    String s2=<span class="string">&quot;hello word&quot;</span>;</span><br><span class="line">    System.out.println(s2.contains(<span class="string">&quot;o&quot;</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(s2.indexOf(<span class="string">&quot;h&quot;</span>));<span class="comment">//0</span></span><br><span class="line">    System.out.println(s2.indexOf(<span class="string">&quot;o&quot;</span>, <span class="number">5</span>));<span class="comment">//7</span></span><br><span class="line">    System.out.println(s2.lastIndexOf(<span class="string">&quot;o&quot;</span>));<span class="comment">//7</span></span><br><span class="line">    System.out.println(s2.lastIndexOf(<span class="string">&quot;l&quot;</span>, <span class="number">2</span>));<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h5></blockquote><p>替换：</p><ul><li><code>String replace(char oldChar, char newChar)</code>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。</li><li><code>String replace(CharSequence target, CharSequence replacement)</code>：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。</li><li><code>String replaceAll(String regex, String replacement)</code>：使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。</li><li><code>String replaceFirst(String regex, String replacement)</code>：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</li></ul><p>匹配:</p><ul><li><code>boolean matches(String regex)</code>：告知此字符串是否匹配给定的正则表达式。</li></ul><p>切片：</p><ul><li><code>String[] split(String regex)</code>：根据给定正则表达式的匹配拆分此字符串。</li><li><code>String[] split(String regex, int limit)</code>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;北京你好，你好北京&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str1.replace(<span class="string">&#x27;北&#x27;</span>, <span class="string">&#x27;南&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(str1);<span class="comment">//北京你好，你好北京</span></span><br><span class="line">    System.out.println(str2);<span class="comment">//南京你好，你好南京</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str1.replace(<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>);</span><br><span class="line">    System.out.println(str3);<span class="comment">//上海你好，你好上海</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;12hello34world5java7891mysql456&quot;</span>;</span><br><span class="line">    <span class="comment">//把字符串中的数字替换成,，如果结果中开头和结尾有，的话去掉</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> str.replaceAll(<span class="string">&quot;\\d+&quot;</span>, <span class="string">&quot;,&quot;</span>).replaceAll(<span class="string">&quot;^,|,$&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    System.out.println(string);<span class="comment">//hello,world,java,mysql</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line">    str = <span class="string">&quot;12345&quot;</span>;</span><br><span class="line">    <span class="comment">//判断str字符串中是否全部有数字组成，即有1-n个数字组成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> str.matches(<span class="string">&quot;\\d+&quot;</span>);</span><br><span class="line">    System.out.println(matches);<span class="comment">//true</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tel</span> <span class="operator">=</span> <span class="string">&quot;0571-4534289&quot;</span>;</span><br><span class="line">    <span class="comment">//判断这是否是一个杭州的固定电话</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> tel.matches(<span class="string">&quot;0571-\\d&#123;7,8&#125;&quot;</span>);</span><br><span class="line">    System.out.println(result);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************************&quot;</span>);</span><br><span class="line">    str = <span class="string">&quot;hello|world|java&quot;</span>;</span><br><span class="line">    String[] strs = str.split(<span class="string">&quot;\\|&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">        System.out.println(strs[i]);<span class="comment">//依次输出hello word java</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    str2 = <span class="string">&quot;hello.world.java&quot;</span>;</span><br><span class="line">    String[] strs2 = str2.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs2.length; i++) &#123;</span><br><span class="line">        System.out.println(strs2[i]);<span class="comment">//依次输出hello word java</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="String与其他结构的转换"><a href="#String与其他结构的转换" class="headerlink" title="String与其他结构的转换"></a>String与其他结构的转换</h4><blockquote><h5 id="String与基本数据类型、包装类之间的转换"><a href="#String与基本数据类型、包装类之间的转换" class="headerlink" title="String与基本数据类型、包装类之间的转换"></a>String与基本数据类型、包装类之间的转换</h5></blockquote><p>String –&gt; 基本数据类型、包装类：调用包装类的静态方法：<code>parseXxx(str)</code></p><p>基本数据类型、包装类 –&gt; String:调用String重载的 <code>valueOf(xxx)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringToBasic</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    System.out.println(i == <span class="number">123</span>);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">456</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(j);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    System.out.println(s.equals(<span class="string">&quot;456&quot;</span>));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="与字符数组之间的转换"><a href="#与字符数组之间的转换" class="headerlink" title="与字符数组之间的转换"></a>与字符数组之间的转换</h5></blockquote><p>String –&gt; char[]:调用String的 <code>toCharArray() char[]</code> –&gt; String:调用String的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">BasicToString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;helloword&quot;</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = s1.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">        System.out.println(chars[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] charArray = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    System.out.println(s2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="与字节数组之间的转换"><a href="#与字节数组之间的转换" class="headerlink" title="与字节数组之间的转换"></a>与字节数组之间的转换</h5></blockquote><p>编码：String –&gt; byte[]:调用String的 <code>getBytes()</code></p><p>解码：byte[] –&gt; String:调用String的构造器</p><p>编码：字符串 –&gt;字节 (看得懂 —&gt;看不懂的二进制数据)</p><p>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂</p><p>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringToByteTest</span><span class="params">()</span> <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span><span class="string">&quot;你好java世界&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytesArray = s1.getBytes();<span class="comment">//使用默认字符集编码</span></span><br><span class="line">    System.out.println(Arrays.toString(bytesArray));<span class="comment">//[-28, -67, -96, -27, -91, -67, 106, 97, 118, 97, -28, -72, -106, -25, -107, -116]</span></span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] gbks = s1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk编码集合</span></span><br><span class="line">    System.out.println(Arrays.toString(gbks));<span class="comment">//[-60, -29, -70, -61, 106, 97, 118, 97, -54, -64, -67, -25]</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;--------------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String str1=<span class="keyword">new</span> <span class="title class_">String</span>(bytesArray);<span class="comment">//使用默认字符进行解码</span></span><br><span class="line">    System.out.println(str1);<span class="comment">//你好java世界</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);<span class="comment">//使用默认字符对gbk编码进行解码</span></span><br><span class="line">    System.out.println(str2);<span class="comment">//���java����解码错误，出现中文乱码,原因：编码和解码不一致</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks,<span class="string">&quot;gbk&quot;</span>);<span class="comment">//使用gbk格式进行解码</span></span><br><span class="line">    System.out.println(str3);<span class="comment">//你好java世界，解码正确，原因：编码和解码一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="与StringBuffer、StringBuilder之间的转换"><a href="#与StringBuffer、StringBuilder之间的转换" class="headerlink" title="与StringBuffer、StringBuilder之间的转换"></a>与StringBuffer、StringBuilder之间的转换</h5></blockquote><p>1.String –&gt;StringBuffer、StringBuilder: 调用StringBuffer、StringBuilder构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringToStringBufferTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span><span class="string">&quot;helloword&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str1);</span><br><span class="line">    System.out.println(stringBuffer);<span class="comment">//helloword</span></span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">stringBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(str1);</span><br><span class="line">    System.out.println(stringBuilder);<span class="comment">//helloword</span></span><br><span class="line"></span><br><span class="line">    stringBuffer.append(<span class="string">&quot;isStringBuffer&quot;</span>);</span><br><span class="line">    System.out.println(stringBuffer);<span class="comment">//hellowordandgood</span></span><br><span class="line"></span><br><span class="line">    stringBuilder.append(<span class="string">&quot;isStringBuider&quot;</span>);</span><br><span class="line">    System.out.println(stringBuilder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.StringBuffer、StringBuilder –&gt;String:</p><p>①调用String构造器； ②StringBuffer、StringBuilder的toString()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">StringBuiderOrStringBufferToStringTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello StringBuffer&quot;</span>);</span><br><span class="line">    System.out.println(sb1);</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;hello StringBuider&quot;</span>);</span><br><span class="line">    System.out.println(sb2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb1);</span><br><span class="line">    System.out.println(str1);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb2);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;----------------------&quot;</span>);</span><br><span class="line">    System.out.println(sb1.toString());</span><br><span class="line">    System.out.println(sb2.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JVM中字符串常量池存放位置说明"><a href="#JVM中字符串常量池存放位置说明" class="headerlink" title="JVM中字符串常量池存放位置说明"></a>JVM中字符串常量池存放位置说明</h4><p>jdk 1.6 (jdk 6.0 ,java 6.0):字符串常量池存储在方法区（永久区）</p><p>jdk 1.7:字符串常量池存储在堆空间</p><p>jdk 1.8:字符串常量池存储在方法区（元空间）</p><h4 id="常见算法题"><a href="#常见算法题" class="headerlink" title="常见算法题"></a>常见算法题</h4><p>1）模拟一个trim方法，去除字符串两端的空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">myTrim</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录从前往后首次索引位置不是空格的位置索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> str.length() - <span class="number">1</span>;<span class="comment">//记录从后往前首次索引位置不是空格的位置索引</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; str.charAt(start) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end &amp;&amp; str.charAt(end) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (str.charAt(start) == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.substring(start, end + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse1</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//1.转换成char型数组</span></span><br><span class="line">        <span class="type">char</span>[] charArray = str.toCharArray();</span><br><span class="line">        <span class="comment">//2.进行反转操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">temp</span> <span class="operator">=</span> charArray[i];</span><br><span class="line">            charArray[i] = charArray[j];</span><br><span class="line">            charArray[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.返回值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="comment">//分析：整个字符串分为三部分不反转的、反转的、不反转的</span></span><br><span class="line"><span class="comment">//先将前面不反转的部分取出来，将反转的部分取出后进行拼接</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse2</span><span class="params">(String string, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(string != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//第一部分</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> string.substring(<span class="number">0</span>, start);</span><br><span class="line">    <span class="comment">//第二部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end; i &gt;= start; i--) &#123;</span><br><span class="line">        newStr += string.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三部分</span></span><br><span class="line">    newStr += string.substring(end + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//拼接操作</span></span><br><span class="line">    <span class="keyword">return</span> newStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式三,使用StringBuffer或StringBuilder替换String优化</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reverse3</span><span class="params">(String str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(str != <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="comment">//1.新建StringBuffer</span></span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str.length());</span><br><span class="line">    <span class="comment">//2.第一部分</span></span><br><span class="line">    stringBuffer.append(str.substring(<span class="number">0</span>, start));</span><br><span class="line">    <span class="comment">//3.第二部分</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> end; i &gt;= start; i--) &#123;</span><br><span class="line">        stringBuffer.append(str.charAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.第三部分</span></span><br><span class="line">    stringBuffer.append(str.substring(end + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">//5.拼接操作</span></span><br><span class="line">    <span class="keyword">return</span> stringBuffer.toString();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）获取一个字符串在另一个字符串中出现的次数。 比如：获取“ ab”在 “abkkcadkabkebfkabkskab” 中出现的次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(String mainStr, String subStr)</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断主串和部分串的大小</span></span><br><span class="line">    <span class="keyword">if</span> (mainStr.length() &gt;= subStr.length()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//2.在主串中取出子串下标，并将新的下标赋值给主串，统计量加1</span></span><br><span class="line">        <span class="comment">//            while ((index = mainStr.indexOf(subStr) )!= -1)&#123;</span></span><br><span class="line">        <span class="comment">//                count++;</span></span><br><span class="line">        <span class="comment">////从已经找到的子串的下一个开始</span></span><br><span class="line">        <span class="comment">//                mainStr = mainStr.substring(index + subStr.length());</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line">        <span class="comment">//改进，不再新建字符串，只做位置比对</span></span><br><span class="line">        <span class="keyword">while</span> ((index = mainStr.indexOf(subStr, index)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            index += subStr.length();</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）获取两个字符串中最大相同子串。比如： str1 &#x3D; “abcwerthelloyuiodef“;str2 &#x3D; “cvhellobnm” 提示：将短的那个串进行长度依次递减的子串与较长的串比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只存在一个子串的情况</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getMaxSameSubString</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">    <span class="comment">//1.判断两个字串的大小</span></span><br><span class="line">    <span class="keyword">if</span> (str1 != <span class="literal">null</span> &amp;&amp; str2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> (str1.length() &gt;= str2.length()) ? str1 : str2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">minStr</span> <span class="operator">=</span> (str1.length() &lt; str2.length()) ? str1 : str2;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> minStr.length();</span><br><span class="line">        <span class="comment">//2.用小的依次去比对大的子串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">//这层for循环用来确定需要比对的字符次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = len - i; y &lt;= len; x++, y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (maxStr.contains(minStr.substring(x, y))) &#123;</span><br><span class="line">                    <span class="keyword">return</span> minStr.substring(x, y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存在多个相同子串的情况</span></span><br><span class="line"><span class="comment">// 此时先返回String[]，后面可以用集合中的ArrayList替换，较方便</span></span><br><span class="line"><span class="keyword">public</span> String [] getMaxSameSubStrings(String str1, String str2) &#123;</span><br><span class="line">    <span class="comment">//1.先比较出两个子串的大小</span></span><br><span class="line">    <span class="keyword">if</span> (str1 != <span class="literal">null</span> &amp;&amp; str2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">maxStr</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str1 : str2;</span><br><span class="line">        <span class="type">String</span> <span class="variable">minStr</span> <span class="operator">=</span> (str1.length() &gt; str2.length()) ? str2 : str1;</span><br><span class="line">        <span class="comment">//2.用小的去依次匹配大的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> minStr.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = len - i; y &lt;= len; x++,y++ )&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">subString</span> <span class="operator">=</span> minStr.substring(x,y);</span><br><span class="line">                <span class="comment">//3.取出匹配到的子串</span></span><br><span class="line">                <span class="keyword">if</span> (maxStr.contains(subString))&#123;</span><br><span class="line">                    stringBuffer.append(subString+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//System.out.println(stringBuffer);</span></span><br><span class="line">            <span class="keyword">if</span> (stringBuffer.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String [] split = stringBuffer.toString().replaceAll(<span class="string">&quot;,$&quot;</span>,<span class="string">&quot;&quot;</span>).split(<span class="string">&quot;\\,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> split;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5）对字符串中字符进行自然顺序排序。 提示：</p><ol><li>字符串变成字符数组。</li><li>对数组排序，择，冒泡，<code>Arrays.sort()</code>;</li><li>将排序后的数组变成字符串。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">charTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;hello java&quot;</span>;</span><br><span class="line">    <span class="type">char</span>[] charArray = str1.toCharArray();</span><br><span class="line"></span><br><span class="line">    Arrays.sort(charArray);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(charArray);</span><br><span class="line">    System.out.println(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringBuffer和StringBuilder"><a href="#StringBuffer和StringBuilder" class="headerlink" title="StringBuffer和StringBuilder"></a>StringBuffer和StringBuilder</h3><h4 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h4><blockquote><h5 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h5></blockquote><p><code>java.lang.String.Buffer</code> 代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象。 很多方法与 String相同 作为参数传递时，方法内部可以改变值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title class_">Appendable</span>, CharSequence &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>[] value;<span class="comment">//value没有final声明，value可以不断扩容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> count;<span class="comment">//count记录有效字符个数</span></span><br></pre></td></tr></table></figure><p>StringBuffer类不同于 String，其对象必须使用构造器生成。</p><p>有三个构造器:</p><ul><li><code>StringBuffer()</code>：初始容量为16的字符串缓冲区</li><li><code>StringBuffer(int size)</code>：构造指定容量的字符串缓冲区</li><li><code>StringBuffer(String str)</code>：将内容初始化为指定字符串内容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s= <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学习&quot;</span>)；</span><br><span class="line">StringBuffer buffer= <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;我喜欢学习&quot;</span>)；</span><br><span class="line">buffer. append(<span class="string">&quot;数学&quot;</span>);</span><br></pre></td></tr></table></figure><p><img src="/../image/JavaPic/StringBuffer.awebp"></p><blockquote><h5 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h5></blockquote><ol><li><code>StringBuffer append(xxx)</code>：提供了很多的 <code>append()</code> 方法，用于进行字符串拼接</li><li><code>StringBuffer delete(int start,int end)</code>：删除指定位置的内容</li><li><code>StringBuffer replace(int start, int end, String str)</code>：把[start,end)位置替换为str</li><li><code>StringBuffer insert(int offset, xxx)</code>：在指定位置插入xxx</li><li><code>StringBuffer reverse()</code> ：把当前字符序列逆转</li></ol><p>当 append和insert时，如果原来vaue数组长度不够，可扩容。 如上这些方法支持方法链操作。 方法链的原理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>public int indexOf(String str)</code>：返回子串的下标</li><li><code>public String substring(int start,int end)</code>:返回一个从start开始到end索引结束的左闭右开区间的子字符串</li><li><code>public int length()</code>：获取字符串的长度</li><li><code>public char charAt(int n )</code>：返回指定位置的字符</li><li><code>public void setCharAt(int n ,char ch)</code>：设置指定位置的字符</li></ul><p><strong>总结：</strong></p><p>增：<code>append(xxx)</code> ；</p><p>删：<code>delete(int start,int end)</code> ；</p><p>改：<code>setCharAt(int n ,char ch) </code>&#x2F;<code> replace(int start, int end, String str)</code> ；</p><p>查：<code>charAt(int n )</code> ；</p><p>插：<code>insert(int offset, xxx)</code> ；</p><p>长度：<code>length()</code>;</p><p>遍历：<code>for() + charAt() </code>&#x2F;<code> toString()</code>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stringBufferMethodTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    System.out.println(s1);</span><br><span class="line"></span><br><span class="line">    System.out.println(s1.append(<span class="string">&quot;1&quot;</span>));<span class="comment">//abc1</span></span><br><span class="line">    System.out.println(s1.delete(<span class="number">0</span>, <span class="number">1</span>));<span class="comment">//bc1</span></span><br><span class="line">    System.out.println(s1.replace(<span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;hello&quot;</span>));<span class="comment">//helloc1</span></span><br><span class="line">    System.out.println(s1.insert(<span class="number">3</span>, <span class="string">&quot;v&quot;</span>));<span class="comment">//helvloc1</span></span><br><span class="line">    System.out.println(s1.reverse());<span class="comment">//1colvleh</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h4><p>StringBuilder和 StringBuffer非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样，只是StringBuilder类没有加线程锁，执行效率更高。</p><blockquote><h5 id="String、StringBuffer、StringBuilder三者的对比"><a href="#String、StringBuffer、StringBuilder三者的对比" class="headerlink" title="String、StringBuffer、StringBuilder三者的对比"></a>String、StringBuffer、StringBuilder三者的对比</h5></blockquote><ul><li><p>String:不可变的字符序列；底层使用 <code>char[]</code> 存储；占用内存（会不断的创建和回收对象）</p></li><li><p>StringBuffer:可变的字符序列；线程安全的，效率低；线程安全；底层使用char[]存储；</p></li><li><p>StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；线程不安全；底层使用 <code>char[]</code> 存储</p></li></ul><p>注意：作为参数传递的话，方法内部Stng不会改变其值， StringBuffer和 StringBuilder会改变其值。</p><blockquote><h5 id="StringBuffer与StringBuilder的内存解析"><a href="#StringBuffer与StringBuilder的内存解析" class="headerlink" title="StringBuffer与StringBuilder的内存解析"></a>StringBuffer与StringBuilder的内存解析</h5></blockquote><p><strong>以StringBuffer为例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//char[] value = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//char[] value = new char[16];底层创建了一个长度是16的数组。</span></span><br><span class="line">System.out.println(sb1.length());<span class="comment">//</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br></pre></td></tr></table></figure><p><strong>StringBuffer构造器源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuffer</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题1. <code>System.out.println(sb2.length());//3</code></p><p>问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。 默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。</p><p>指导意义：开发中建议大家使用：<code>StringBuffer(int capacity)</code> 或 <code>StringBuilder(int capacity)</code></p><blockquote><h5 id="对比String、StringBuffer、StringBuilder三者的执行效率"><a href="#对比String、StringBuffer、StringBuilder三者的执行效率" class="headerlink" title="对比String、StringBuffer、StringBuilder三者的执行效率"></a>对比String、StringBuffer、StringBuilder三者的执行效率</h5></blockquote><p>从高到低排列：StringBuilder &gt; StringBuffer &gt; String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//初始设置</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//开始对比</span></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        buffer.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuffer的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        builder.append(String.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuilder的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">    startTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">        text = text + i;</span><br><span class="line">    &#125;</span><br><span class="line">    endTime = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;String的执行时间：&quot;</span> + (endTime - startTime));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDK8-0-以前的日期时间API"><a href="#JDK8-0-以前的日期时间API" class="headerlink" title="JDK8.0 以前的日期时间API"></a>JDK8.0 以前的日期时间API</h3><h4 id="java-lang-System类"><a href="#java-lang-System类" class="headerlink" title="java.lang.System类"></a>java.lang.System类</h4><p>System类提供的 <code>public static long currentTimeMillis()</code> 用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。(时间戳) 此方法适于计算时间差。</p><p>计算世界时间的主要标准有：</p><ul><li>UTC（Coordinated Universal Time）</li><li>GMT（Greenwich Mean Time）</li><li>CST（Central Standard Time）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取系统当前时间：System类中的currentTimeMillis()</span></span><br><span class="line"><span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。</span></span><br><span class="line"><span class="comment">//称为时间戳</span></span><br><span class="line">System.out.println(time);</span><br></pre></td></tr></table></figure><h4 id="java-util-Data"><a href="#java-util-Data" class="headerlink" title="java.util.Data"></a>java.util.Data</h4><p>表示特定的瞬间，精确到毫秒</p><blockquote><h5 id="构造器-1"><a href="#构造器-1" class="headerlink" title="构造器"></a>构造器</h5></blockquote><p><code>Date()</code>:使用无参的构造器创建对象可以获取本地当前时间</p><p><code>Date(long date)</code></p><blockquote><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5></blockquote><p><code>getTime()</code>：返回自1970年1月1日00：00：00GMT以来此Date对象表示的毫秒数</p><p><code>tostring()</code>：把此Date对象转换为以下形式的 String：</p><ul><li>dow mon dd</li><li>hh: mm:ss zzz yyyy</li></ul><p>其中：doW是一周中的某一天（Sun，Mon，Tue，Wed，Thu，Fri，Sat），zzz是时间标准。 其它很多方法都过时了</p><blockquote><h5 id="java-util-Date类与java-sql-Date类"><a href="#java-util-Date类与java-sql-Date类" class="headerlink" title="java.util.Date类与java.sql.Date类"></a>java.util.Date类与java.sql.Date类</h5></blockquote><ul><li><code>java.util.Date </code>类</li><li><code>java.sql.Date</code> 类</li></ul><p>1.两个构造器的使用</p><ul><li>构造器一：<code>Date()</code>：创建一个对应当前时间的Date对象</li><li>构造器二：创建指定毫秒数的Date对象</li></ul><p>2.两个方法的使用</p><ul><li><code>toString()</code>:显示当前的年、月、日、时、分、秒</li><li><code>getTime()</code>:获取当前Date对象对应的毫秒数。（时间戳）</li></ul><p>3.<code>java.sql.Date</code> 对应着数据库中的日期类型的变量</p><p>如何将 <code>java.util.Date</code> 对象转换为 <code>java.sql.Date</code> 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dateTest</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//构造器一：Date()：创建一个对应当前时间的Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    System.out.println(date1.toString());<span class="comment">//Sun Apr 19 13:35:12 CST 2020</span></span><br><span class="line">    System.out.println(date1.getTime());<span class="comment">//1587274512876</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器二：创建指定毫秒数的Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">15872745176L</span>);</span><br><span class="line">    System.out.println(date2.toString());</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建java.sql.Date对象</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">1587274512876L</span>);</span><br><span class="line">    System.out.println(date3.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//第一种方式，存在问题：java.util.Date cannot be cast to java.sql.Date</span></span><br><span class="line">    <span class="comment">//        java.sql.Date date6 = (java.sql.Date) date4;</span></span><br><span class="line">    <span class="comment">//        System.out.println(date6);</span></span><br><span class="line">    <span class="comment">//第二种方式</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date4.getTime());</span><br><span class="line">    System.out.println(date5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java-text-SimpleDateFormat类"><a href="#java-text-SimpleDateFormat类" class="headerlink" title="java.text.SimpleDateFormat类"></a>java.text.SimpleDateFormat类</h4><p>Date类的AP不易于国际化，大部分被废弃了， <code>java.text.SimpleDateFormat</code> 类是一个不与语言环境有关的方式来格式化和解析日期的具体类。</p><p>它允许进行格式化：日期→文本、解析：文本→日期</p><p><strong>格式化：</strong></p><p><code>SimpleDateFormat()</code>：默认的模式和语言环境创建对象</p><p><code>public SimpleDateFormat(String pattern)</code>：该构造方法可以用参数 pattern指定的格式创建一个对象，该对象调用：</p><p><code>public String format(Datedate)</code>：方法格式化时间对象date</p><p><strong>解析</strong>： <code>public Date parse(String source)</code>：从给定字符串的开始解析文本，以生成个日期</p><blockquote><h5 id="SimpleDateFormat对日期Date类的格式化和解析"><a href="#SimpleDateFormat对日期Date类的格式化和解析" class="headerlink" title="SimpleDateFormat对日期Date类的格式化和解析"></a>SimpleDateFormat对日期Date类的格式化和解析</h5></blockquote><p>两个操作：</p><p>1.1 格式化：日期 —&gt;字符串</p><p>1.2 解析：格式化的逆过程，字符串 —&gt; 日期</p><blockquote><h5 id="SimpleDateFormat-的实例化：new-构造器"><a href="#SimpleDateFormat-的实例化：new-构造器" class="headerlink" title="SimpleDateFormat 的实例化：new + 构造器"></a>SimpleDateFormat 的实例化：new + 构造器</h5></blockquote><p>照指定的方式格式化和解析：调用带参的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyyy.MMMMM.dd GGG hh:mm aaa&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="comment">//实例化Date对象</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    <span class="comment">//实例化SimpleDateFormate对象，并设置显示格式</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:aaa&quot;</span>);</span><br><span class="line">    <span class="comment">//格式化date对象</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(date1);</span><br><span class="line">    System.out.println(format.toString());<span class="comment">//2020-09-19 02:09:下午</span></span><br><span class="line">    <span class="comment">//解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现),</span></span><br><span class="line">    <span class="comment">//否则，抛异常</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> simpleDateFormat.parse(<span class="string">&quot;2020-04-20 14:20:下午&quot;</span>);</span><br><span class="line">    System.out.println(date2.toString());<span class="comment">//Tue Jan 21 02:20:00 CST 2020</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/JavaPic/java.text.SimpleDateFormat.awebp"></p><p><strong>小练习：</strong></p><p>将字符串”2020-09-08”转换为 <code>java.sql.Date</code> 格式的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">brith</span> <span class="operator">=</span> <span class="string">&quot;1997-10-15&quot;</span>;</span><br><span class="line">    <span class="comment">//新建SimpleDateFormat对象并设置时间格式</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpBrith</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-mm-dd&quot;</span>);</span><br><span class="line">    <span class="comment">//将字符串格式的时间格式化为Date类</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">brithday</span> <span class="operator">=</span> simpBrith.parse(brith);</span><br><span class="line">    <span class="comment">//通过Date的getTime方法将Date对象转化为时间戳放到java.sql.date类的构造方法中</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">brithDate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(brithday.getTime());</span><br><span class="line">    System.out.println(brithDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Calender类：日历类、抽象类"><a href="#Calender类：日历类、抽象类" class="headerlink" title="Calender类：日历类、抽象类"></a>Calender类：日历类、抽象类</h4><p>Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能。</p><ul><li>获取 Calenda实例的方法 使用 Calendar.getInstance()方法 调用它的子类 GregorianCalendarl的构造器。</li><li>一个 Calendar的实例是系统时间的抽象表示，通过 get(int field)方法来取得想要的时间信息。 比如YEAR、MONTH、DAY_OF_WEEK、HOUR_OF_DAY、MINUTE、SECOND</li></ul><p>注意： 获取月份时：一月是0，二月是1，以此类推，12月是11 获取星期时：周日是1，周二是2，。。。周六是7</p><blockquote><h5 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h5></blockquote><p>方式一：创建其子类(GregorianCalendar)的对象</p><p>方式二：调用其静态方法 <code>getInstance()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br></pre></td></tr></table></figure><blockquote><h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5></blockquote><p><code>get()</code>:获取日期</p><p><code>set()</code>:设置日期</p><p><code>add()</code>:添加、修改日期</p><p><code>getTime</code>:日历类–&gt;Date</p><p><code>setTime</code>:Date–&gt;日历类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//        System.out.println(calendar.getClass());</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.常用方法</span></span><br><span class="line"><span class="comment">//get()</span></span><br><span class="line"><span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);<span class="comment">//获取本月第几天</span></span><br><span class="line">System.out.println(days);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_YEAR));<span class="comment">//获取本年第几天</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set()</span></span><br><span class="line"><span class="comment">//calendar可变性</span></span><br><span class="line">calendar.set(Calendar.DAY_OF_MONTH,<span class="number">22</span>);<span class="comment">//设置本月第几天</span></span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br><span class="line"></span><br><span class="line"><span class="comment">//add()</span></span><br><span class="line">calendar.add(Calendar.DAY_OF_MONTH,-<span class="number">3</span>);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br><span class="line"></span><br><span class="line"><span class="comment">//getTime():日历类---&gt; Date</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">System.out.println(date);</span><br><span class="line"></span><br><span class="line"><span class="comment">//setTime():Date ---&gt; 日历类</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">calendar.setTime(date1);</span><br><span class="line">days = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(days);</span><br></pre></td></tr></table></figure><h3 id="JDK8-0-中心的日期时间类"><a href="#JDK8-0-中心的日期时间类" class="headerlink" title="JDK8.0 中心的日期时间类"></a>JDK8.0 中心的日期时间类</h3><h4 id="日期时间API的迭代"><a href="#日期时间API的迭代" class="headerlink" title="日期时间API的迭代"></a>日期时间API的迭代</h4><p>第一代：jdk 1.0 Date类</p><p>第二代：jdk 1.1 Calendar类，一定程度上替换Date类</p><p>第三代：jdk 1.8 提出了新的一套API</p><h4 id="前两代的问题"><a href="#前两代的问题" class="headerlink" title="前两代的问题"></a>前两代的问题</h4><p>可变性：像日期和时间这样的类应该是不可变的。</p><p>偏移性：Date中的年份是从1900开始的，而月份都从0开始。</p><p>格式化：格式化只对Date用，Calendar则不行。 此外，它们也不是线程安全的；不能处理闰秒等。</p><p>Java 8.0中新引入的java.time API:</p><p>Java 8.0吸收了Joda-Time的精华，以一个新的开始为Java创建优秀的APl。新的java.time中包含了所有关于本地日期(LocalDate)、本地时间(Localtime)、本地日期时间(LocalDate time)、时区(ZonedDate time)和持续时间(Duration)的类。历史悠久的Date类新增了tolnstant()方法用于把Date转换成新的表示形式。这些新增的本地化时间日期API大大简化了日期时间和本地化的管理。</p><h4 id="Java8-0-中新的日期时间API涉及的包"><a href="#Java8-0-中新的日期时间API涉及的包" class="headerlink" title="Java8.0 中新的日期时间API涉及的包"></a>Java8.0 中新的日期时间API涉及的包</h4><p>![](..&#x2F;image&#x2F;JavaPic&#x2F;Java8.0 中新的日期时间API涉及的包.awebp)</p><h4 id="本地日期、本地时间、本地日期时间的使用"><a href="#本地日期、本地时间、本地日期时间的使用" class="headerlink" title="本地日期、本地时间、本地日期时间的使用"></a>本地日期、本地时间、本地日期时间的使用</h4><p>LocalDate &#x2F; LocalTime &#x2F; LocalDateTime</p><blockquote><h5 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h5></blockquote><p>① 分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息。</p><p>② LocalDateTime相较于LocalDate、LocalTime，使用频率要高</p><p>③ 类似于Calendar</p><blockquote><h5 id="常用方法：-1"><a href="#常用方法：-1" class="headerlink" title="常用方法："></a>常用方法：</h5></blockquote><p><img src="/../image/JavaPic/%E6%9C%AC%E5%9C%B0%E6%97%A5%E6%9C%9F%E3%80%81%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%E3%80%81%E6%9C%AC%E5%9C%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取当前的日期、时间、日期时间</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"></span><br><span class="line">    System.out.println(localDate);<span class="comment">//2020-04-21</span></span><br><span class="line">    System.out.println(localTime);<span class="comment">//18:52:54.929</span></span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:52:54.929</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//of():设置指定的年、月、日、时、分、秒。没有偏移量</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">12</span>);</span><br><span class="line">    System.out.println(localDateTime1);<span class="comment">//2020-10-06T12:13:12</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//getXxx()：获取相关的属性</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfMonth());<span class="comment">//21</span></span><br><span class="line">    System.out.println(localDateTime.getDayOfWeek());<span class="comment">//TUESDAY</span></span><br><span class="line">    System.out.println(localDateTime.getMonth());<span class="comment">//APRIL</span></span><br><span class="line">    System.out.println(localDateTime.getMonthValue());<span class="comment">//4</span></span><br><span class="line">    System.out.println(localDateTime.getMinute());<span class="comment">//52</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//体现不可变性</span></span><br><span class="line">    <span class="comment">//withXxx():设置相关的属性</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> localDate.withDayOfMonth(<span class="number">22</span>);</span><br><span class="line">    System.out.println(localDate);<span class="comment">//2020-04-21</span></span><br><span class="line">    System.out.println(localDate1);<span class="comment">//2020-04-22</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime2</span> <span class="operator">=</span> localDateTime.withHour(<span class="number">4</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime2);<span class="comment">//2020-04-21T04:59:17.484</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不可变性</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime3</span> <span class="operator">=</span> localDateTime.plusMonths(<span class="number">3</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime3);<span class="comment">//2020-07-21T18:59:17.484</span></span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime4</span> <span class="operator">=</span> localDateTime.minusDays(<span class="number">6</span>);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T18:59:17.484</span></span><br><span class="line">    System.out.println(localDateTime4);<span class="comment">//2020-04-15T18:59:17.484</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间点：Instant"><a href="#时间点：Instant" class="headerlink" title="时间点：Instant"></a>时间点：Instant</h4><blockquote><h5 id="说明：-2"><a href="#说明：-2" class="headerlink" title="说明："></a>说明：</h5></blockquote><p>① 时间线上的一个瞬时点。 概念上讲，它只是简单的表示自1970年1月1日0时0分0秒（UTC开始的秒数。）</p><p>② 类似于 <code>java.util.Date</code> 类</p><blockquote><h5 id="常用方法：-2"><a href="#常用方法：-2" class="headerlink" title="常用方法："></a>常用方法：</h5></blockquote><p><img src="/../image/JavaPic/%E6%97%B6%E9%97%B4%E7%82%B9%EF%BC%9AInstant.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取本初子午线对应的标准时间</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">    System.out.println(instant);<span class="comment">//2020-04-21T11:03:21.469Z</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加时间的偏移量</span></span><br><span class="line">    <span class="type">OffsetDateTime</span> <span class="variable">offsetDateTime</span> <span class="operator">=</span> instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    System.out.println(offsetDateTime);<span class="comment">//2020-04-21T19:03:21.469+08:00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//toEpochMilli():获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数  ---&gt; Date类的getTime()</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">milli</span> <span class="operator">=</span> instant.toEpochMilli();</span><br><span class="line">    System.out.println(milli);<span class="comment">//1587467105795</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ofEpochMilli():通过给定的毫秒数，获取Instant实例  --&gt;Date(long millis)</span></span><br><span class="line">    <span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochMilli(<span class="number">1587467105795L</span>);</span><br><span class="line">    System.out.println(instant1);<span class="comment">//2020-04-21T11:05:05.795Z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日期时间格式化类：DateTimeFormatter"><a href="#日期时间格式化类：DateTimeFormatter" class="headerlink" title="日期时间格式化类：DateTimeFormatter"></a>日期时间格式化类：DateTimeFormatter</h4><blockquote><h5 id="说明：-3"><a href="#说明：-3" class="headerlink" title="说明："></a>说明：</h5></blockquote><p>① 格式化或解析日期、时间</p><p>② 类似于 <code>SimpleDateFormat</code></p><blockquote><h5 id="常用方法：-3"><a href="#常用方法：-3" class="headerlink" title="常用方法："></a>常用方法：</h5></blockquote><ul><li><p>实例化方式： 预定义的标准格式。如：<code>ISO\_LOCAL\_DATE\_TIME;</code></p><ul><li><p>ISO_LOCAL_DATE;ISO_LOCAL_TIME 本地化相关的格式：</p><ul><li>如：<code>ofLocalizedDateTime(FormatStyle.LONG) </code></li></ul></li><li><p>自定义的格式：如：<code>ofPattern(“yyyy-MM-dd hh:mm:ss”)</code></p></li></ul></li><li><p>常用方法：</p></li></ul><p><img src="/../image/JavaPic/DateTimeFormatter.awebp"></p><p>特别的：自定义的格式。如：<code>ofPattern(“yyyy-MM-dd hh:mm:ss”)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//        方式一：预定义的标准格式。</span></span><br><span class="line">    <span class="comment">//        如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">    <span class="comment">//格式化:日期--&gt;字符串</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> formatter.format(localDateTime);</span><br><span class="line">    System.out.println(localDateTime);<span class="comment">//2020-04-21T19:13:13.530</span></span><br><span class="line">    System.out.println(str1);<span class="comment">//2020-04-21T19:13:13.53</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析：字符串 --&gt;日期</span></span><br><span class="line">    <span class="type">TemporalAccessor</span> <span class="variable">parse</span> <span class="operator">=</span> formatter.parse(<span class="string">&quot;2000-04-21T19:13:13.53&quot;</span>);</span><br><span class="line">    System.out.println(parse);<span class="comment">//&#123;&#125;,ISO resolved to 2000-04-21T19:13:13.530</span></span><br><span class="line">    <span class="comment">//        方式二：</span></span><br><span class="line">    <span class="comment">//        本地化相关的格式。如：ofLocalizedDateTime()</span></span><br><span class="line">    <span class="comment">//        FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT :适用于LocalDateTime</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> formatter1.format(localDateTime);</span><br><span class="line">    System.out.println(str2);<span class="comment">//2020年4月21日 下午07时16分57秒</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//      本地化相关的格式。如：ofLocalizedDate()</span></span><br><span class="line">    <span class="comment">//      FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT : 适用于LocalDate</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM);</span><br><span class="line">    <span class="comment">//格式化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> formatter2.format(LocalDate.now());</span><br><span class="line">    System.out.println(str3);<span class="comment">//2020-4-21</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//       重点： 方式三：自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss”)</span></span><br><span class="line">    <span class="type">DateTimeFormatter</span> <span class="variable">formatter3</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">Str4</span> <span class="operator">=</span> formatter3.format(LocalDateTime.now());</span><br><span class="line">    System.out.println(Str4);<span class="comment">//2020-04-21 07:24:04</span></span><br><span class="line"></span><br><span class="line">    <span class="type">TemporalAccessor</span> <span class="variable">accessor</span> <span class="operator">=</span> formatter3.parse(<span class="string">&quot;2020-02-03 05:23:06&quot;</span>);</span><br><span class="line">    System.out.println(accessor);<span class="comment">//&#123;SecondOfMinute=6, HourOfAmPm=5, NanoOfSecond=0, MicroOfSecond=0, MinuteOfHour=23, MilliOfSecond=0&#125;,ISO resolved to 2020-02-03</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他API的使用"><a href="#其他API的使用" class="headerlink" title="其他API的使用"></a>其他API的使用</h4><p><img src="/../image/JavaPic/%E5%85%B6%E4%BB%96API%E7%9A%84%E4%BD%BF%E7%94%A8.awebp"></p><blockquote><h5 id="带时区的日期时间："><a href="#带时区的日期时间：" class="headerlink" title="带时区的日期时间："></a>带时区的日期时间：</h5></blockquote><p>ZonedDateTime &#x2F; ZoneId</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ZoneId:类中包含了所的时区信息</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//getAvailableZoneIds():获取所的ZoneId</span></span><br><span class="line">    Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line">    <span class="keyword">for</span>(String s : zoneIds)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取“Asia/Tokyo”时区对应的时间</span></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>));</span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ZonedDateTime:带时区的日期时间</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//now():获取本时区的ZonedDateTime对象</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.now();</span><br><span class="line">    System.out.println(zonedDateTime);</span><br><span class="line">    <span class="comment">//now(ZoneId id):获取指定时区的ZonedDateTime对象</span></span><br><span class="line">    <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime1</span> <span class="operator">=</span> ZonedDateTime.now(ZoneId.of(<span class="string">&quot;Asia/Tokyo&quot;</span>));</span><br><span class="line">    System.out.println(zonedDateTime1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="时间间隔："><a href="#时间间隔：" class="headerlink" title="时间间隔："></a>时间间隔：</h5></blockquote><p>Duration–用于计算两个“时间”间隔，以秒和纳秒为基准</p><p><img src="/../image/JavaPic/%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">    <span class="type">LocalTime</span> <span class="variable">localTime1</span> <span class="operator">=</span> LocalTime.of(<span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line">    <span class="comment">//between():静态方法，返回Duration对象，表示两个时间的间隔</span></span><br><span class="line">    <span class="type">Duration</span> <span class="variable">duration</span> <span class="operator">=</span> Duration.between(localTime1, localTime);</span><br><span class="line">    System.out.println(duration);</span><br><span class="line"></span><br><span class="line">    System.out.println(duration.getSeconds());</span><br><span class="line">    System.out.println(duration.getNano());</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2017</span>, <span class="number">6</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">23</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Duration</span> <span class="variable">duration1</span> <span class="operator">=</span> Duration.between(localDateTime1, localDateTime);</span><br><span class="line">    System.out.println(duration1.toDays());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="日期间隔："><a href="#日期间隔：" class="headerlink" title="日期间隔："></a>日期间隔：</h5></blockquote><p>Period –用于计算两个“日期”间隔，以年、月、日衡量</p><p><img src="/../image/JavaPic/%E6%97%A5%E6%9C%9F%E9%97%B4%E9%9A%94.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2028</span>, <span class="number">3</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Period</span> <span class="variable">period</span> <span class="operator">=</span> Period.between(localDate, localDate1);</span><br><span class="line">    System.out.println(period);</span><br><span class="line"></span><br><span class="line">    System.out.println(period.getYears());</span><br><span class="line">    System.out.println(period.getMonths());</span><br><span class="line">    System.out.println(period.getDays());</span><br><span class="line"></span><br><span class="line">    <span class="type">Period</span> <span class="variable">period1</span> <span class="operator">=</span> period.withYears(<span class="number">2</span>);</span><br><span class="line">    System.out.println(period1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="日期时间校正器：TemporalAdjuster"><a href="#日期时间校正器：TemporalAdjuster" class="headerlink" title="日期时间校正器：TemporalAdjuster"></a>日期时间校正器：TemporalAdjuster</h5></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//获取当前日期的下一个周日是哪天？</span></span><br><span class="line">    <span class="type">TemporalAdjuster</span> <span class="variable">temporalAdjuster</span> <span class="operator">=</span> TemporalAdjusters.next(DayOfWeek.SUNDAY);</span><br><span class="line"></span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now().with(temporalAdjuster);</span><br><span class="line">    System.out.println(localDateTime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取下一个工作日是哪天？</span></span><br><span class="line">    <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> LocalDate.now().with(<span class="keyword">new</span> <span class="title class_">TemporalAdjuster</span>()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Temporal <span class="title function_">adjustInto</span><span class="params">(Temporal temporal)</span> &#123;</span><br><span class="line">            <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> (LocalDate)temporal;</span><br><span class="line">            <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.FRIDAY))&#123;</span><br><span class="line">                <span class="keyword">return</span> date.plusDays(<span class="number">3</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(date.getDayOfWeek().equals(DayOfWeek.SATURDAY))&#123;</span><br><span class="line">                <span class="keyword">return</span> date.plusDays(<span class="number">2</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> date.plusDays(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;下一个工作日是：&quot;</span> + localDate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="新的日期API与原来API的转化问题："><a href="#新的日期API与原来API的转化问题：" class="headerlink" title="新的日期API与原来API的转化问题："></a>新的日期API与原来API的转化问题：</h5></blockquote><p><img src="/../image/JavaPic/%E6%96%B0%E7%9A%84%E6%97%A5%E6%9C%9FAPI%E4%B8%8E%E5%8E%9F%E6%9D%A5API%E7%9A%84%E8%BD%AC%E5%8C%96%E9%97%AE%E9%A2%98.awebp"></p><h3 id="Java比较器"><a href="#Java比较器" class="headerlink" title="Java比较器"></a>Java比较器</h3><h4 id="Java比较器的使用背景"><a href="#Java比较器的使用背景" class="headerlink" title="Java比较器的使用背景"></a>Java比较器的使用背景</h4><ul><li><p>Java中的对象，正常情况下，只能进行比较：<code>==</code> 或 <code>!=</code>。不能使用 <code>&gt;</code> 或 <code>&lt;</code> 的</p></li><li><p>但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。</p></li><li><p>如何实现？使用两个接口中的任何一个：Comparable（自然排序） 或 Comparator（定制排序）</p></li></ul><h4 id="自然排序：使用Comparable"><a href="#自然排序：使用Comparable" class="headerlink" title="自然排序：使用Comparable"></a>自然排序：使用Comparable</h4><blockquote><h5 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h5></blockquote><ul><li><p>像 String 或包装类等实现了Comparable接口，重写了 <code>compareTo(obj)</code> 方法，给出了比较两个对象大小的方式。</p></li><li><p>像 String 或包装类重写 <code>compareTo()</code> 方法以后，进行了从小到大的排列</p></li><li><p>重写 <code>compareTo(obj)</code> 的规则： 如果当前对象this大于形参对象obj，则返回正整数， 如果当前对象this小于形参对象obj，则返回负整数， 如果当前对象this等于形参对象obj，则返回零。</p></li><li><p>对于自定义类来说，如果需要排序，我们可以让自定义类实现Comparable接口，重写  <code>compareTo(obj)</code> 方法。在<code> compareTo(obj)</code> 方法中指明如何排序</p></li><li><p>Comparable的典型实现：(默认都是从小到大排列的) String：按照字符串中字符的Uincode值进行比较 Character：按照字符的 Unicode值来进行比较 数值类型对应的包装类以及 BigInteger、BigDecimal：按照它们对应的数值大小进行比较 Boolean：true对应的包装类实例大于false对应的包装类实例 Date、Time等：后面的日期时间比前面的日期时间大</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span>  <span class="title class_">Comparable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指明商品比较大小的方式:照价格从低到高排序,再照产品名称从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="comment">//        System.out.println(&quot;**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods)o;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">this</span>.price &gt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.price &lt; goods.price)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line">            <span class="comment">//           return Double.compare(this.price,goods.price);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//        return 0;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter、setter、toString()、构造器：省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="定制排序：使用Comparator"><a href="#定制排序：使用Comparator" class="headerlink" title="定制排序：使用Comparator"></a>定制排序：使用Comparator</h4><blockquote><h5 id="说明-2"><a href="#说明-2" class="headerlink" title="说明:"></a>说明:</h5></blockquote><p>背景：</p><p>当元素的类型没实现 <code>java.lang.Comparable</code> 接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序</p><p>重写 <code>compare(Object o1,Object o2)</code> 方法，比较o1和o2的大小：</p><ul><li>如果方法返回正整数，则表示o1大于o2；</li><li>如果返回0，表示相等；</li><li>返回负整数，表示o1小于o2。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">    <span class="comment">//指明商品比较大小的方式:照产品名称从低到高排序,再照价格从高到低排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods)o1;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods)o2;</span><br><span class="line">            <span class="keyword">if</span>(g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                <span class="keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两种排序方式对比"><a href="#两种排序方式对比" class="headerlink" title="两种排序方式对比"></a>两种排序方式对比</h4><ul><li>Comparable接口的方式是一定的，保证Comparable接口实现类的对象在任何位置都可以比较大小。</li><li>Comparator接口属于临时性的比较。</li></ul><h3 id="其他常用类"><a href="#其他常用类" class="headerlink" title="其他常用类"></a>其他常用类</h3><h4 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h4><ul><li><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包。</p></li><li><p>由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。</p></li></ul><p><strong>成员方法：</strong></p><ul><li><p><code>native long currentTimeMillis()：</code></p><p>该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间（格林威治时间）1970年1月1号0时0分0秒所差的毫秒数。</p></li><li><p><code> void exit(int status)</code></p><p>该方法的作用是退出程序。其中 status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等</p></li><li><p><code>void gc()</code></p><p>该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况。</p></li><li><p><code>String getProperty(String key)</code></p><p>该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示：</p></li></ul><p><img src="/../image/JavaPic/%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%B1%9E%E6%80%A7%E5%90%8D%E4%BB%A5%E5%8F%8A%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%9C%E7%94%A8.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">javaVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.version&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;java的version:&quot;</span> + javaVersion);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">javaHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;java.home&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;java的home:&quot;</span> + javaHome);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">osName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;os的name:&quot;</span> + osName);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">osVersion</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;os.version&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;os的version:&quot;</span> + osVersion);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user的name:&quot;</span> + userName);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">userHome</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.home&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user的home:&quot;</span> + userHome);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">userDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user的dir:&quot;</span> + userDir);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h4><p><code>java.lang.Math</code> 提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型。</p><p><img src="/../image/JavaPic/Math%E7%B1%BB.awebp"></p><h4 id="BigInteger类、BigDecimal类"><a href="#BigInteger类、BigDecimal类" class="headerlink" title="BigInteger类、BigDecimal类"></a>BigInteger类、BigDecimal类</h4><blockquote><h5 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h5></blockquote><ul><li><p><code>java.math </code>包的BigInteger可以表示不可变的任意精度的整数。</p></li><li><p>BigInteger提供所有Java的基本整数操作符的对应物，并提供 <code>java.lang.Math</code> 的所有相关方法。另外，BigInteger还提供以下运算：模算术、GCD计算、质数测试、素数生成、位操作以及一些其他操作。</p></li><li><p>构造器： <code>BigInteger(String val)</code>：根据字符串构建 BigInteger对象</p></li></ul><p><img src="/../image/JavaPic/BigInteger.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1243324112234324324325235245346567657653&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    System.out.println(bi);</span><br><span class="line">    <span class="comment">//         System.out.println(bd.divide(bd2));</span></span><br><span class="line">    System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">    System.out.println(bd.divide(bd2, <span class="number">25</span>, BigDecimal.ROUND_HALF_UP));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h5></blockquote><p>要求数字精度比较高，用到 <code>java.math.BigDecimal</code> 类</p><p>BigDecimal类支持不可变的、任意精度的有符号十进制定点数。</p><p><strong>构造器：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public BigDecimal(double val)</span><br><span class="line">public BigDecimal(String val)</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public BigDecimal add(BigDecimal augend)</span><br><span class="line">public BigDecimal subtract(BigDecimal subtrahend)</span><br><span class="line">public BigDecimal multiply(BigDecimal multiplicand)</span><br><span class="line">public BigDecimal divide(BigDecimal divisor， int scale， int rounding Mode)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">bi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;1243324112234324324325235245346567657653&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;12435.351&quot;</span>);</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">bd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11&quot;</span>);</span><br><span class="line">    System.out.println(bi);</span><br><span class="line">    <span class="comment">//         System.out.println(bd.divide(bd2));</span></span><br><span class="line">    System.out.println(bd.divide(bd2, BigDecimal.ROUND_HALF_UP));</span><br><span class="line">    System.out.println(bd.divide(bd2, <span class="number">25</span>, BigDecimal.ROUND_HALF_UP));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java之枚举类和注解"><a href="#Java之枚举类和注解" class="headerlink" title="Java之枚举类和注解"></a>Java之枚举类和注解</h2><h3 id="枚举类的使用"><a href="#枚举类的使用" class="headerlink" title="枚举类的使用"></a>枚举类的使用</h3><h4 id="枚举类的说明"><a href="#枚举类的说明" class="headerlink" title="枚举类的说明"></a>枚举类的说明</h4><ul><li><p>枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</p></li><li><p>当需要定义一组常量时，强烈建议使用枚举类</p></li><li><p>枚举类的实现：</p><ul><li><p>JDK 5.0以前需要自定义</p></li><li><p>JDK 5.0后新增enum关键字用于定义枚举类</p></li></ul></li><li><p>如果枚举类中只一个对象，则可以作为单例模式的实现方式。</p></li><li><p>枚举类的属性：</p><p>枚举类对象的属性不应允许被改动，所以应该使用 private final修饰 枚举类的使用 private final修饰的属性应该在构造器中为其赋值 若枚举类显式的定义了带参数的构造器，则在列出枚举值时也必须对应的传入参数</p></li></ul><h4 id="如何自定义枚举类"><a href="#如何自定义枚举类" class="headerlink" title="如何自定义枚举类"></a>如何自定义枚举类</h4><p>步骤:</p><ol><li>私有化构造器，保证不能在类的外部创建其对象；</li><li>在类的内部创建枚举类的示例。声明为：public static final；</li><li>对象如果有实例变量，应该声明为private final，并在构造器中初始化；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK5-0-新增使用enum定义枚举类"><a href="#JDK5-0-新增使用enum定义枚举类" class="headerlink" title="JDK5.0 新增使用enum定义枚举类"></a>JDK5.0 新增使用enum定义枚举类</h4><blockquote><h5 id="使用说明："><a href="#使用说明：" class="headerlink" title="使用说明："></a>使用说明：</h5></blockquote><ul><li><p>使用enum定义的枚举类默认继承了 <code>java.lang.Enum</code> 类，因此不能再继承其他类</p></li><li><p>枚举类的构造器只能使用private权限修饰符</p></li><li><p>枚举类的所有实例必须在枚举类中显式列出(<code>,</code> 分隔 <code>;</code> 结尾)。列出的实例系统会自动添加<code>public static final</code> 修饰</p></li><li><p>必须在枚举类的第一行声明枚举类对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> &#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season1</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="Enum类的常用方法："><a href="#Enum类的常用方法：" class="headerlink" title="Enum类的常用方法："></a>Enum类的常用方法：</h5></blockquote><ul><li><p><code>values()</code>方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</p></li><li><p><code>valueOf(String str)</code>：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”.如不是，会有运行时异常 &#96;IllegalArgumentException</p></li><li><p><code>toString()</code>：返回当前枚举类对象常量的名称</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season1</span> <span class="variable">summer</span> <span class="operator">=</span> Season1.SUMMER;</span><br><span class="line"><span class="comment">//toString():返回枚举类对象的名称</span></span><br><span class="line">System.out.println(summer.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(Season1.class.getSuperclass());</span></span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line"><span class="comment">//values():返回所的枚举类对象构成的数组</span></span><br><span class="line">Season1[] values = Season1.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">    System.out.println(values[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">Thread.State[] values1 = Thread.State.values();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values1.length; i++) &#123;</span><br><span class="line">    System.out.println(values1[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line"><span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line"><span class="comment">//如果没objName的枚举类对象，则抛异常：IllegalArgumentException</span></span><br><span class="line"><span class="comment">//        Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);</span></span><br><span class="line">System.out.println(winter);</span><br></pre></td></tr></table></figure><blockquote><h5 id="用Enum类定义的枚举类对象分别实现接口："><a href="#用Enum类定义的枚举类对象分别实现接口：" class="headerlink" title="用Enum类定义的枚举类对象分别实现接口："></a>用Enum类定义的枚举类对象分别实现接口：</h5></blockquote><p>使用说明：</p><ol><li>和普通Java类一样，枚举类可以实现一个或多个接口</li><li>若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。</li><li>若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h3><h4 id="注解的理解"><a href="#注解的理解" class="headerlink" title="注解的理解"></a>注解的理解</h4><p>① jdk 5.0 新增的功能</p><p>② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。通过使用 Annotation,程序员可以在不改变原逻辑的情况下, 在源文件中嵌入一些补充信息。</p><p>③ Annotation可以像修饰符一样使用，可以用来修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在Annotation的 <code>name = value</code> 对中。</p><p>④ 在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE&#x2F;Android 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗 代码和XML配置等。</p><p>⑤ 框架 &#x3D; 注解 + 反射机制 + 设计模式</p><h4 id="注解的使用演示"><a href="#注解的使用演示" class="headerlink" title="注解的使用演示"></a>注解的使用演示</h4><p>使用 Annotation时要在其前面增加 <code>@</code> 符号，并把该 Annotation当成个修饰符使用。用于修饰它支持的程序元素</p><blockquote><h5 id="示例一：生成文档相关的注解"><a href="#示例一：生成文档相关的注解" class="headerlink" title="示例一：生成文档相关的注解"></a>示例一：生成文档相关的注解</h5></blockquote><ul><li><p><code>@author</code> 标明开发该类模块的作者，多个作者之间使用，分割 <code>@version</code> 标明该类模块的版本；</p></li><li><p><code>@see</code> 参考转向，也就是相关主题；</p></li><li><p><code>@since</code> 从哪个版本开始增加的；</p></li><li><p><code>@param</code> 对方法中某参数的说明，如果没有参数就不能写 <code> @return</code> 对方法返回值的说明，如果方法的返回值类型是 <code>void</code> 就不能写 <code>@exception</code> 对方法可能抛出的异常进行说明，如果方法没有用 <code>throws</code> 显式抛出的异常就不能写；</p></li><li><p>其中 <code>@param</code> 、 <code>@return</code> 和 <code>@exception</code> 这三个标记都是只用于方法的。</p></li><li><p><code>@param</code> 的格式要求：<code>@param</code> 形参名形参类型形参说明；</p></li><li><p><code>@return</code> 的格式要求：<code>@return</code> 返回值类型返回值说明；</p></li><li><p><code>@exception</code> 的格式要求：<code>@exception</code> 异常类型异常说明；</p></li><li><p><code>@param</code> 和 <code>@exception</code> 可以并列多个；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> bruce</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@project</span>_name JavaSenior</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span>_name com.bruce.java</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2020-04-26 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *程序的主方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 传入命令行参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求圆形面积</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> radius 所求面积的半径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 面积值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">getArea</span><span class="params">(<span class="type">double</span> radius)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * radius * radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="示例二：在编译时进行格式检查-JDK内置的个基本注解"><a href="#示例二：在编译时进行格式检查-JDK内置的个基本注解" class="headerlink" title="示例二：在编译时进行格式检查(JDK内置的个基本注解)"></a>示例二：在编译时进行格式检查(JDK内置的个基本注解)</h5></blockquote><ul><li><code>@Override</code>: 限定重写父类方法, 该注解只能用于方法；</li><li><code>@Deprecated</code>: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的择；</li><li><code>@SuppressWarnings</code>: 抑制编译器警告；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mian</span> <span class="params">(String [] args)</span>&#123;</span><br><span class="line">        <span class="meta">@SuppressWarning(&quot;unused&quot;)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;过时的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;重写的toString方法&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="示例三：跟踪代码依赖性，实现替代配置文件功能"><a href="#示例三：跟踪代码依赖性，实现替代配置文件功能" class="headerlink" title="示例三：跟踪代码依赖性，实现替代配置文件功能"></a>示例三：跟踪代码依赖性，实现替代配置文件功能</h5></blockquote><p>在使用Spring框架时会大量用到注解驱动开发。</p><h4 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h4><p>参照 <code>@SuppressWarnings</code> 定义</p><ol><li>注解声明为：<code>@interface</code></li><li>内部定义成员，通常使用value表示</li><li>可以指定成员的默认值，使用default定义</li><li>如果自定义注解没成员，表明是一个标识作用。</li></ol><p>说明：</p><ul><li>如果注解有成员，在使用注解时，需要指明成员的值。</li><li>自定义注解必须配上注解的信息处理流程(使用反射)才意义。</li><li>自定义注解通过都会指明两个元注解：<code>@Retention</code>、<code>@Target</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>对现有的注解进行解释说明的注解。</p><p>JDK 5.0 提供的4种元注解：</p><ul><li><p><code>@Retention</code>：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为）\RUNTIME只有声明为RUNTIME生命周期的注解，才能通过反射获取。</p></li><li><p><code>@Target</code>:用于指定被修饰的 Annotation 能用于修饰哪些程序元素</p></li></ul><p><img src="/../image/JavaPic/@Target.awebp"></p><ul><li><p><code>@Documented</code>:表示所修饰的注解在被javadoc解析时，保留下来。</p></li><li><p><code>@Inherited</code>:被它修饰的 Annotation 将具继承性。</p></li></ul><h4 id="如何获取注解信息"><a href="#如何获取注解信息" class="headerlink" title="如何获取注解信息"></a>如何获取注解信息</h4><p>通过发射来进行获取、调用。</p><p>前提：要求此注解的元注解Retention中声明的生命周期状态为：RUNTIME.</p><h4 id="JDK8-0中注解的新特性"><a href="#JDK8-0中注解的新特性" class="headerlink" title="JDK8.0中注解的新特性"></a>JDK8.0中注解的新特性</h4><p>可重复注解、类型注解</p><blockquote><h5 id="可重复注解："><a href="#可重复注解：" class="headerlink" title="可重复注解："></a>可重复注解：</h5></blockquote><p>① 在MyAnnotation上声明 <code>@Repeatabl</code>e，成员值为 <code>MyAnnotations.class</code></p><p>② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。</p><blockquote><h5 id="类型注解："><a href="#类型注解：" class="headerlink" title="类型注解："></a>类型注解：</h5></blockquote><p><code>ElementType.TYPE_PARAMETER</code> 表示该注解能写在类型变量的声明语句中（如：泛型声明。）</p><p><code>ElementType.TYPE_USE</code> 表示该注解能写在使用类型的任何语句中。</p><h2 id="Java之集合"><a href="#Java之集合" class="headerlink" title="Java之集合"></a>Java之集合</h2><h3 id="集合与数组"><a href="#集合与数组" class="headerlink" title="集合与数组"></a>集合与数组</h3><h4 id="集合与数组存储数据概述"><a href="#集合与数组存储数据概述" class="headerlink" title="集合与数组存储数据概述"></a>集合与数组存储数据概述</h4><p>集合、数组都是对多个数据进行存储操作的结构，简称Java容器。 说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中)</p><h4 id="数组存储的特点"><a href="#数组存储的特点" class="headerlink" title="数组存储的特点"></a>数组存储的特点</h4><p>一旦初始化以后，其长度就确定了。 数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。</p><p>比如：<code>String[] arr</code>、<code>int[] arr1</code>、<code>Object[] arr2</code></p><h4 id="数组存储的弊端"><a href="#数组存储的弊端" class="headerlink" title="数组存储的弊端"></a>数组存储的弊端</h4><ol><li>一旦初始化以后，其长度就不可修改。</li><li>数组中提供的方法非常限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li><li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</li><li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li></ol><h4 id="集合存储的优点"><a href="#集合存储的优点" class="headerlink" title="集合存储的优点"></a>集合存储的优点</h4><p>解决数组存储数据方面的弊端。</p><h4 id="集合的分类"><a href="#集合的分类" class="headerlink" title="集合的分类"></a>集合的分类</h4><p>Java集合可分为Collection和Map两种体系</p><ul><li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul><li>List：元素有序、可重复的集合</li><li>Set：元素无序、不可重复的集</li></ul></li><li>Map接口：双列数据，保存具有映射关系“key-value对”的集合</li></ul><h4 id="集合的框架结构"><a href="#集合的框架结构" class="headerlink" title="集合的框架结构"></a>集合的框架结构</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">           |----ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</span><br><span class="line">           |----LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</span><br><span class="line">           |----Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</span><br><span class="line">           </span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;数学概念上的“集合”</span><br><span class="line">           |----HashSet：作为Set接口主要实现类;线程不安全;可以存null值</span><br><span class="line">           |----LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">           |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)</span><br><span class="line">     |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</span><br><span class="line">          |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</span><br><span class="line">                    原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</span><br><span class="line">                    对于频繁的遍历操作，此类执行效率高于HashMap。</span><br><span class="line">     |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</span><br><span class="line">                      底层使用红黑树</span><br><span class="line">     |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</span><br><span class="line">          |----Properties:常用来处理配置文件。key和value都是String类型</span><br></pre></td></tr></table></figure><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h3><ul><li><p>Collection接口是List、Set和Queue接口的父接口，该接口里定义的方法既可用于操作Set集合，也可用于操作List和 Queue集合。</p></li><li><p>JDK不提供此接口的任何直接实现，而是提供更具体的子接口（如：Set和List）实现。</p></li><li><p>在JDK 5.0之前，Java集合会丢失容器中所有对象的数据类型，把所有对象都当成 Object类型处理；从JDK 5.0增加了泛型以后，Java集合可以记住容器中对象的数据类型。</p></li></ul><h4 id="单列集合框架结构"><a href="#单列集合框架结构" class="headerlink" title="单列集合框架结构"></a>单列集合框架结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组</span><br><span class="line">           |----ArrayList：作为List接口的主要实现类，线程不安全的，效率高;底层采用Object[] elementData数组存储</span><br><span class="line">           |----LinkedList：对于频繁的插入删除操作，使用此类效率比ArrayList效率高底层采用双向链表存储</span><br><span class="line">           |----Vector：作为List的古老实现类，线程安全的，效率低;底层采用Object[]数组存储</span><br><span class="line">           </span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;数学概念上的“集合”</span><br><span class="line">           |----HashSet：作为Set接口主要实现类;线程不安全;可以存null值</span><br><span class="line">           |----LinkedHashSet：作为HashSet的子类;遍历其内部数据时，可以按照添加顺序遍历;对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">           |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br></pre></td></tr></table></figure><p><img src="/../image/JavaPic/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84.awebp"></p><h4 id="Collection接口常用方法"><a href="#Collection接口常用方法" class="headerlink" title="Collection接口常用方法"></a>Collection接口常用方法</h4><ul><li><p>添加</p><ul><li><p><code>add(Object obj)</code></p></li><li><p><code>addAll(Collection coll)</code></p></li></ul></li><li><p>获取有效元素个数</p><ul><li><code>int size()</code></li></ul></li><li><p>清空集合</p><ul><li><code>void clear()</code></li></ul></li><li><p>是否为空集合</p><ul><li><code>boolean isEmpty()</code></li></ul></li><li><p>是否包含某个元素</p><ul><li><p><code>boolean contains(Object obj)</code>:是通过元素的equals方法来判断是否是同一个对象</p></li><li><p><code>boolean containsAll(Collection c)</code>:也是调用元素的equals方法来比较的。用两个两个集合的元素逐一比较</p></li></ul></li><li><p>删除</p><ul><li><p><code>boolean remove(Object obj)</code>:通过元素的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素</p></li><li><p><code>boolean removeAll(Collection coll)</code>:取当前集合的差集</p></li></ul></li><li><p>取两个集合的交集</p><ul><li><code>boolean retainAll(Collection c)</code>:把交集的结果存在当前的集合中，不影响c</li></ul></li><li><p>集合是否相等</p><ul><li><code>boolean equals(Object obj)</code></li></ul></li><li><p>转换成对象数组</p><ul><li><code>Object [] toArray()</code></li></ul></li><li><p>获取集合对象的哈希值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-   `hashCode()`</span><br></pre></td></tr></table></figure><ul><li>遍历</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-   `iterator()`:返回迭代器对象，用于集合遍历</span><br></pre></td></tr></table></figure><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//1.add(Object e):将元素添加到集合中</span></span><br><span class="line">    collection.add(<span class="string">&quot;ZZ&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    collection.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    collection.add(<span class="number">123</span>);</span><br><span class="line">    collection.add(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="comment">//2.size():获取添加元素的个数</span></span><br><span class="line">    System.out.println(collection.size());<span class="comment">//5</span></span><br><span class="line">    <span class="comment">//3.addAll(Collection coll1):将coll1集合中的元素添加到当前集合中</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">collection1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    collection1.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    collection1.add(<span class="number">213</span>);</span><br><span class="line">    collection.addAll(collection1);</span><br><span class="line">    System.out.println(collection.size());<span class="comment">//9</span></span><br><span class="line">    <span class="comment">//调用collection1中的toString()方法输出</span></span><br><span class="line">    System.out.println(collection);<span class="comment">//[ZZ, AA, BB, 123, Tue Apr 28 09:22:34 CST 2020, 213, 213]</span></span><br><span class="line">    <span class="comment">//4.clear():清空集合元素</span></span><br><span class="line">    collection1.clear();</span><br><span class="line">    System.out.println(collection1.size());<span class="comment">//0</span></span><br><span class="line">    System.out.println(collection1);<span class="comment">//[]</span></span><br><span class="line">    <span class="comment">//5.isEmpty():判断当前集合是否为空</span></span><br><span class="line">    System.out.println(collection1.isEmpty());<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//6.contains(Object obj):判断当前集合中是否包含obj</span></span><br><span class="line">    <span class="comment">//判断时需要调用obj对象所在类的equals()方法</span></span><br><span class="line">    System.out.println(coll.contains(<span class="number">123</span>));<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>)));<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll.contains(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">23</span>)));<span class="comment">//false</span></span><br><span class="line">    <span class="comment">//7.containsAll(Collection coll1):判断形参coll1中的元素是否都存在当前集合中</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">4566</span>);</span><br><span class="line">    System.out.println(coll.containsAll(coll1));<span class="comment">//flase</span></span><br><span class="line">    <span class="comment">//8.remove(Object obj):从当前集合中移除obj元素</span></span><br><span class="line">    coll.remove(<span class="number">123</span>);</span><br><span class="line">    System.out.println(coll);<span class="comment">//[456, Person&#123;name=&#x27;Tom&#x27;, age=23&#125;, Person&#123;name=&#x27;Jarry&#x27;, age=34&#125;, false]</span></span><br><span class="line">    <span class="comment">//9.removeAll(Collection coll1):差集：从当前集合中和coll1中所有的元素</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">456</span>, <span class="literal">false</span>);</span><br><span class="line">    coll.removeAll(coll2);</span><br><span class="line">    System.out.println(coll);<span class="comment">//[Person&#123;name=&#x27;Tom&#x27;, age=23&#125;, Person&#123;name=&#x27;Jarry&#x27;, age=34&#125;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//10.retainAll(Collection coll1):交集：获取当前集合和coll1集合的交集，并返回给当前集合</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll1</span> <span class="operator">=</span> Arrays.asList(<span class="number">123</span>, <span class="number">345</span>, <span class="number">456</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> coll.retainAll(coll1);</span><br><span class="line">    System.out.println(b);<span class="comment">//true</span></span><br><span class="line">    System.out.println(coll);<span class="comment">//[123, 456]</span></span><br><span class="line">    <span class="comment">//11.equals(Object obj):返回true需要当前集合和形参集合的元素相同</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll2.add(<span class="number">123</span>);</span><br><span class="line">    coll2.add(<span class="number">456</span>);</span><br><span class="line">    System.out.println(coll.equals(coll2));<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//12.hashCode():返回当前对象的哈希值</span></span><br><span class="line">    System.out.println(coll.hashCode());<span class="comment">//5230</span></span><br><span class="line">    <span class="comment">//13.集合---&gt;数组:toArray()</span></span><br><span class="line">    Object[] array = coll.toArray();</span><br><span class="line">    <span class="keyword">for</span> (Object obj : array) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//14.数组---&gt;集合:调用Arrays类的静态方法asList()</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; ints = Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">345</span>&#125;);</span><br><span class="line">    System.out.println(ints.size());<span class="comment">//1</span></span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    System.out.println(strings);<span class="comment">//[AA, BB, CC]</span></span><br><span class="line">    <span class="comment">//15.iteratoriterator():返回Iterator接口的实例，用于遍历集合元素。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Collection集合与数组间的转换"><a href="#Collection集合与数组间的转换" class="headerlink" title="Collection集合与数组间的转换"></a>Collection集合与数组间的转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合 ---&gt;数组：toArray()</span></span><br><span class="line">Object[] arr = coll.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line">    System.out.println(arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拓展：数组 ---&gt;集合:调用Arrays类的静态方法asList(T ... t)</span></span><br><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;BB&quot;</span>, <span class="string">&quot;CC&quot;</span>&#125;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr1</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr1.size());<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="type">List</span> <span class="variable">arr2</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">123</span>, <span class="number">456</span>&#125;);</span><br><span class="line">System.out.println(arr2.size());<span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>使用 Collection 集合存储对象，要求对象所属的类满足：</p><p>向 Collection 接口的实现类的对象中添加数据 obj 时，要求 obj 所在类要重写 <code>equals()</code>。</p><h3 id="Iterator接口与foreach循环"><a href="#Iterator接口与foreach循环" class="headerlink" title="Iterator接口与foreach循环"></a>Iterator接口与foreach循环</h3><h4 id="遍历Collection的两种方式"><a href="#遍历Collection的两种方式" class="headerlink" title="遍历Collection的两种方式"></a>遍历Collection的两种方式</h4><p>① 使用迭代器Iterator</p><p>② foreach循环（或增强for循环）</p><h4 id="java-utils包下定义的迭代器接口：iterator"><a href="#java-utils包下定义的迭代器接口：iterator" class="headerlink" title="java.utils包下定义的迭代器接口：iterator"></a>java.utils包下定义的迭代器接口：iterator</h4><blockquote><p>说明：</p></blockquote><p>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素。 GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生。</p><blockquote><p>作用：</p></blockquote><p>遍历集合Collectiton元素</p><blockquote><p>如何获取实例：</p></blockquote><p><code>coll.iterator()</code> 返回一个迭代器实例</p><blockquote><p>遍历的代码实现：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line"><span class="comment">//hasNext():判断是否还下一个元素</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    <span class="comment">//next():①指针下移 ②将下移以后集合位置上的元素返回</span></span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/JavaPic/iterator.awebp"></p><blockquote><h5 id="iterator中remove-方法的使用："><a href="#iterator中remove-方法的使用：" class="headerlink" title="iterator中remove()方法的使用："></a>iterator中remove()方法的使用：</h5></blockquote><ul><li><p>测试Iterator中的 <code>remove()</code></p></li><li><p>如果还未调用 <code>next()</code> 或在上一次调用 <code>next()</code> 方法之后已经调用了 <code>remove()</code> 方法，再调用 remove 都会报 <code>IllegalStateException</code>。</p></li><li><p>内部定义了 <code>remove()</code>,可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用<code>remove()</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="string">&quot;Tom&quot;</span></span><br><span class="line">            );</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除集合中&quot;Tom&quot;</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        <span class="comment">//            iterator.remove();</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;Tom&quot;</span>.equals(obj))&#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">            <span class="comment">//                iterator.remove();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将指针重新放到头部，遍历集合</span></span><br><span class="line">    iterator = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JDK5-0新特性—增强for循环：foreach"><a href="#JDK5-0新特性—增强for循环：foreach" class="headerlink" title="JDK5.0新特性—增强for循环：foreach"></a>JDK5.0新特性—增强for循环：foreach</h4><blockquote><h4 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h4></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">456</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">20</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(集合元素的类型 局部变量 : 集合对象)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(Object obj : coll)&#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：内部仍然调用了迭代器</p><blockquote><h4 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h4></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="comment">//for(数组元素的类型 局部变量 : 数组对象)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i : arr)&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Colleation子接口：List接口"><a href="#Colleation子接口：List接口" class="headerlink" title="Colleation子接口：List接口"></a>Colleation子接口：List接口</h3><h4 id="存储的数据特点"><a href="#存储的数据特点" class="headerlink" title="存储的数据特点"></a>存储的数据特点</h4><p>存储序有序的、可重复的数据。</p><ul><li>鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组</li><li>List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引。</li><li>List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。</li><li>JDK AP中List接口的实现类常用的有：ArrayList、LinkedList和 Vector.</li></ul><h4 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h4><p>List除了从 Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法。</p><ul><li><code>void add(int index, Object ele)</code>:在index位置插入ele元素</li><li><code>boolean addAll(int index, Collection eles)</code>:从index位置开始将eles中的所有元素添加进来</li><li><code>Object get(int index)</code>:获取指定index位置的元素</li><li><code>int indexOf(Object obj)</code>:返回obj在集合中首次出现的位置</li><li><code>int lastIndexOf(Object obj)</code>:返回obj在当前集合中末次出现的位置</li><li><code>Object remove(int index)</code>:移除指定index位置的元素，并返回此元素</li><li><code>Object set(int index, Object ele)</code>:设置指定index位置的元素为ele</li><li><code>List subList(int fromIndex, int toIndex)</code>:返回从fromIndex到toIndex位置的子集合</li></ul><p>总结：</p><ul><li>增：<code>add(Object obj)</code></li><li>删：<code>remove(int index)</code> &#x2F; <code>remove(Object obj)</code></li><li>改：<code>set(int index, Object ele)</code></li><li>查：<code>get(int index)</code></li><li>插：<code>add(int index, Object ele)</code></li><li>长度：<code>size()</code></li><li>遍历： ① Iterator迭代器方式 ② foreach（增强for循环） ③ 普通的循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    <span class="comment">//int indexOf(Object obj):返回obj在集合中首次出现的位置。如果不存在，返回-1.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(<span class="number">4567</span>);</span><br><span class="line">    System.out.println(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置。如果不存在，返回-1.</span></span><br><span class="line">    System.out.println(list.lastIndexOf(<span class="number">456</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object remove(int index):移除指定index位置的元素，并返回此元素</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object set(int index, Object ele):设置指定index位置的元素为ele</span></span><br><span class="line">    list.set(<span class="number">1</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的左闭右开区间的子集合</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">subList</span> <span class="operator">=</span> list.subList(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    System.out.println(subList);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line">    list.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    list.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//void add(int index, Object ele):在index位置插入ele元素</span></span><br><span class="line">    list.add(<span class="number">1</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素添加进来</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    list.addAll(list1);</span><br><span class="line">    <span class="comment">//        list.add(list1);</span></span><br><span class="line">    System.out.println(list.size());<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object get(int index):获取指定index位置的元素</span></span><br><span class="line">    System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用实现类"><a href="#常用实现类" class="headerlink" title="常用实现类"></a>常用实现类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3. 常用实现类：</span><br><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">  |----List接口：存储序的、可重复的数据。  --&gt;“动态”数组,替换原的数组</span><br><span class="line">      |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</span><br><span class="line">      |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</span><br><span class="line">      |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</span><br></pre></td></tr></table></figure><blockquote><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4></blockquote><ul><li><p>ArrayList是List接口的典型实现类、主要实现类</p></li><li><p>本质上，ArrayList是对象引用的一个”变长”数组</p></li><li><p>Array Listi的JDK 1.8之前与之后的实现区别？</p><ul><li><p>JDK 1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组</p></li><li><p>JDK 1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</p></li></ul></li><li><p><code>Arrays.asList(...)</code>方法返回的List集合，既不是 ArrayList实例，也不是Vector实例。<code>Arrays.asList(...)</code>返回值是一个固定长度的List集合</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Collection</span> <span class="variable">coll</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    coll.add(<span class="number">123</span>);</span><br><span class="line">    coll.add(<span class="number">345</span>);</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    coll.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    coll.add(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//iterator()遍历ArrayList集合</span></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> coll.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="linkedList"><a href="#linkedList" class="headerlink" title="linkedList"></a>linkedList</h4></blockquote><ul><li><p>对与对于频繁的插入和删除元素操作，建议使用LinkedList类，效率更高</p></li><li><p>新增方法：</p><ul><li><p><code>void addFirst(Object obj)</code></p></li><li><p><code>void addLast(Object obj)</code></p></li><li><p><code>Object getFirst()</code></p></li><li><p><code>Object getlast)()</code></p></li><li><p><code>Object removeFirst()</code></p></li><li><p><code>Object removeLast()</code></p></li></ul></li><li><p>Linkedlist：双向链表，内部没有声明数组，而是定义了Node类型的frst和last，用于记录首末元素。同时，定义内部类Node，作为 Linkedlist中保存数据的基本结构。Node除了保存数据，还定义了两个变量：</p><ul><li><p>prev：变量记录前一个元素的位置</p></li><li><p>next：变量记录下一个元素的位置</p></li></ul></li></ul><p><img src="/../image/JavaPic/linkedList.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">LinkedList</span> <span class="variable">linkedList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    linkedList.add(<span class="number">123</span>);</span><br><span class="line">    linkedList.add(<span class="number">345</span>);</span><br><span class="line">    linkedList.add(<span class="number">2342</span>);</span><br><span class="line">    linkedList.add(<span class="string">&quot;DDD&quot;</span>);</span><br><span class="line">    linkedList.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> linkedList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><blockquote><h4 id="ArrayList的源码分析："><a href="#ArrayList的源码分析：" class="headerlink" title="ArrayList的源码分析："></a>ArrayList的源码分析：</h4></blockquote><p>4.1.1 JDK 7.0情况下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//底层创建了长度是10的Object[]数组elementData</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//elementData[0] = new Integer(123);</span></span><br><span class="line">...</span><br><span class="line">list.add(<span class="number">11</span>);<span class="comment">//如果此次的添加导致底层elementData数组容量不够，则扩容。</span></span><br></pre></td></tr></table></figure><ul><li>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</li><li>结论：建议开发中使用带参的构造器：<code>ArrayList list = new ArrayList(int capacity)</code></li></ul><p>4.1.2 JDK 8.0中ArrayList的变化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();<span class="comment">//底层Object[] elementData初始化为&#123;&#125;.并没创建长度为10的数组</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>后续的添加和扩容操作与JDK 7.0 无异。</p><p>4.1.3 小结：</p><p>JDK 7.0中的ArrayList的对象的创建类似于单例的饿汉式，而JDK 8.0中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</p><blockquote><h4 id="LinkedList的源码分析："><a href="#LinkedList的源码分析：" class="headerlink" title="LinkedList的源码分析："></a>LinkedList的源码分析：</h4></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LinkedList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>(); <span class="comment">//内部声明了Node类型的first和last属性，默认值为null</span></span><br><span class="line">list.add(<span class="number">123</span>);<span class="comment">//将123封装到Node中，创建了Node对象。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其中，Node定义为：体现了LinkedList的双向链表的说法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="Vector的源码分析："><a href="#Vector的源码分析：" class="headerlink" title="Vector的源码分析："></a>Vector的源码分析：</h4></blockquote><ul><li><p>Vector是一个古老的集合，JDK 1.0就有了。大多数操作与ArrayList相同，区别在于Vector是线程安全的</p></li><li><p>在各种list中，最好把ArrayList作为缺省选择。当插入、删除频繁时，使用LinkedList；Vector总是比ArrayList慢，所以尽量避免选择使用。</p></li><li><p>JDK 7.0和JDK 8.0中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p></li><li><p>在扩容方面，默认扩容为原来的数组长度的2倍。</p></li></ul><h4 id="存储元素的要求"><a href="#存储元素的要求" class="headerlink" title="存储元素的要求"></a>存储元素的要求</h4><p>添加的对象，所在的类要重写equals()方法</p><h4 id="面试题-5"><a href="#面试题-5" class="headerlink" title="面试题"></a>面试题</h4><p>请问 ArrayList&#x2F;LinkedList&#x2F;Vector的异同？谈谈你的理解？ArrayList底层是什么？扩容机制？ Vector和 ArrayList的最大区别？</p><ul><li><p>ArrayList和 Linkedlist的异同：</p><p>二者都线程不安全，相比线程安全的 Vector，ArrayList执行效率高。 此外，ArrayList是实现了基于动态数组的数据结构，Linkedlist基于链表的数据结构。对于随机访问get和set，ArrayList觉得优于Linkedlist，因为Linkedlist要移动指针。对于新增和删除操作add（特指插入）和 remove，Linkedlist比较占优势，因为 ArrayList要移动数据。</p></li><li><p>ArrayList和 Vector的区别：</p><p>Vector和ArrayList几乎是完全相同的，唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比 ArrayList要大，访问要慢。正常情况下，大多数的Java程序员使用ArrayList而不是Vector，因为同步完全可以由程序员自己来控制。Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。Vector还有一个子类Stack.</p></li></ul><h3 id="Collection子接口：Set接口概述"><a href="#Collection子接口：Set接口概述" class="headerlink" title="Collection子接口：Set接口概述"></a>Collection子接口：Set接口概述</h3><ul><li><p>Set接口是Collection的子接口，set接口没有提供额外的方法</p></li><li><p>Set集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败。（多用于过滤操作，去掉重复数据）</p></li><li><p>Set判断两个对象是否相同不是使用&#x3D;&#x3D;运算符，而是根据equals()方法</p></li></ul><h4 id="存储的数据特点-1"><a href="#存储的数据特点-1" class="headerlink" title="存储的数据特点"></a>存储的数据特点</h4><p>用于存放无序的、不可重复的元素</p><p>以HashSet为例说明：</p><ol><li>无序性：不等于随机性。存储的数据在底层数组中并非照数组索引的顺序添加，而是根据数据的哈希值决定的。</li><li>不可重复性：保证添加的元素照equals()判断时，不能返回true.即：相同的元素只能添加一个。</li></ol><h4 id="元素添加过程：以HashSet为例"><a href="#元素添加过程：以HashSet为例" class="headerlink" title="元素添加过程：以HashSet为例"></a>元素添加过程：以HashSet为例</h4><p>我们向HashSet中添加元素a,首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置），判断</p><p>数组此位置上是否已经有元素：</p><ul><li>如果此位置上没有其他元素，则元素a添加成功。 —&gt;情况1</li><li>如果此位置上有其他元素b(或以链表形式存在的多个元素），则比较元素a与元素b的hash值：<ul><li>如果hash值不相同，则元素a添加成功。—&gt;情况2</li><li>如果hash值相同，进而需要调用元素a所在类的equals()方法：<ul><li>equals()返回true,元素a添加失败</li><li>equals()返回false,则元素a添加成功。—&gt;情况3</li></ul></li></ul></li></ul><p>对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上数据以链表的方式存储。</p><p>JDK 7.0 :元素a放到数组中，指向原来的元素。</p><p>JDK 8.0 :原来的元素在数组中，指向元素a</p><p>总结：七上八下</p><p>HashSet底层：数组+链表的结构。（JDK 7.0以前）</p><p><img src="/../image/JavaPic/HashSet.awebp"></p><h4 id="常用方法-3"><a href="#常用方法-3" class="headerlink" title="常用方法"></a>常用方法</h4><p>Set接口中没额外定义新的方法，使用的都是Collection中声明过的方法</p><blockquote><h4 id="重写hashCode-的基本方法"><a href="#重写hashCode-的基本方法" class="headerlink" title="重写hashCode()的基本方法"></a>重写hashCode()的基本方法</h4></blockquote><ul><li><p>在程序运行时，同一个对象多次调用 <code>hashCode()</code> 方法应该返回相同的值。</p></li><li><p>当两个对象的 <code>equals()</code> 方法比较返回true时，这两个对象的 <code>hashCode()</code> 方法的返回值也应相等。</p></li><li><p>对象中用作 <code>equals()</code> 方法比较的Field，都应该用来计算hashCode值。</p></li></ul><blockquote><h4 id="重写-equals-方法基本原则"><a href="#重写-equals-方法基本原则" class="headerlink" title="重写 equals() 方法基本原则"></a>重写 equals() 方法基本原则</h4></blockquote><ul><li><p>以自定义的 Customer类为例，何时需要重写 <code>equals()</code>？</p></li><li><p>当一个类有自己特有的“逻辑相等”概念，当改写equals()的时候，总是要改写 <code>hash Code()</code>，根据一个类的 equals方法(改写后)，两个截然不同的实例有可能在逻辑上是相等的，但是，根据 <code>Object.hashCode()</code> 方法，它们仅仅是两个对象。</p></li><li><p>因此，违反了<strong>相等的对象必须具有相等的散列码</strong>.</p></li><li><p>结论：复写equals方法的时候一般都需要同时复写 hashCode 方法。通常参与计算 hashCode的对象的属性也应该参与到 <code>equals()</code> 中进行计算。</p></li></ul><blockquote><h4 id="Eclipse-IDEA工具里hashCode-重写"><a href="#Eclipse-IDEA工具里hashCode-重写" class="headerlink" title="Eclipse&#x2F;IDEA工具里hashCode()重写"></a>Eclipse&#x2F;IDEA工具里hashCode()重写</h4></blockquote><p>以Eclipse&#x2F;DEA为例，在自定义类中可以调用工具自动重写 <code>equals()</code> 和 <code>hashCode()</code></p><p>问题：为什么用 Eclipse&#x2F;IDEA复写 hash Code方法，有31这个数字？</p><ul><li>选择系数的时候要选择尽量大的系数。因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。（减少冲突）</li><li>并且31只占用5bits，相乘造成数据溢出的概率较小。</li><li>31可以由i*31&#x3D;&#x3D;(&lt;&lt;5)-1来表示，现在很多虚拟机里面都有做相关优化。（提高算法效率）</li><li>31是一个素数，素数作用就是如果我用一个数字来乘以这个素数，那么最终出来的结果只能被素数本身和被乘数还有1来整除！（减少冲突）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;User equals()....&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (age != user.age) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(user.name) : user.name == <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123; <span class="comment">//return name.hashCode() + age;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>;</span><br><span class="line">    result = <span class="number">31</span> * result + age;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用实现类-1"><a href="#常用实现类-1" class="headerlink" title="常用实现类"></a>常用实现类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span><br><span class="line">          |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</span><br><span class="line">               |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历，对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">          |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br></pre></td></tr></table></figure><blockquote><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4></blockquote><ul><li><p>Hashset是Set接口的典型实现，大多数时候使用Set集合时都使用这个实现类。</p></li><li><p>HashSet按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能。</p></li><li><p>HashSet具有以下特点：</p><ul><li><p>不能保证元素的排列顺序</p></li><li><p>HashSet不是线程安全的</p></li><li><p>集合元素可以是nul</p></li></ul></li><li><p>HashSet集合判断两个元素相等的标准：两个对象通过hashCode()方法比较相等，并且两个对象的equals()方法返回值也相等。</p></li><li><p>对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即：“相等的对象必须具有相等的散列码”</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//HashSet使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">    set.add(<span class="number">454</span>);</span><br><span class="line">    set.add(<span class="number">213</span>);</span><br><span class="line">    set.add(<span class="number">111</span>);</span><br><span class="line">    set.add(<span class="number">123</span>);</span><br><span class="line">    set.add(<span class="number">23</span>);</span><br><span class="line">    set.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">34</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jarry&quot;</span>,<span class="number">74</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4></blockquote><ul><li><p>LinkedhashSet是HashSet的子类</p></li><li><p>LinkedhashSet根据元素的hashCode值来决定元素的存储位置但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的。</p></li><li><p>LinkedhashSet插入性能略低于HashSet，但在迭代访问Set里的全部元素时有很好的性能。</p></li><li><p>LinkedhashSet不允许集合元素重复。</p></li></ul><p><img src="/../image/JavaPic/LinkedHashSet.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//LinkedHashSet使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">    set.add(<span class="number">454</span>);</span><br><span class="line">    set.add(<span class="number">213</span>);</span><br><span class="line">    set.add(<span class="number">111</span>);</span><br><span class="line">    set.add(<span class="number">123</span>);</span><br><span class="line">    set.add(<span class="number">23</span>);</span><br><span class="line">    set.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    set.add(<span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">34</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jarry&quot;</span>,<span class="number">74</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4></blockquote><ul><li><p>Treeset是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态。</p></li><li><p>TreeSet底层使用红黑树结构存储数据</p></li><li><p>新增的方法如下：（了解）</p><ul><li><p><code>Comparator comparator()</code></p></li><li><p><code>Object first()</code></p></li><li><p><code>Object last()</code></p></li><li><p><code>Object lower(object e)</code></p></li><li><p><code>Object higher(object e)</code></p></li><li><p><code>SortedSet subSet(fromElement， toElement)</code></p></li><li><p><code>SortedSet headSet(toElement)</code></p></li><li><p><code>SortedSet tailSet(fromElement)</code></p></li></ul></li><li><p>TreeSet两种排序方法：自然排序和定制排序。默认情况下，TreeSet采用自然排序。</p></li></ul><p><img src="/../image/JavaPic/%E7%BA%A2%E9%BB%91%E6%A0%91.awebp"></p><p>红黑树的特点：有序，查询效率比List快</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Set</span> <span class="variable">treeSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">34</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jarry&quot;</span>,<span class="number">23</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;mars&quot;</span>,<span class="number">38</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jane&quot;</span>,<span class="number">56</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jane&quot;</span>,<span class="number">60</span>));</span><br><span class="line">    treeSet.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bruce&quot;</span>,<span class="number">58</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> treeSet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存储对象所在类的要求"><a href="#存储对象所在类的要求" class="headerlink" title="存储对象所在类的要求"></a>存储对象所在类的要求</h4><blockquote><h4 id="HashSet-LinkedHashSet"><a href="#HashSet-LinkedHashSet" class="headerlink" title="HashSet&#x2F;LinkedHashSet:"></a>HashSet&#x2F;LinkedHashSet:</h4></blockquote><ul><li>要求：向Set(主要指：HashSet、LinkedHashSet)中添加的数据，其所在的类一定要重写hashCode()和equals()</li><li>要求：重写的hashCode()和equals()尽可能保持一致性：相等的对象必须具有相等的散列码</li></ul><p>重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</p><blockquote><h4 id="TreeSet-1"><a href="#TreeSet-1" class="headerlink" title="TreeSet:"></a>TreeSet:</h4></blockquote><ol><li>自然排序中，比较两个对象是否相同的标准为：<code>compareTo()</code> 返回0.不再是 <code>equals()</code></li><li>定制排序中，比较两个对象是否相同的标准为：<code>compare()</code> 返回0.不再是 <code>equals()</code></li></ol><h4 id="TreeSet的使用"><a href="#TreeSet的使用" class="headerlink" title="TreeSet的使用"></a>TreeSet的使用</h4><blockquote><h4 id="使用说明-3"><a href="#使用说明-3" class="headerlink" title="使用说明:"></a>使用说明:</h4></blockquote><ol><li>向TreeSet中添加的数据，要求是相同类的对象。</li><li>两种排序方式：自然排序（实现Comparable接口 和 定制排序（Comparator）</li></ol><blockquote><h4 id="常用的排序方式"><a href="#常用的排序方式" class="headerlink" title="常用的排序方式:"></a>常用的排序方式:</h4></blockquote><p>方式一：自然排序</p><ul><li>自然排序：TreeSet会调用集合元素的 <code>compareTo(object obj)</code> 方法来比较元素之间的大小关系，然后将集合元素按升序（默认情况）排列</li><li>如果试图把一个对象添加到Treeset时，则该对象的类必须实现Comparable接口。<ul><li>实现Comparable的类必须实现 <code>compareTo(Object obj)</code> 方法，两个对象即通过<code>compareTo(Object obj)</code> 方法的返回值来比较大小</li></ul></li><li>Comparable的典型实现:<ul><li>BigDecimal、BigInteger以及所有的数值型对应的包装类：按它们对应的数值大小进行比较</li><li>Character：按字符的unic！ode值来进行比较</li><li>Boolean：true对应的包装类实例大于fase对应的包装类实例</li><li>String：按字符串中字符的unicode值进行比较</li><li>Date、Time：后边的时间、日期比前面的时间、日期大</li></ul></li><li>向TreeSet中添加元素时，只有第一个元素无须比较 <code>compareTo()</code> 方法，后面添加的所有元素都会调用 <code>compareTo()</code> 方法进行比较。</li><li>因为只有相同类的两个实例才会比较大小，所以向 TreeSet中添加的应该是同一个类的对象。 对于TreeSet集合而言，它判断两个对象是否相等的唯一标准是：两个对象通过 <code>compareTo(Object obj)</code> 方法比较返回值。</li><li>当需要把一个对象放入TreeSet中，重写该对象对应的equals()方法时，应保证该方法与 <code>compareTo(Object obj)</code> 方法有一致的结果：如果两个对象通过equals()方法比较返回true，则通过 <code>compareTo(object ob)</code> 方法比较应返回0。否则，让人难以理解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//失败：不能添加不同类的对象</span></span><br><span class="line">    <span class="comment">//        set.add(123);</span></span><br><span class="line">    <span class="comment">//        set.add(456);</span></span><br><span class="line">    <span class="comment">//        set.add(&quot;AA&quot;);</span></span><br><span class="line">    <span class="comment">//        set.add(new User(&quot;Tom&quot;,12));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//举例一：</span></span><br><span class="line">    <span class="comment">//        set.add(34);</span></span><br><span class="line">    <span class="comment">//        set.add(-34);</span></span><br><span class="line">    <span class="comment">//        set.add(43);</span></span><br><span class="line">    <span class="comment">//        set.add(11);</span></span><br><span class="line">    <span class="comment">//        set.add(8);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//举例二：</span></span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">33</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">56</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方式二：定制排序</p><ul><li>TreeSet的自然排序要求元素所属的类实现Comparable接口，如果元素所属的类没有实现 Comparable接口，或不希望按照升序（默认情况）的方式排列元素或希望按照其它属性大小进行排序，则考虑使用定制排序。定制排序，通过 Comparator接口来实现。需要重写 compare(T o1，T o2)方法。</li><li>利用 <code>int compare(T o1，T o2)</code> 方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2。</li><li>要实现定制排序，需要将实现Comparator接口的实例作为形参传递给TreeSet的构造器。</li><li>此时，仍然只能向Treeset中添加类型相同的对象。否则发生 <code>ClassCastException</code> 异常</li><li>使用定制排序判断两个元素相等的标准是：通过 Comparator比较两个元素返回了0</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Comparator</span> <span class="variable">com</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">        <span class="comment">//照年龄从小到大排列</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User)&#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User)o1;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User)o2;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(u1.getAge(),u2.getAge());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不匹配&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>(com);</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>,<span class="number">32</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jim&quot;</span>,<span class="number">2</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mike&quot;</span>,<span class="number">65</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mary&quot;</span>,<span class="number">33</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">33</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jack&quot;</span>,<span class="number">56</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><ul><li><p>Map与Collection并列存在。用于保存具有映射关系的数据:key-value</p></li><li><p>Map中的key和value都可以是任何引用类型的数据</p></li><li><p>Map中的key用set来存放，不允许重复，即同一个Map对象所对应的类，须重写 <code>hashCode()</code> 和 <code>equals()</code> 方法</p></li><li><p>常用 String类作为Map的“键”</p></li><li><p>key和value之间存在单向一对一关系，即通过指定的key总能找到唯一的、确定的value</p></li><li><p>Map接口的常用实现类:HashMap、TreeMap、LinkedHashMap和Properties。其中，HashMap是Map接口使用频率最高的实现类</p></li></ul><h4 id="常见实现类结构"><a href="#常见实现类结构" class="headerlink" title="常见实现类结构"></a>常见实现类结构</h4><p><img src="/../image/JavaPic/%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%BB%93%E6%9E%84.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y = f(x)</span><br><span class="line">     |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储<span class="literal">null</span>的key和value</span><br><span class="line">          |----LinkedHashMap:保证在遍历map元素时，可以照添加的顺序实现遍历。</span><br><span class="line">                    原因：在原的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</span><br><span class="line">                    对于频繁的遍历操作，此类执行效率高于HashMap。</span><br><span class="line">     |----TreeMap:保证照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序</span><br><span class="line">                      底层使用红黑树</span><br><span class="line">     |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储<span class="literal">null</span>的key和value</span><br><span class="line">          |----Properties:常用来处理配置文件。key和value都是String类型</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HashMap的底层： 数组+链表  （JDK <span class="number">7.0</span>及之前)</span><br><span class="line">               数组+链表+红黑树 （JDK <span class="number">8.0</span>以后)</span><br></pre></td></tr></table></figure><blockquote><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4></blockquote><ul><li><p>HashMap是Map接口使用频率最高的实现类。</p></li><li><p>允许使用null键和null值，与 HashSet一样，不保证映射的顺序。</p></li><li><p>所有的key构成的集合是set：无序的、不可重复的。所以，key所在的类要重写equals()和 hashCode()</p></li><li><p>所有的value构成的集合是Collection：无序的、可以重复的。所以，value所在的类要重写:equals()</p></li><li><p>一个key-value构成一个entry</p></li><li><p>所有的entry构成的集合是Set：无序的、不可重复的</p></li><li><p>HashMap判断两个key相等的标准是：两个key通过 <code>equals()</code> 方法返回true，hashCode值也相等。</p></li><li><p>HashMap判断两个value相等的标准是：两个value通过 <code>equals()</code> 方法返回true.</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="literal">null</span>,<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4></blockquote><ul><li><p>LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap.</p></li><li><p>区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node.</p></li><li><p>与Linkedhash Set类似，LinkedHashMap可以维护Map的迭代顺序：迭代顺序与Key-value对的插入顺序一致</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>();</span><br><span class="line">    map.put(<span class="number">123</span>,<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    map.put(<span class="number">345</span>,<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    map.put(<span class="number">12</span>,<span class="string">&quot;CC&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4></blockquote><ul><li><p>TreeMap存储Key-Value对时，需要根据key-value对进行排序。TreeMap可以保证所有的 Key-Value对处于有序状态。</p></li><li><p>TreeSet底层使用红黑树结构存储数据</p></li><li><p>TreeMap的Key的排序:</p><ul><li><p>自然排序： TreeMap的所有的Key必须实现Comparable接口，而且所有的Key应该是同一个类的对象，否则将会抛出ClasssCastEXception()</p></li><li><p>定制排序：创建 TreeMap时，传入一个 Comparator对象，该对象负责对TreeMap中的所有key进行排序。此时不需要Map的Key实现Comparable接口</p></li></ul></li><li><p>TreeMap判断两个key相等的标准：两个key通过 compareTo()方法或者compare()方法返回0.</p></li></ul><blockquote><h4 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h4></blockquote><ul><li><p>Hashtable是个古老的Map实现类，JDK1.0就提供了。不同于 HashMap，Hashtable是线程安全的.</p></li><li><p>Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用</p></li><li><p>与HashMap.不同，Hashtable不允许使用null作为key和value.</p></li><li><p>与HashMap一样，Hashtable也不能保证其中Key-value对的顺序.</p></li><li><p>Hashtable判断两个key相等、两个value相等的标准，与HashMap-致.</p></li></ul><blockquote><h4 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h4></blockquote><ul><li><p>Properties类是Hashtable的子类，该对象用于处理属性文件</p></li><li><p>由于属性文件里的key、value都是字符串类型，所以Properties里的key和value都是字符串类型</p></li><li><p>存取数据时，建议使用 <code>setProperty(String key,String value)</code> 方法和 <code>getProperty(String key)</code> 方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Properties:常用来处理配置文件。key和value都是String类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        pros.load(fis);<span class="comment">//加载流对应的文件</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存储结构的理解"><a href="#存储结构的理解" class="headerlink" title="存储结构的理解"></a>存储结构的理解</h4><ul><li><p>Map中的key:无序的、不可重复的，使用Set存储所的key —&gt; key所在的类要重写equals()和hashCode() （以HashMap为例)</p></li><li><p>Map中的value:无序的、可重复的，使用Collection存储所的value —&gt;value所在的类要重写equals()</p></li><li><p>一个键值对：key-value构成了一个Entry对象。</p></li><li><p>Map中的entry:无序的、不可重复的，使用Set存储所的entry</p></li></ul><p><img src="/../image/JavaPic/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3.awebp"></p><h4 id="常用方法-4"><a href="#常用方法-4" class="headerlink" title="常用方法"></a>常用方法</h4><blockquote><h4 id="添加、删除、修改操作："><a href="#添加、删除、修改操作：" class="headerlink" title="添加、删除、修改操作："></a>添加、删除、修改操作：</h4></blockquote><ul><li><p><code>Object put(Object key,Object value)</code>：将指定key-value添加到(或修改)当前map对象中</p></li><li><p><code>void putAll(Map m)</code>:将m中的所有key-value对存放到当前map中</p></li><li><p><code>Object remove(Object key)</code>：移除指定key的key-value对，并返回value</p></li><li><p><code>void clear()</code>：清空当前map中的所有数据</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="comment">//Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</span></span><br><span class="line">    map.put(<span class="string">&quot;AA&quot;</span>,<span class="number">123</span>);</span><br><span class="line">    map.put(<span class="string">&quot;ZZ&quot;</span>,<span class="number">251</span>);</span><br><span class="line">    map.put(<span class="string">&quot;CC&quot;</span>,<span class="number">110</span>);</span><br><span class="line">    map.put(<span class="string">&quot;RR&quot;</span>,<span class="number">124</span>);</span><br><span class="line">    map.put(<span class="string">&quot;FF&quot;</span>,<span class="number">662</span>);</span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;AA=123, ZZ=251, CC=110, RR=124, FF=662&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中</span></span><br><span class="line">    map.put(<span class="string">&quot;ZZ&quot;</span>,<span class="number">261</span>);</span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;AA=123, ZZ=261, CC=110, RR=124, FF=662&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void putAll(Map m):将m中的所有key-value对存放到当前map中</span></span><br><span class="line">    <span class="type">HashMap</span> <span class="variable">map1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map1.put(<span class="string">&quot;GG&quot;</span>,<span class="number">435</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;DD&quot;</span>,<span class="number">156</span>);</span><br><span class="line">    map.putAll(map1);</span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;AA=123, ZZ=261, CC=110, RR=124, FF=662, GG=435, DD=156&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object remove(Object key)：移除指定key的key-value对，并返回value</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map.remove(<span class="string">&quot;GG&quot;</span>);</span><br><span class="line">    System.out.println(value);<span class="comment">//435</span></span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;AA=123, ZZ=261, CC=110, RR=124, FF=662, DD=156&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void clear()：清空当前map中的所有数据</span></span><br><span class="line">    map.clear();</span><br><span class="line">    System.out.println(map.size());<span class="comment">//0  与map = null操作不同</span></span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="元素查询的操作："><a href="#元素查询的操作：" class="headerlink" title="元素查询的操作："></a>元素查询的操作：</h4></blockquote><ul><li><p>Object get(Object key)&#96;：获取指定key对应的value</p></li><li><p>boolean containsKey(Object key)&#96;：是否包含指定的key</p></li><li><p>boolean containsValue(Object value)&#96;：是否包含指定的value</p></li><li><p><code>int size()</code>：返回map中key-value对的个数</p></li><li><p><code>boolean isEmpty()</code>：判断当前map是否为空</p></li><li><p>boolean equals(Object obj)&#96;：判断当前map和参数对象obj是否相等</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="string">&quot;AA&quot;</span>, <span class="number">123</span>);</span><br><span class="line">    map.put(<span class="string">&quot;ZZ&quot;</span>, <span class="number">251</span>);</span><br><span class="line">    map.put(<span class="string">&quot;CC&quot;</span>, <span class="number">110</span>);</span><br><span class="line">    map.put(<span class="string">&quot;RR&quot;</span>, <span class="number">124</span>);</span><br><span class="line">    map.put(<span class="string">&quot;FF&quot;</span>, <span class="number">662</span>);</span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;AA=123, ZZ=251, CC=110, RR=124, FF=662&#125;</span></span><br><span class="line">    <span class="comment">//Object get(Object key)：获取指定key对应的value</span></span><br><span class="line">    System.out.println(map.get(<span class="string">&quot;AA&quot;</span>));<span class="comment">//123</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean containsKey(Object key)：是否包含指定的key</span></span><br><span class="line">    System.out.println(map.containsKey(<span class="string">&quot;ZZ&quot;</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean containsValue(Object value)：是否包含指定的value</span></span><br><span class="line">    System.out.println(map.containsValue(<span class="number">123</span>));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int size()：返回map中key-value对的个数</span></span><br><span class="line">    System.out.println(map.size());<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean isEmpty()：判断当前map是否为空</span></span><br><span class="line">    System.out.println(map.isEmpty());<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean equals(Object obj)：判断当前map和参数对象obj是否相等</span></span><br><span class="line">    <span class="type">Map</span> <span class="variable">map1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map1.put(<span class="string">&quot;AA&quot;</span>, <span class="number">123</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;ZZ&quot;</span>, <span class="number">251</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;CC&quot;</span>, <span class="number">110</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;RR&quot;</span>, <span class="number">124</span>);</span><br><span class="line">    map1.put(<span class="string">&quot;FF&quot;</span>, <span class="number">662</span>);</span><br><span class="line">    System.out.println(map.equals(map1));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="元视图操作的方法："><a href="#元视图操作的方法：" class="headerlink" title="元视图操作的方法："></a>元视图操作的方法：</h4></blockquote><ul><li><code>Set keySet()</code>：返回所有key构成的Set集合</li><li><code>Collection values()</code>：返回所有value构成的Collection集合</li><li><code>Set entrySet()</code>：返回所有key-value对构成的Set集合</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    map.put(<span class="string">&quot;AA&quot;</span>, <span class="number">123</span>);</span><br><span class="line">    map.put(<span class="string">&quot;ZZ&quot;</span>, <span class="number">251</span>);</span><br><span class="line">    map.put(<span class="string">&quot;CC&quot;</span>, <span class="number">110</span>);</span><br><span class="line">    map.put(<span class="string">&quot;RR&quot;</span>, <span class="number">124</span>);</span><br><span class="line">    map.put(<span class="string">&quot;FF&quot;</span>, <span class="number">662</span>);</span><br><span class="line">    System.out.println(map);<span class="comment">//&#123;AA=123, ZZ=251, CC=110, RR=124, FF=662&#125;</span></span><br><span class="line">    <span class="comment">//遍历所有的key集:Set keySet()：返回所有key构成的Set集合</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">set</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历所有的value集：Collection values()：返回所有value构成的Collection集合</span></span><br><span class="line">    <span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line">    <span class="keyword">for</span> (Object obj :</span><br><span class="line">         values) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;---------------&quot;</span>);</span><br><span class="line">    <span class="comment">//Set entrySet()：返回所有key-value对构成的Set集合</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">    <span class="comment">//方式一：</span></span><br><span class="line">    <span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator1.next();</span><br><span class="line">        <span class="comment">//entrySet集合中的元素都是entry</span></span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;--&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：</span></span><br><span class="line">    <span class="type">Set</span> <span class="variable">keySet</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> keySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator2.next();</span><br><span class="line">        <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        System.out.println(key + <span class="string">&quot;==&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：常用方法：</p><ul><li>添加：<code>put(Object key,Object value)</code></li><li>删除：<code>remove(Object key)</code></li><li>修改：<code>put(Object key,Object value)</code></li><li>查询：<code>get(Object key)</code></li><li>长度：<code>size()</code></li><li>遍历：<code>keySet()</code> &#x2F; <code>values()</code> &#x2F; <code>entrySet()</code></li></ul><h4 id="内存结构说明"><a href="#内存结构说明" class="headerlink" title="内存结构说明"></a>内存结构说明</h4><blockquote><h4 id="HashMap在JDK-7-0中实现原理："><a href="#HashMap在JDK-7-0中实现原理：" class="headerlink" title="HashMap在JDK 7.0中实现原理："></a>HashMap在JDK 7.0中实现原理：</h4></blockquote><p>1 HashMap的存储结构：</p><p>JDK 7.0及以前的版本：HashMap是数组+链表结构（地址链表法）</p><p>JDK 8.0版本以后：HashMap是数组+链表+红黑树实现</p><p>![](..&#x2F;image&#x2F;JavaPic&#x2F;HashMap在JDK 7.0中实现原理.awebp)</p><p>2 对象创建和添加过程：</p><p><code>HashMap map = new HashMap()</code>:</p><p>在实例化以后，底层创建了长度是16的一维数组 <code>Entry[] table</code>。</p><p><code>map.put(key1,value1)</code>:</p><ul><li>首先，调用key1所在类的 <code>hashCode()</code> 计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</li><li>如果此位置上的数据为空，此时的key1-value1添加成功。 —-情况1</li><li>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：<ul><li>如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。—-情况2</li><li>如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：<ul><li>如果 <code>equals()</code> 返回false:此时key1-value1添加成功。—-情况3</li><li>如果 <code>equals()</code> 返回true:使用value1替换value2。</li></ul></li></ul></li></ul><p>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p><p>3 HashMap的扩容</p><p>当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对 HashMap的数组进行扩容，而在HashMap数组扩容之后，原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是 resize。</p><p>4 HashMap扩容时机</p><p>当HashMap中的元素个数超过数组大小（数组总大小 length，不是数组中个数）* loadFactor时，就会进行数组扩容，loadFactor的默认值(<code>DEFAULT_LOAD_ FACTOR</code>)为0.75，这是一个折中的取值。也就是说，默认情况下，数组大小(<code>DEFAULT INITIAL CAPACITY</code>)为16，那么当 HashMap中元素个数超过16 * 0.75&#x3D;12（这个值就是代码中的 threshold值，也叫做临界值）的时候，就把数组的大小扩展为2 * 16&#x3D;32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知 HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。</p><blockquote><h4 id="HashMap在JDK-8-0底层实现原理："><a href="#HashMap在JDK-8-0底层实现原理：" class="headerlink" title="HashMap在JDK 8.0底层实现原理："></a>HashMap在JDK 8.0底层实现原理：</h4></blockquote><p>1 HashMap的存储结构：</p><p>HashMap的内部存储结构其实是数组+链表+红黑树的组合。</p><p>![](..&#x2F;image&#x2F;JavaPic&#x2F;HashMap在JDK 8.0底层实现原理.awebp)</p><p>2 HashMap添加元素的过程：</p><p>当实例化一个HashMap时，会初始化 initialCapacity和loadFactor，在put第一对映射关系时，系统会创建一个长度为 initialCapacity的Node数组，这个长度在哈希表中被称为容量（Capacity），在这个数组中可以存放元素的位置我们称之为“桶”（ bucket），每个bucket都有自己的索引，系统可以根据索引快速的查找bucket中的元素。</p><p>每个 bucket中存储一个元素，即一个Node对象，但每一个Noe对象可以带个引用变量next，用于指向下一个元素，因此，在一个桶中，就有可能生成一个Node链。也可能是一个一个 TreeNode对象，每一个Tree node对象可以有两个叶子结点left和right，因此，在一个桶中，就有可能生成一个TreeNode树。而新添加的元素作为链表的last，或树的叶子结点。</p><p>3 HashMap的扩容机制:</p><ul><li>当HashMapl中的其中一个链的对象个数没有达到8个和JDK 7.0以前的扩容方式一样。</li><li>当HashMapl中的其中一个链的对象个数如果达到了8个，此时如果 capacity没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链会变成树，结点类型由Node变成 Tree Node类型。当然，如果当映射关系被移除后，下次resize方法时判断树的结点个数低于6个，也会把树再转为链表。</li></ul><p>4 JDK 8.0与JDK 7.0中HashMap底层的变化：</p><ol><li><code>new HashMap()</code>:底层没有创建一个长度为16的数组</li><li>JDK 8.0底层的数组是：<code>Node[]</code>,而非 <code>Entry[]</code></li><li>首次调用put()方法时，底层创建长度为16的数组</li><li>JDK 7.0底层结构只有：数组+链表。JDK 8.0中底层结构：数组+链表+红黑树。<ul><li>形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</li><li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</li></ul></li></ol><blockquote><h4 id="HashMap底层典型属性的属性的说明："><a href="#HashMap底层典型属性的属性的说明：" class="headerlink" title="HashMap底层典型属性的属性的说明："></a>HashMap底层典型属性的属性的说明：</h4></blockquote><ul><li><p><code>DEFAULT_INITIAL_CAPACITY</code> : HashMap的默认容量，16</p></li><li><p><code>DEFAULT_LOAD_FACTOR</code>：HashMap的默认加载因子：0.75</p></li><li><p><code>threshold</code>：扩容的临界值，&#x3D; 容量*填充因子：16 * 0.75 &#x3D;&gt; 12</p></li><li><p><code>TREEIFY_THRESHOLD</code>：Bucket中链表长度大于该默认值，转化为红黑树:JDK 8.0引入</p></li><li><p><code>MIN_TREEIFY_CAPACITY</code>：桶中的Node被树化时最小的hash表容量:64</p></li></ul><blockquote><h4 id="LinkedHashMap的底层实现原理"><a href="#LinkedHashMap的底层实现原理" class="headerlink" title="LinkedHashMap的底层实现原理"></a>LinkedHashMap的底层实现原理</h4></blockquote><ul><li>LinkedHashMap底层使用的结构与HashMap相同，因为LinkedHashMap继承于HashMap.</li><li>区别就在于：LinkedHashMap内部提供了Entry，替换HashMap中的Node.</li><li>与Linkedhash Set类似，LinkedHashMap可以维护Map的迭代顺序：迭代顺序与Key-value对的插入顺序一致</li></ul><p>HashMap中内部类Node源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt;&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedHashM中内部类Entry源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;<span class="comment">//能够记录添加的元素的先后顺序</span></span><br><span class="line">    Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TreeMap的使用"><a href="#TreeMap的使用" class="headerlink" title="TreeMap的使用"></a>TreeMap的使用</h4><p>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象 要照key进行排序：自然排序 、定制排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自然排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>();</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bruce&quot;</span>, <span class="number">56</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Davie&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    map.put(u1, <span class="number">98</span>);</span><br><span class="line">    map.put(u2, <span class="number">16</span>);</span><br><span class="line">    map.put(u3, <span class="number">92</span>);</span><br><span class="line">    map.put(u4, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定制排序：按照年龄大小排</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">TreeMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> User &amp;&amp; o2 <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> (User) o1;</span><br><span class="line">                <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> (User) o2;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(u1.getAge(), u2.getAge());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入数据类型错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jarry&quot;</span>, <span class="number">18</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Bruce&quot;</span>, <span class="number">56</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">u4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Davie&quot;</span>, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">    map.put(u1, <span class="number">98</span>);</span><br><span class="line">    map.put(u2, <span class="number">16</span>);</span><br><span class="line">    map.put(u3, <span class="number">92</span>);</span><br><span class="line">    map.put(u4, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) obj;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Properties读取配置文件"><a href="#使用Properties读取配置文件" class="headerlink" title="使用Properties读取配置文件"></a>使用Properties读取配置文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Properties:常用来处理配置文件。key和value都是String类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        pros.load(fis);<span class="comment">//加载流对应的文件</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name = &quot;</span> + name + <span class="string">&quot;, password = &quot;</span> + password);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="面试题-6"><a href="#面试题-6" class="headerlink" title="面试题"></a>面试题</h4><p>HashMap的底层实现原理？</p><p>HashMap 和 Hashtable的异同？</p><p>CurrentHashMap 与 Hashtable的异同？</p><p>负载因子值的大小，对HashMap的影响？</p><ul><li>负载因子的大小决定了HashMap的数据密度。</li><li>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成査询或插入时的比较次数增多，性能会下降</li><li>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间</li><li>按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数。</li></ul><h3 id="Collection工具类的使用"><a href="#Collection工具类的使用" class="headerlink" title="Collection工具类的使用"></a>Collection工具类的使用</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>Collections是一个操作Set、Lit和Map等集合的工具类</p><p>Collections中提供了一系列静态的方法对集合元素进行排序、査询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</p><h4 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h4><blockquote><h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4></blockquote><ul><li><p><code>reverse(List)</code>：反转 List 中元素的顺序</p></li><li><p><code>shuffle(List)</code>：对 List 集合元素进行随机排序</p></li><li><p><code>sort(List)</code>：根据元素的自然顺序对指定 List 集合元素升序排序</p></li><li><p><code>sort(List，Comparator)</code>：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</p></li><li><p><code>swap(List，int， int)</code>：将指定 list 集合中的 i 处元素和 j 处元素进行交换</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">765</span>);</span><br><span class="line">    list.add(-<span class="number">97</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123, 43, 765, -97, 0]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//reverse(List)：反转 List 中元素的顺序</span></span><br><span class="line">    Collections.reverse(list);</span><br><span class="line">    System.out.println(list);<span class="comment">//[0, -97, 765, 43, 123]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//shuffle(List)：对 List 集合元素进行随机排序</span></span><br><span class="line">    Collections.shuffle(list);</span><br><span class="line">    System.out.println(list);<span class="comment">//[765, -97, 123, 0, 43]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//sort(List)：根据元素的自然顺序对指定 List 集合元素按升序排序</span></span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    System.out.println(list);<span class="comment">//[-97, 0, 43, 123, 765]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//swap(List，int， int)：将指定 list 集合中的 i 处元素和 j 处元素进行交换</span></span><br><span class="line">    Collections.swap(list,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[-97, 765, 43, 123, 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="查找、替换"><a href="#查找、替换" class="headerlink" title="查找、替换"></a>查找、替换</h4></blockquote><ul><li><p><code>Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中的最大元素</p></li><li><p><code>Object max(Collection，Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</p></li><li><p><code>Object min(Collection)</code></p></li><li><p><code>Object min(Collection，Comparator)</code></p></li><li><p><code>int frequency(Collection，Object)</code>：返回指定集合中指定元素的出现次数</p></li><li><p><code>void copy(List dest,List src)</code>：将src中的内容复制到dest中</p></li><li><p><code>boolean replaceAll(List list，Object oldVal，Object newVal)</code>：使用新值替换 List 对象的所旧值</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">765</span>);</span><br><span class="line">    list.add(-<span class="number">97</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123, 43, 765, -97, 0]</span></span><br><span class="line">    <span class="comment">//Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素</span></span><br><span class="line">    <span class="type">Comparable</span> <span class="variable">max</span> <span class="operator">=</span> Collections.max(list);</span><br><span class="line">    System.out.println(max);<span class="comment">//765</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Object min(Collection)</span></span><br><span class="line">    <span class="type">Comparable</span> <span class="variable">min</span> <span class="operator">=</span> Collections.min(list);</span><br><span class="line">    System.out.println(min);<span class="comment">//-97</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//int frequency(Collection，Object)：返回指定集合中指定元素的出现次数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">frequency</span> <span class="operator">=</span> Collections.frequency(list,<span class="number">123</span>);</span><br><span class="line">    System.out.println(frequency);<span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void copy(List dest,List src)：将src中的内容复制到dest中</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">dest</span> <span class="operator">=</span> Arrays.asList(<span class="keyword">new</span> <span class="title class_">Object</span>[list.size()]);</span><br><span class="line">    System.out.println(dest.size());<span class="comment">//7</span></span><br><span class="line">    Collections.copy(dest,list);</span><br><span class="line">    System.out.println(dest);<span class="comment">//[123, 123, 123, 43, 765, -97, 0]</span></span><br><span class="line">    <span class="comment">//boolean replaceAll(List list，Object oldVal，Object newVal)：使用新值替换 List 对象的所有旧值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h4></blockquote><p>Collections 类中提供了多个 <code>synchronizedXxx()</code> 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</p><p><img src="/../image/JavaPic/%E5%90%8C%E6%AD%A5%E6%8E%A7%E5%88%B6.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">123</span>);</span><br><span class="line">    list.add(<span class="number">43</span>);</span><br><span class="line">    list.add(<span class="number">765</span>);</span><br><span class="line">    list.add(-<span class="number">97</span>);</span><br><span class="line">    list.add(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list);<span class="comment">//[123, 43, 765, -97, 0]</span></span><br><span class="line">    <span class="comment">//返回的list1即为线程安全的List</span></span><br><span class="line">    <span class="type">List</span> <span class="variable">list1</span> <span class="operator">=</span> Collections.synchronizedList(list);</span><br><span class="line">    System.out.println(list1);<span class="comment">//[123, 123, 123, 43, 765, -97, 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据结构简述"><a href="#数据结构简述" class="headerlink" title="数据结构简述"></a>数据结构简述</h3><h4 id="数据结构概述"><a href="#数据结构概述" class="headerlink" title="数据结构概述"></a>数据结构概述</h4><p>数据结构（Data Structure是一门和计算机硬件与软件都密切相关的学科，它的研究重点是在计算机的程序设计领域中探讨如何在计算机中组织和存储数据并进行高效率的运用，涉及的内容包含：数据的逻辑关系、数据的存储结构、排序算法（Algorithm）、查找（或搜索）等。</p><h4 id="数据结构与算法的理解"><a href="#数据结构与算法的理解" class="headerlink" title="数据结构与算法的理解"></a>数据结构与算法的理解</h4><p>程序能否快速而高效地完成预定的任务，取决于是否选对了数据结构，而程序是否能清楚而正确地把问题解决，则取决于算法。</p><p>所以大家认为：“Algorithms + Data Structures &#x3D; Programs”（出自：Pascal之父Nicklaus Wirth）</p><p>总结：算法是为了解决实际问题而设计的，数据结构是算法需要处理的问题载体。</p><h4 id="数据结构的研究对象"><a href="#数据结构的研究对象" class="headerlink" title="数据结构的研究对象"></a>数据结构的研究对象</h4><blockquote><h5 id="数据间的逻辑结构"><a href="#数据间的逻辑结构" class="headerlink" title="数据间的逻辑结构"></a>数据间的逻辑结构</h5></blockquote><p>集合结构</p><p><img src="/../image/JavaPic/%E9%9B%86%E5%90%88%E7%BB%93%E6%9E%84.awebp"></p><p>一对一：线性结构</p><p><img src="/../image/JavaPic/%E4%B8%80%E5%AF%B9%E4%B8%80%EF%BC%9A%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.awebp"></p><p>一对多：树形结构</p><p><img src="/../image/JavaPic/%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%9A%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.awebp"></p><p>多对多：图形结构</p><p><img src="/../image/JavaPic/%E5%A4%9A%E5%AF%B9%E5%A4%9A%EF%BC%9A%E5%9B%BE%E5%BD%A2%E7%BB%93%E6%9E%84.awebp"></p><blockquote><h5 id="数据的存储结构："><a href="#数据的存储结构：" class="headerlink" title="数据的存储结构："></a>数据的存储结构：</h5></blockquote><p>线性表（顺序表、链表、栈、队列） 树 图</p><h2 id="Java之泛型"><a href="#Java之泛型" class="headerlink" title="Java之泛型"></a>Java之泛型</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="泛型的概念"><a href="#泛型的概念" class="headerlink" title="泛型的概念"></a>泛型的概念</h4><ul><li><p>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返 回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、 创建对象时确定（即传入实际的类型参数，也称为类型实参）。</p></li><li><p>从JDK 5.0以后，Java引入了“参数化类型(Parameterized type)”的概念，允许我们在创建集合时再指定集合元素的类型，正如:List，这表明该List只能保存字符串类型的对象。</p></li><li><p>JDK 5.0改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。</p></li></ul><h4 id="泛型的引入背景"><a href="#泛型的引入背景" class="headerlink" title="泛型的引入背景"></a>泛型的引入背景</h4><p>集合容器类在设计阶段&#x2F;声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。Collection，List，ArrayList 这个就是类型参数，即泛型。</p><h4 id="引入泛型的目的"><a href="#引入泛型的目的" class="headerlink" title="引入泛型的目的"></a>引入泛型的目的</h4><ol><li>解决元素存储的安全性问题，好比商品、药品标签，不会弄错。</li><li>解决获取数据元素时，需要类型强制转换的问题，好比不用每回拿商品、药品都要辨别。</li></ol><p>Java泛型可以保证如果程序在编译时没有发岀警告，运行时就不会产生 <code>ClassCastException</code> 异常。同时，代码更加简洁、健壮。</p><h3 id="泛型在集合中的应用"><a href="#泛型在集合中的应用" class="headerlink" title="泛型在集合中的应用"></a>泛型在集合中的应用</h3><h4 id="在集合中没有使用泛型的例子"><a href="#在集合中没有使用泛型的例子" class="headerlink" title="在集合中没有使用泛型的例子"></a>在集合中没有使用泛型的例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">//需求：存放学生的成绩</span></span><br><span class="line">    list.add(<span class="number">78</span>);</span><br><span class="line">    list.add(<span class="number">76</span>);</span><br><span class="line">    list.add(<span class="number">89</span>);</span><br><span class="line">    list.add(<span class="number">88</span>);</span><br><span class="line">    <span class="comment">//问题一：类型不安全</span></span><br><span class="line">    <span class="comment">//        list.add(&quot;Tom&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Object score : list)&#123;</span><br><span class="line">        <span class="comment">//问题二：强转时，可能出现ClassCastException</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (Integer) score;</span><br><span class="line"></span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/JavaPic/%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BE%8B%E5%AD%90.awebp"></p><h4 id="在集合中使用泛型的例子-1"><a href="#在集合中使用泛型的例子-1" class="headerlink" title="在集合中使用泛型的例子-1"></a>在集合中使用泛型的例子-1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在集合中使用泛型，以ArrayList为例</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;FFF&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;EEE&quot;</span>);</span><br><span class="line">    list.add(<span class="string">&quot;CCC&quot;</span>);</span><br><span class="line"><span class="comment">//遍历方式一：</span></span><br><span class="line">    Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">    <span class="comment">//便利方式二：</span></span><br><span class="line">    <span class="keyword">for</span> (String str:</span><br><span class="line">         list) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../image/JavaPic/%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BE%8B%E5%AD%90.awebp"></p><h4 id="在集合中使用泛型例子-2"><a href="#在集合中使用泛型例子-2" class="headerlink" title="在集合中使用泛型例子-2"></a>在集合中使用泛型例子-2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//在集合中使用泛型的情况：以HashMap为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//jdk7新特性：类型推断</span></span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">26</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jarry&quot;</span>,<span class="number">30</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Bruce&quot;</span>,<span class="number">28</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Davie&quot;</span>,<span class="number">60</span>);</span><br><span class="line">    <span class="comment">//嵌套循环</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entries.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; entry = iterator.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        System.out.println(key+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在集合中使用泛型总结"><a href="#在集合中使用泛型总结" class="headerlink" title="在集合中使用泛型总结"></a>在集合中使用泛型总结</h4><p>① 集合接口或集合类在JDK 5.0时都修改为带泛型的结构。</p><p>② 在实例化集合类时，可以指明具体的泛型类型</p><p>③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</p><p>  比如：add(E e) —&gt;实例化以后：<code>add(Integer e)</code></p><p>④ 注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</p><p>⑤ 如果实例化时，没有指明泛型的类型。默认类型为 <code>java.lang.Object</code> 类型。</p><h3 id="自定义泛型结构"><a href="#自定义泛型结构" class="headerlink" title="自定义泛型结构"></a>自定义泛型结构</h3><p>泛型类、泛型接口、泛型方法</p><h4 id="泛型的声明"><a href="#泛型的声明" class="headerlink" title="泛型的声明"></a>泛型的声明</h4><ul><li>interface <code>List&lt;T&gt;</code> 和 <code>class GenTest&lt;K,V&gt;</code> 其中，T，K，V，不代表值，而是表示类型。这里使用任意字母都可以。</li><li>常用T表示，是Type的缩写。</li></ul><h4 id="泛型的实例化"><a href="#泛型的实例化" class="headerlink" title="泛型的实例化"></a>泛型的实例化</h4><p>一定要在类名后面指定类型参数的值（类型）。如：</p><p><code>List&lt;String&gt; strList =new ArrayList&lt;String&gt;();</code><br><code>Iterator&lt;Customer&gt; iterator = customers.iterator();</code></p><ul><li>T只能是类，不能用基本数据类型填充。但可以使用包装类填充</li><li>把一个集合中的内容限制为一个特定的数据类型，这就是 generics背后的核心思想</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK 5.0以前</span></span><br><span class="line"><span class="type">Comparable</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(c.comparaTo(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">                   </span><br><span class="line"><span class="comment">//JDK 5.0以后</span></span><br><span class="line">Comparable &lt;Date&gt; c = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.println(c.comparaTo(<span class="string">&quot;red&quot;</span>);             </span><br></pre></td></tr></table></figure><p>总结：使用泛型的主要优点在于能够在编译时而不是在运行时检测错误</p><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul><li><p>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如&lt;E1,E2,E3&gt;</p></li><li><p>泛型类的构造器如下： <code>public GenericClass()&#123;&#125;</code></p><p>而下面是错误的： <code>public GenericClass&lt;E&gt;&#123;&#125;</code></p></li><li><p>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致。</p></li><li><p>泛型不同的引用不能相互赋值。</p><ul><li>尽管在编译时 ArrayList和ArrayList是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中。</li></ul></li><li><p>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。</p><ul><li>建议：泛型要使用一路都用。要不用，一路都不要用。</li></ul></li><li><p>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象。</p></li><li><p>JDK 7.0，泛型的简化操作： <code>ArrayList&lt;Fruit&gt;first= new ArrayList&lt;&gt;();</code>（类型推断）</p></li><li><p>泛型的指定中不能使用基本数据类型，可以使用包装类替换。</p></li><li><p>在类&#x2F;接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型。</p></li><li><p>异常类不能是泛型的。</p></li><li><p>不能使用 <code>new E[]</code>。但是可以：<code>E[] elements= (E[])new Object[capacity];</code></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 参考：ArrayList源码中声明：`Object[] elementData`，而非泛型参数类型数组。</span><br></pre></td></tr></table></figure><ul><li>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型：<ul><li>子类不保留父类的泛型：按需实现</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    -   没有类型---擦除</span><br><span class="line">    -   具体类型</span><br><span class="line">-   子类保留父类的泛型：泛型子类</span><br><span class="line">    -   全部保留</span><br><span class="line">    -   部分保留</span><br><span class="line">-   结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义泛型子类Son</span></span><br><span class="line"><span class="comment"> * 情况一：继承泛型父类后不保留父类的泛型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.没有指明类型  擦除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;<span class="comment">//等价于class Son1 extends Father&lt;Object,Odject&gt;&#123;&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.指定具体类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义泛型子类Son</span></span><br><span class="line"><span class="comment"> * 情况二：继承泛型父类后保留泛型类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//1.全部保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.部分保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer,T2&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义泛型结构-1"><a href="#自定义泛型结构-1" class="headerlink" title="自定义泛型结构"></a>自定义泛型结构</h4><blockquote><h4 id="自定义泛型类"><a href="#自定义泛型类" class="headerlink" title="自定义泛型类"></a>自定义泛型类</h4></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义泛型类Order</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderName;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> orderId;</span><br><span class="line">    <span class="comment">//使用T类型定义变量</span></span><br><span class="line">    <span class="keyword">private</span> T orderT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用T类型定义构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(String orderName, <span class="type">int</span> orderId, T orderT)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderName = orderName;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个不是泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getOrderT</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个不是泛型方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOrderT</span><span class="params">(T orderT)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderT = orderT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这个不是泛型方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Order&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;orderName=&#x27;&quot;</span> + orderName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, orderId=&quot;</span> + orderId +</span><br><span class="line">                <span class="string">&quot;, orderT=&quot;</span> + orderT +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    //静态方法中不能使用类的泛型。</span></span><br><span class="line"><span class="comment">//    public static void show(T orderT)&#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(orderT);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    //try-catch中不能是泛型的。</span></span><br><span class="line"><span class="comment">//    public void show()&#123;</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;catch (T t)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。</span></span><br><span class="line">    <span class="comment">//换句话说，泛型方法所属的类是不是泛型类都没有关系。</span></span><br><span class="line">    <span class="comment">//泛型方法，可以声明为静态的。</span></span><br><span class="line">    <span class="comment">// 原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyFromArryToList</span><span class="params">(E[] arr)</span> &#123;</span><br><span class="line">        ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (E e :</span><br><span class="line">                list) &#123;</span><br><span class="line">            list.add(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义泛型类Order的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型</span></span><br><span class="line">    <span class="comment">//要求：如果大家定义了类是带泛型的，建议在实例化时要指明类的泛型。</span></span><br><span class="line">    <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">    order.setOrderT(<span class="number">123</span>);</span><br><span class="line">    System.out.println(order.getOrderT());</span><br><span class="line"></span><br><span class="line">    order.setOrderT(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    System.out.println(order.getOrderT());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建议：实例化时指明类的泛型</span></span><br><span class="line">    Order&lt;String&gt; order1 = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;(<span class="string">&quot;Tom&quot;</span>, <span class="number">16</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line">    order1.setOrderT(<span class="string">&quot;AA:BBB&quot;</span>);</span><br><span class="line">    System.out.println(order1.getOrderT());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//调用泛型方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    Order&lt;String&gt; order = <span class="keyword">new</span> <span class="title class_">Order</span>&lt;&gt;();</span><br><span class="line">    Integer [] arr = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; list = order.copyFromArryToList(arr);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="自定义泛型接口"><a href="#自定义泛型接口" class="headerlink" title="自定义泛型接口"></a>自定义泛型接口</h4></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义泛型接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DemoInterface</span> &lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">implements</span> <span class="title class_">DemoInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//测试泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Demo</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">    demo.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="自定义泛型方法"><a href="#自定义泛型方法" class="headerlink" title="自定义泛型方法"></a>自定义泛型方法</h4></blockquote><ul><li><p>方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型。</p></li><li><p>泛型方法的格式： <code>[访问权限]&lt;泛型&gt;返回类型 方法名(泛型标识 参数名称])抛出的异常</code></p></li><li><p>泛型方法声明泛型时也可以指定上限</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系。</span></span><br><span class="line"><span class="comment">//换句话说，泛型方法所属的类是不是泛型类都没有关系。</span></span><br><span class="line"><span class="comment">//泛型方法，可以声明为静态的。</span></span><br><span class="line"><span class="comment">// 原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; List&lt;E&gt; <span class="title function_">copyFromArryToList</span><span class="params">(E[] arr)</span> &#123;</span><br><span class="line">    ArrayList&lt;E&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (E e :</span><br><span class="line">         list) &#123;</span><br><span class="line">        list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4></blockquote><ul><li>泛型实际上就是标签，声明时不知道类型，再使用时指明</li><li>定义泛型结构，即：泛型类、接口、方法、构造器时贴上泛型的标签</li><li>用泛型定义类或借口是放到类名或接口名后面，定义泛型方法时在方法名前加上</li></ul><h4 id="泛型的应用场景"><a href="#泛型的应用场景" class="headerlink" title="泛型的应用场景"></a>泛型的应用场景</h4><p><code>DAO.java</code>：定义了操作数据库中的表的通用操作。 ORM思想(数据库中的表和Java中的类对应)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DAO</span>&lt;T&gt; &#123;<span class="comment">//表的共性操作的DAO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一条记录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除一条记录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改一条记录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index,T t)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询一条记录</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询多条记录</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">getForList</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法</span></span><br><span class="line">    <span class="comment">//举例：获取表中一共有多少条记录？获取最大的员工入职时间？</span></span><br><span class="line">    <span class="keyword">public</span> &lt;E&gt; E <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CustomerDAO.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerDAO</span> <span class="keyword">extends</span> <span class="title class_">DAO</span>&lt;Customer&gt;&#123;<span class="comment">//只能操作某一个表的DAO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StudentDAO.java</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentDAO</span> <span class="keyword">extends</span> <span class="title class_">DAO</span>&lt;Student&gt; &#123;<span class="comment">//只能操作某一个表的DAO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型在继承上的体现"><a href="#泛型在继承上的体现" class="headerlink" title="泛型在继承上的体现"></a>泛型在继承上的体现</h3><p>泛型在继承方面的体现：</p><p>虽然类A是类B的父类，但是 <code>G&lt;A&gt;</code> 和 <code>G&lt;B&gt;</code> 二者不具备子父类关系，二者是并列关系。</p><p>补充：类A是类B的父类，<code>A&lt;G&gt;</code> 是 <code>B&lt;G&gt;</code> 的父类</p><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    obj = str;</span><br><span class="line"></span><br><span class="line">    Object[] arr1 = <span class="literal">null</span>;</span><br><span class="line">    String[] arr2 = <span class="literal">null</span>;</span><br><span class="line">    arr1 = arr2;</span><br><span class="line">    <span class="comment">//编译不通过</span></span><br><span class="line">    <span class="comment">//        Date date = new Date();</span></span><br><span class="line">    <span class="comment">//        str = date;</span></span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">//此时的list1和list2的类型不具子父类关系</span></span><br><span class="line">    <span class="comment">//编译不通过</span></span><br><span class="line">    <span class="comment">//        list1 = list2;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        反证法：</span></span><br><span class="line"><span class="comment">        假设list1 = list2;</span></span><br><span class="line"><span class="comment">           list1.add(123);导致混入非String的数据。出错。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    show(list1);</span><br><span class="line">    show1(list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(List&lt;Object&gt; list)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    AbstractList&lt;String&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;String&gt; list3 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list2 = list3;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><h4 id="通配符的使用"><a href="#通配符的使用" class="headerlink" title="通配符的使用"></a>通配符的使用</h4><ul><li><p>使用类型通配符：<code>?</code></p><p>比如：<code>List&lt;?&gt;</code>，<code>Map&lt;?,?&gt;</code></p><p><code>List&lt;?&gt;</code> 是 <code>List&lt;String&gt;</code>、<code>List&lt;Object&gt;</code> 等各种泛型 List 的父类。</p></li><li><p>读取 <code>List&lt;?&gt;</code> 的对象list中的元素时，永远是安全的，因为不管list的真实类型是什么，它包含的都是Object</p></li><li><p>写入list中的元素时，不可以。因为我们不知道c的元素类型，我们不能向其中添加对象。 除了添加null之外。</p></li></ul><p><strong>说明：</strong></p><ul><li><p>将任意元素加入到其中不是类型安全的</p><p><code>Collection&lt;?&gt; c = new ArrayList&lt;String&gt;()</code></p><p><code>c.add(new Object());//编译时错误</code></p><p>因为我们不知道c的元素类型，我们不能向其中添加对象。add 方法有类型参数 E 作为集合的元素类型。我们传给add的任何参数都必须是一个已知类型的子类。因为我们不知道那是什么类型，所以我们无法传任何东西进去。</p></li><li><p>唯一的例外的是 null，它是所有类型的成员。</p></li><li><p>我们可以调用 <code>get()</code> 方法并使用其返回值。返回值是一个未知的类型，但是我们知道，它总是一个Object。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    list = list1;</span><br><span class="line">    list = list2;</span><br><span class="line">    <span class="comment">//编译通过</span></span><br><span class="line">    <span class="comment">//        print(list1);</span></span><br><span class="line">    <span class="comment">//        print(list2);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list3.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    list = list3;</span><br><span class="line">    <span class="comment">//添加(写入)：对于List&lt;?&gt;就不能向其内部添加数据。</span></span><br><span class="line">    <span class="comment">//除了添加null之外。</span></span><br><span class="line">    <span class="comment">//        list.add(&quot;DD&quot;);</span></span><br><span class="line">    <span class="comment">//        list.add(&#x27;?&#x27;);</span></span><br><span class="line"></span><br><span class="line">    list.add(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取(读取)：允许读取数据，读取的数据类型为Object。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;?&gt; list)</span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;?&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意点2：编译错误：不能用在泛型类的声明上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericTypeClass</span>&lt;?&gt;&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象</span></span><br><span class="line">ArrayList&lt;&gt; list2 <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;();</span><br></pre></td></tr></table></figure><h4 id="有限制的通配符"><a href="#有限制的通配符" class="headerlink" title="有限制的通配符"></a>有限制的通配符</h4><ul><li><p><code>&lt;?&gt;</code>：允许所有泛型的引用调用</p></li><li><p>通配符指定上限</p></li></ul><p>​上限 <code>extends</code>：使用时指定的类型必须是继承某个类，或者实现某个接口，即 <code>&lt;=</code></p><ul><li>通配符指定下限</li></ul><p>​下限 <code>super</code>：使用时指定的类型不能小于操作的类，即 <code>&gt;=</code></p><ul><li><p>举例：</p><ul><li><p><code>&lt;?extends Number&gt;（无穷小， Number\]</code></p><p>只允许泛型为Number及Number子类的引用调用</p></li><li><p><code>&lt;?super Number&gt;\[Number，无穷大）</code></p><p>只允许泛型为Number及Number父类的引用调用</p></li><li><p><code>&lt;? extends Comparable&gt;</code></p><p>只允许泛型为实现 Comparable接口的实现类的引用调用</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">    List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">    List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list1 = list4;</span><br><span class="line">    <span class="comment">//        list1 = list5;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//        list2 = list3;</span></span><br><span class="line">    list2 = list4;</span><br><span class="line">    list2 = list5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据：</span></span><br><span class="line">    list1 = list3;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> list1.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//编译不通过</span></span><br><span class="line">    <span class="comment">//Student s = list1.get(0);</span></span><br><span class="line"></span><br><span class="line">    list2 = list4;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list2.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">////编译不通过</span></span><br><span class="line">    <span class="comment">//        Person obj = list2.get(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入数据：</span></span><br><span class="line">    <span class="comment">//编译不通过</span></span><br><span class="line">    <span class="comment">//        list1.add(new Student());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译通过</span></span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java之IO流"><a href="#Java之IO流" class="headerlink" title="Java之IO流"></a>Java之IO流</h2><h3 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a>File类的使用</h3><h4 id="File类的理解"><a href="#File类的理解" class="headerlink" title="File类的理解"></a>File类的理解</h4><ul><li><p>File类的一个对象，代表一个文件或一个文件目录(俗称：文件夹)。</p></li><li><p>File类声明在 <code>java.io</code> 包下：文件和文件路径的抽象表示形式，与平台无关。</p></li><li><p>File类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间、文件大小等方法，并未涉及到写入或读取文件内容的操作。如果需要读取或写入文件内容，必须使用IO流来完成。</p></li><li><p>想要在 Java 程序中表示一个真实存在的文件或目录，那么必须有一个 File 对象，但是 Java程序中的一个 File 对象，可能没有一个真实存在的文件或目录。</p></li><li><p>后续 File 类的对象常会作为参数传递到流的构造器中，指明读取或写入的”终点”。</p></li></ul><h4 id="File的实例化"><a href="#File的实例化" class="headerlink" title="File的实例化"></a>File的实例化</h4><blockquote><h4 id="常用构造器"><a href="#常用构造器" class="headerlink" title="常用构造器"></a>常用构造器</h4></blockquote><ul><li><code>File(String filePath)</code></li><li><code>File(String parentPath,String childPath)</code></li><li><code>File(File parentFile,String childPath)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//构造器1</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\workspace_idea\\JavaSenic\\IO\\hello.txt&quot;</span>);</span><br><span class="line">    System.out.println(file1);</span><br><span class="line">    System.out.println(file2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器2</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\workspace_idea\\JavaSenior&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    System.out.println(file3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器3</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file3, <span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line">    System.out.println(file4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="路径分类"><a href="#路径分类" class="headerlink" title="路径分类"></a>路径分类</h4></blockquote><ul><li>相对路径：相较于某个路径下，指明的路径。</li><li>绝对路径：包含盘符在内的文件或文件目录的路径。</li></ul><p><strong>说明</strong>：</p><ul><li>IDEA中：<ul><li>如果使用JUnit中的单元测试方法测试，相对路径即为当前Module下。</li><li>如果使用main()测试，相对路径即为当前的Project下。</li></ul></li><li>Eclipse中：<ul><li>不管使用单元测试方法还是使用main()测试，相对路径都是当前的Project下。</li></ul></li></ul><blockquote><h4 id="路径分隔符"><a href="#路径分隔符" class="headerlink" title="路径分隔符"></a>路径分隔符</h4></blockquote><ul><li><p>windows和DOS系统默认使用 <code>\</code> 来表示</p></li><li><p>UNIX和URL使用 <code>/</code> 来表示</p></li><li><p>Java程序支持跨平台运行，因此路径分隔符要慎用。</p></li><li><p>为了解决这个隐患，File类提供了一个常量： <code>public static final String separator</code>。根据操作系统，动态的提供分隔符。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//windows和DOS系统</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\io\\test.txt&quot;</span>);</span><br><span class="line"><span class="comment">//UNIX和URL</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:/io/test.txt&quot;</span>);</span><br><span class="line"><span class="comment">//java提供的常量</span></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:&quot;</span>+File.separator+<span class="string">&quot;io&quot;</span>+File.separator+<span class="string">&quot;test.txt&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="File的常用方法"><a href="#File的常用方法" class="headerlink" title="File的常用方法"></a>File的常用方法</h4><blockquote><h4 id="File类的获取功能"><a href="#File类的获取功能" class="headerlink" title="File类的获取功能"></a>File类的获取功能</h4></blockquote><ul><li><p><code>public String getAbsolutePath()</code>：获取绝对路径</p></li><li><p><code>public String getPath()</code>：获取路径</p></li><li><p><code>public String getName()</code> ：获取名称</p></li><li><p><code>public String getParent()</code>：获取上层文件目录路径。若无，返回 &#96;null</p></li><li><p><code>public long length()</code> ：获取文件长度（即：字节数）。不能获取目录的长度。</p></li><li><p><code>public long lastModified()</code> ：获取最后一次的修改时间，毫秒值</p></li></ul><p>如下的两个方法适用于文件目录：</p><ul><li><p><code>public String[] list()</code> ：获取指定目录下的所有文件或者文件目录的名称数组</p></li><li><p><code>public File[] listFiles()</code> ：获取指定目录下的所有文件或者文件目录的File数组</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io\\hi.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(file1.getAbsolutePath());</span><br><span class="line">    System.out.println(file1.getPath());</span><br><span class="line">    System.out.println(file1.getName());</span><br><span class="line">    System.out.println(file1.getParent());</span><br><span class="line">    System.out.println(file1.length());</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>(file1.lastModified()));</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    System.out.println(file2.getAbsolutePath());</span><br><span class="line">    System.out.println(file2.getPath());</span><br><span class="line">    System.out.println(file2.getName());</span><br><span class="line">    System.out.println(file2.getParent());</span><br><span class="line">    System.out.println(file2.length());</span><br><span class="line">    System.out.println(file2.lastModified());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\workspace_idea1\\JavaSenior&quot;</span>);</span><br><span class="line"></span><br><span class="line">    String[] list = file.list();</span><br><span class="line">    <span class="keyword">for</span>(String s : list)&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    File[] files = file.listFiles();</span><br><span class="line">    <span class="keyword">for</span>(File f : files)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="File类的重命名功能"><a href="#File类的重命名功能" class="headerlink" title="File类的重命名功能"></a>File类的重命名功能</h4></blockquote><ul><li><code>public boolean renameTo(File dest)</code>:把文件重命名为指定的文件路径</li><li>注意：<code>file1.renameTo(file2)</code>为例：要想保证返回 <code>true</code> ,需要file1在硬盘中是存在的，且file2不能在硬盘中存在。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\io\\hi.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">renameTo</span> <span class="operator">=</span> file2.renameTo(file1);</span><br><span class="line">    System.out.println(renameTo);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="File类的判断功能"><a href="#File类的判断功能" class="headerlink" title="File类的判断功能"></a>File类的判断功能</h4></blockquote><ul><li><p><code>public boolean isDirectory()</code>：判断是否是文件目录</p></li><li><p><code>public boolean isFile()</code> ：判断是否是文件</p></li><li><p><code>public boolean exists()</code> ：判断是否存在</p></li><li><p><code>public boolean canRead()</code> ：判断是否可读</p></li><li><p><code>public boolean canWrite()</code> ：判断是否可写</p></li><li><p><code>public boolean isHidden()</code> ：判断是否隐藏</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    file1 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(file1.isDirectory());</span><br><span class="line">    System.out.println(file1.isFile());</span><br><span class="line">    System.out.println(file1.exists());</span><br><span class="line">    System.out.println(file1.canRead());</span><br><span class="line">    System.out.println(file1.canWrite());</span><br><span class="line">    System.out.println(file1.isHidden());</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io&quot;</span>);</span><br><span class="line">    file2 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io1&quot;</span>);</span><br><span class="line">    System.out.println(file2.isDirectory());</span><br><span class="line">    System.out.println(file2.isFile());</span><br><span class="line">    System.out.println(file2.exists());</span><br><span class="line">    System.out.println(file2.canRead());</span><br><span class="line">    System.out.println(file2.canWrite());</span><br><span class="line">    System.out.println(file2.isHidden());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="Flie类的创建功能"><a href="#Flie类的创建功能" class="headerlink" title="Flie类的创建功能"></a>Flie类的创建功能</h4></blockquote><ul><li><p>创建硬盘中对应的文件或文件目录</p></li><li><p><code>public boolean createNewFile()</code> ：创建文件。若文件存在，则不创建，返回false</p></li><li><p><code>public boolean mkdir()</code> ：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</p></li><li><p><code>public boolean mkdirs()</code> ：创建文件目录。如果此文件目录存在，就不创建了。如果上层文件目录不存在，一并创建</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file1.exists())&#123;</span><br><span class="line">        <span class="comment">//文件的创建</span></span><br><span class="line">        file1.createNewFile();</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//文件存在</span></span><br><span class="line">        file1.delete();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//文件目录的创建</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io\\io1\\io3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">mkdir</span> <span class="operator">=</span> file1.mkdir();</span><br><span class="line">    <span class="keyword">if</span>(mkdir)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\io\\io1\\io4&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">mkdir1</span> <span class="operator">=</span> file2.mkdirs();</span><br><span class="line">    <span class="keyword">if</span>(mkdir1)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//要想删除成功，io4文件目录下不能有子目录或文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\io\\io1\\io4&quot;</span>);</span><br><span class="line">    file3 = <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\io\\io1&quot;</span>);</span><br><span class="line">    System.out.println(file3.delete());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="File类的删除功能"><a href="#File类的删除功能" class="headerlink" title="File类的删除功能"></a>File类的删除功能</h4></blockquote><ul><li>删除磁盘中的文件或文件目录</li><li><code>public boolean delete()</code>：删除文件或者文件夹</li><li>删除注意事项：Java中的删除不走回收站。</li></ul><h4 id="内存解析"><a href="#内存解析" class="headerlink" title="内存解析"></a>内存解析</h4><p><img src="/../image/JavaPic/%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90.awebp"></p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>利用 File 构造器，<code>new</code> 一个文件目录file</p><p>1）在其中创建多个文件和目录</p><p>2）编写方法，实现删除fle中指定文件的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\io\\io1\\hello.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//创建一个与file同目录下的另外一个文件，文件名为：haha.txt</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file.getParent(),<span class="string">&quot;haha.txt&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newFile</span> <span class="operator">=</span> destFile.createNewFile();</span><br><span class="line">    <span class="keyword">if</span>(newFile)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;创建成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断指定目录下是否有后缀名为 <code>.jpg</code> 的文件，如果有，就输出该文件名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindJPGFileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\code&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String[] fileNames = srcFile.list();</span><br><span class="line">        <span class="keyword">for</span>(String fileName : fileNames)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fileName.endsWith(<span class="string">&quot;.jpg&quot;</span>))&#123;</span><br><span class="line">                System.out.println(fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\code&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File[] listFiles = srcFile.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(File file : listFiles)&#123;</span><br><span class="line">            <span class="keyword">if</span>(file.getName().endsWith(<span class="string">&quot;.jpg&quot;</span>))&#123;</span><br><span class="line">                System.out.println(file.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * File类提供了两个文件过滤器方法</span></span><br><span class="line"><span class="comment"> * public String[] list(FilenameFilter filter)</span></span><br><span class="line"><span class="comment"> * public File[] listFiles(FileFilter filter)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\code&quot;</span>);</span><br><span class="line"></span><br><span class="line">        File[] subFiles = srcFile.listFiles(<span class="keyword">new</span> <span class="title class_">FilenameFilter</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">accept</span><span class="params">(File dir, String name)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> name.endsWith(<span class="string">&quot;.jpg&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(File file : subFiles)&#123;</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历指定目录所有文件名称，包括子文件目录中的文件。</p><p>拓展1：并计算指定目录占用空间的大小</p><p>拓展2：删除指定文件目录及其下的所有文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListFileTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归:文件目录</span></span><br><span class="line">        <span class="comment">/** 打印出指定目录所有文件名称，包括子文件目录中的文件 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建目录对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;E:\\test&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.打印子目录</span></span><br><span class="line">        printSubFile(file);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归方法遍历所有目录下的文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dir</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printSubFile</span><span class="params">(File dir)</span> &#123;</span><br><span class="line">        <span class="comment">//打印子目录</span></span><br><span class="line">        File[] files = dir.listFiles();</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;<span class="comment">//如果为文件目录，则递归调用自身</span></span><br><span class="line">                printSubFile(f);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(f.getAbsolutePath());<span class="comment">//输出绝对路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓展1：求指定目录所在空间的大小</span></span><br><span class="line">    <span class="comment">// 求任意一个目录的总大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDirectorySize</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="comment">// file是文件，那么直接返回file.length()</span></span><br><span class="line">        <span class="comment">// file是目录，把它的下一级的所有大小加起来就是它的总大小</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">            size += file.length();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            File[] allFiles = file.listFiles();<span class="comment">// 获取file的下一级</span></span><br><span class="line">            <span class="comment">// 累加all[i]的大小</span></span><br><span class="line">            <span class="keyword">for</span> (File f : allFiles) &#123;</span><br><span class="line">                size += getDirectorySize(f);<span class="comment">//f的大小</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拓展2：删除指定的目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteDirectory</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果file是文件，直接delete</span></span><br><span class="line">        <span class="comment">// 如果file是目录，先把它的下一级干掉，然后删除自己</span></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            File[] allFiles = file.listFiles();</span><br><span class="line">            <span class="comment">//递归调用删除file下一级</span></span><br><span class="line">            <span class="keyword">for</span> (File f : allFiles) &#123;</span><br><span class="line">                deleteDirectory(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//删除文件</span></span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><ul><li><p>IO 是 Input&#x2F;Output 的缩写，I&#x2F;O 技术是非常实用的技术，用于处理设备之间的数据传输。如读&#x2F;写文件，网络通讯等。</p></li><li><p>Java程序中，对于数据的输入输出操作以 “流(stream)” 的方式进行。</p></li><li><p><code>Java.IO</code> 包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据。</p></li></ul><h4 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h4><p><strong>操作数据单位：字节流、字符流</strong></p><ul><li>对于文本文件(<code>.txt,.java,.c,.cpp</code>)，使用字符流处理</li><li>对于非文本文件(<code>.jpg,.mp3,.mp4,.avi,.doc,.ppt,...</code>)，使用字节流处理</li></ul><p><strong>数据的流向：输入流、输出流</strong></p><ul><li>输入 input:读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中。</li><li>输出 output:将程序（内存）数据输出到磁盘、光盘等存储设备中。</li></ul><p><strong>流的角色：节点流、处理流</strong></p><p>节点流：直接从数据源或目的地读写数据。</p><p><img src="/../image/JavaPic/%E6%B5%81%E7%9A%84%E8%A7%92%E8%89%B2.awebp"></p><p>处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能。</p><p><img src="/../image/JavaPic/%E5%A4%84%E7%90%86%E6%B5%81.awebp"></p><p><img src="/../image/JavaPic/%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB.awebp"></p><h4 id="IO流的体系分类"><a href="#IO流的体系分类" class="headerlink" title="IO流的体系分类"></a>IO流的体系分类</h4><blockquote><h4 id="总体分类"><a href="#总体分类" class="headerlink" title="总体分类"></a>总体分类</h4></blockquote><p><img src="/../image/JavaPic/%E6%80%BB%E4%BD%93%E5%88%86%E7%B1%BB.awebp"></p><p>红框为抽象基类，蓝框为常用IO流</p><blockquote><h4 id="常用的几个IO流结构"><a href="#常用的几个IO流结构" class="headerlink" title="常用的几个IO流结构"></a>常用的几个IO流结构</h4></blockquote><table><thead><tr><th><strong>抽象基类</strong></th><th><strong>节点流（或文件流）</strong></th><th><strong>缓冲流（处理流的一种）</strong></th></tr></thead><tbody><tr><td>InputStream</td><td>FileInputStream (read(byte[] buffer))</td><td>BufferedInputStream (read(byte[] buffer))</td></tr><tr><td>OutputSteam</td><td>FileOutputStream (write(byte[] buffer,0,len)</td><td>BufferedOutputStream (write(byte[] buffer,0,len)<code>/</code>flush()</td></tr><tr><td>Reader</td><td>FileReader (read(char[] cbuf))</td><td>BufferedReader (read(char[] cbuf)<code>/</code>readLine()</td></tr><tr><td>Writer</td><td>FileWriter (write(char[] cbuf,0,len)</td><td>BufferedWriter (write(char[] cbuf,0,len)<code>/</code>flush()</td></tr></tbody></table><blockquote><h4 id="对抽象基类的说明："><a href="#对抽象基类的说明：" class="headerlink" title="对抽象基类的说明："></a>对抽象基类的说明：</h4></blockquote><table><thead><tr><th><strong>抽象基类</strong></th><th><strong>字节流</strong></th><th><strong>字符流</strong></th></tr></thead><tbody><tr><td>输入流</td><td>InputSteam</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputSteam</td><td>Writer</td></tr></tbody></table><ul><li>说明：Java的lO流共涉及40多个类，实际上非常规则，都是从如下4个抽象基类派生的。</li><li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀。</li></ul><p>1InputSteam &amp; Reader</p><ul><li>InputStream和Reader是所有输入流的基类。</li><li>InputStream（典型实现：FileInputStream）<ul><li><code>int read()</code></li><li><code>int read(byte[] b)</code></li><li><code>int read(byte[] b,int off,int len)</code></li></ul></li><li>Reader（典型实现：FileReader）<ul><li><code>int read()</code></li><li><code>int read(char[] c)</code></li><li><code>int read(char[] c,int off,int len)</code></li></ul></li><li>程序中打开的文件IO资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。</li><li>FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream 用于读取非文本数据之类的原始字节流。要读取字符流，需要使用 FileReader。</li></ul><p><strong>InputSteam：</strong></p><ul><li><p><code>int read()</code></p><p>从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节，则返回值-1。</p></li><li><p><code>int read(byte[] b)</code></p><p>从此输入流中将最多b.length个字节的数据读入一个byte数组中。如果因为已经到达流末尾而没有可用的字节，则返回值-1.否则以整数形式返回实际读取的字节数。</p></li><li><p><code>int read(byte[] b,int off,int len)</code></p><p>将输入流中最多len个数据字节读入byte数组。尝试读取len个字节，但读取的字节也可能小于该值。以整数形式返回实际读取的字节数。如果因为流位于文件末尾而没有可用的字节，则返回值-1。</p></li><li><p><code>public void close throws IOException</code></p><p>关闭此输入流并释放与该流关联的所有系统资源。</p></li></ul><p><strong>Reader：</strong></p><ul><li><p><code>int read()</code></p><p>读取单个字符。作为整数读取的字符，范围在0到65535之间（0x00-0xffff）(2个字节的 Unicode码)，如果已到达流的末尾，则返回-1。</p></li><li><p><code>int read（char[] cbuf)</code></p><p>将字符读入数组。如果已到达流的末尾，则返回-1。否则返回本次读取的字符数。</p></li><li><p><code>int read（char[] cbuf,int off,int len)</code></p><p>将字符读入数组的某一部分。存到数组cbuf中，从off处开始存储，最多读len个字符。如果已到达流的末尾，则返回-1。否则返回本次读取的字符数。</p></li><li><p><code>public void close throws IOException</code></p><p>关闭此输入流并释放与该流关联的所有系统资源</p></li></ul><p>2 OutputSteam &amp; Writer</p><ul><li>OutputStream 和 Writer也非常相似：<ul><li><code>void write(int b/int c);</code></li><li><code>void write(byte[] b/char[] cbuf);</code></li><li><code>void write(byte[] b/char[] buff,int off,int len);</code></li><li><code>void flush();</code></li><li><code> void close();//需要先刷新，再关闭此流</code></li></ul></li><li>因为字符流直接以字符作为操作单位，所以 Writer可以用字符串来替换字符数组，即以 String对象作为参数<ul><li><code>void write(String str);</code></li><li><code>void write(String str,int off,int len);</code></li></ul></li><li>FileOutputStream 从文件系统中的某个文件中获得输出字节。FileOutputstream 用于写出非文本数据之类的原始字节流。要写出字符流，需要使用 FileWriter</li></ul><p><strong>OutputStream:</strong></p><ul><li><p><code>void write(int b)</code></p><p>将指定的字节写入此输出流。 write的常规协定是：向输出流写入一个字节。要写入的字节是参数b的八个低位。b的24个高位将被忽略。即写入0~255范围的</p></li><li><p><code>void write（byte[] b)</code></p><p>将 <code>b.length</code> 个字节从指定的byte数组写入此输出流。<code>write(b)</code>的常规协定是：应该与调用<code>wite(b,0,b.length)</code>的效果完全相同。</p></li><li><p><code>void write(byte[] b,int off,int len)</code></p><p>将指定byte数组中从偏移量off开始的len个字节写入此输出流。</p></li><li><p><code>public void flush()throws IOException</code></p><p>刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标。</p></li><li><p><code>public void close throws IOException</code></p><p>关闭此输岀流并释放与该流关联的所有系统资源。</p></li></ul><p><strong>Writer:</strong></p><ul><li><p><code>void write(int c)</code></p><p>写入单个字符。要写入的字符包含在给定整数值的16个低位中，16高位被忽略。即写入0到65535之间的 Unicode码。</p></li><li><p><code>void write(char[] cbuf)</code></p><p>写入字符数组</p></li><li><p><code>void write(char[] cbuf,int off,int len)</code></p><p>写入字符数组的某一部分。从off开始，写入len个字符</p></li><li><p><code>void write(String str)</code></p><p>写入字符串。</p></li><li><p><code>void write(String str,int off,int len)</code></p><p>写入字符串的某一部分。</p></li><li><p><code>void flush()</code></p><p>刷新该流的缓冲，则立即将它们写入预期目标。</p></li><li><p><code>public void close throws IOException</code></p><p>关闭此输出流并释放与该流关联的所有系统资源</p></li></ul><h4 id="输入、输出标准化过程"><a href="#输入、输出标准化过程" class="headerlink" title="输入、输出标准化过程"></a>输入、输出标准化过程</h4><blockquote><h4 id="输入过程："><a href="#输入过程：" class="headerlink" title="输入过程："></a>输入过程：</h4></blockquote><p>① 创建 File 类的对象，指明读取的数据的来源。（要求此文件一定要存在）</p><p>② 创建相应的输入流，将 File 类的对象作为参数，传入流的构造器中</p><p>③ 具体的读入过程：创建相应的 <code>byte[]</code> 或 <code>char[]</code>。</p><p>④ 关闭流资源</p><p>说明：程序中出现的异常需要使用 <code>try-catch-finally</code> 处理。</p><blockquote><h4 id="输出过程："><a href="#输出过程：" class="headerlink" title="输出过程："></a>输出过程：</h4></blockquote><p>① 创建 File 类的对象，指明写出的数据的位置。（不要求此文件一定要存在）</p><p>② 创建相应的输出流，将 File 类的对象作为参数，传入流的构造器中</p><p>③ 具体的写出过程：<code>write(char[]/byte[] buffer,0,len)</code></p><p>④ 关闭流资源</p><p>说明：程序中出现的异常需要使用 <code>try-catch-finally</code> 处理。</p><h3 id="节点流（文件流）"><a href="#节点流（文件流）" class="headerlink" title="节点流（文件流）"></a>节点流（文件流）</h3><h4 id="文件字符流FileReader和FileWriter的使用"><a href="#文件字符流FileReader和FileWriter的使用" class="headerlink" title="文件字符流FileReader和FileWriter的使用"></a>文件字符流FileReader和FileWriter的使用</h4><blockquote><h4 id="文件的输入"><a href="#文件的输入" class="headerlink" title="文件的输入"></a>文件的输入</h4></blockquote><p>从文件中读取到内存（程序）中</p><p><strong>步骤：</strong></p><ol><li>建立一个流对象，将已存在的一个文件加载进流 <code>FileReader fr = new FileReader(new File(&quot;Test. txt&quot;));</code></li><li>创建一个临时存放数据的数组 <code>char[] ch = new char[1024];</code></li><li>调用流对象的读取方法将流中的数据读入到数组中。 <code>fr.read(ch);</code></li><li>关闭资源。 <code>fr.close();</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader1</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.File类的实例化</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.FileReader流的实例化</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.读入的操作</span></span><br><span class="line">        <span class="comment">//read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.资源的关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ol><li><code>read()</code> 的理解：返回读入的一个字符。如果达到文件末尾，返回-1</li><li>异常的处理：为了保证流资源一定可以执行关闭操作。需要使用 <code>try-catch-finally</code> 处理</li><li>读入的文件一定要存在，否则就会报 <code>FileNotFoundException</code>。</li></ol><blockquote><h4 id="文件的输出"><a href="#文件的输出" class="headerlink" title="文件的输出"></a>文件的输出</h4></blockquote><p>从内存（程序）到硬盘文件中</p><p><strong>步骤：</strong></p><ol><li>创建流对象，建立数据存放文件 <code>File Writer fw = new File Writer(new File(&quot;Test.txt&quot;))</code></li><li>调用流对象的写入方法，将数据写入流 <code>fw.write(&quot;HelloWord&quot;)</code></li><li>关闭流资源，并将流中的数据清空到文件中。 <code>fw.close();</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.提供File类的对象，指明写出到的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.提供FileWriter的对象，用于数据的写出</span></span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.写出的操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;you need to have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.流资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h4 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h4></blockquote><p>实现文本文件的复制操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReaderFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建File类的对象，指明读入和写出的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello2.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能使用字符流来处理图片等字节数据</span></span><br><span class="line">        <span class="comment">//            File srcFile = new File(&quot;test.jpg&quot;);</span></span><br><span class="line">        <span class="comment">//            File destFile = new File(&quot;test1.jpg&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建输入流和输出流的对象</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);</span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.数据的读入和写出操作</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;<span class="comment">//记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//每次写出len个字符</span></span><br><span class="line">            fw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭流资源</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="literal">null</span>)</span><br><span class="line">                fw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)</span><br><span class="line">                fr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文件字节流FileInputSteam和FileOutputSteam的使用"><a href="#文件字节流FileInputSteam和FileOutputSteam的使用" class="headerlink" title="文件字节流FileInputSteam和FileOutputSteam的使用"></a>文件字节流FileInputSteam和FileOutputSteam的使用</h4><p>文件字节流操作与字符流操作类似，只是实例化对象操作和数据类型不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用字节流FileInputStream处理文本文件，可能出现乱码。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputStream</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1. 造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.读数据</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;<span class="comment">//记录每次读取的字节的个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现图片文件复制操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputOutputStream</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建File对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test2.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建操流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h4><ul><li><p>定义路径时，可以用 <code>/</code> 或 <code>\\</code>。</p></li><li><p>输出操作，对应的 File 可以不存在的。并不会报异常。</p></li><li><p>File 对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</p></li><li><p>File 对应的硬盘中的文件如果存在：</p><ul><li><p>如果流使用的构造器是：<code>FileWriter(file,false)</code> &#x2F; <code>FileWriter(file)</code>:对原有文件的覆盖。</p></li><li><p>如果流使用的构造器是：<code>FileWriter(file,true)</code>:不会对原有文件覆盖，而是在原有文件基础上追加内容。</p></li></ul></li><li><p>读取文件时，必须保证文件存在，否则会报异常。</p></li><li><p>对于文本文件(<code>.txt,.java,.c,.cpp</code>)，使用字符流处理</p></li><li><p>对于非文本文件(<code>.jpg,.mp3,.mp4,.avi,.doc,.ppt,...</code>)，使用字节流处理</p></li></ul><h3 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h3><h4 id="缓冲流涉及到的类"><a href="#缓冲流涉及到的类" class="headerlink" title="缓冲流涉及到的类"></a>缓冲流涉及到的类</h4><ul><li><code>BufferedInputStream</code></li><li><code>BufferedOutputStream</code></li><li><code>BufferedReader</code></li><li><code>BufferedWriter</code></li></ul><h4 id="引入目的"><a href="#引入目的" class="headerlink" title="引入目的"></a>引入目的</h4><ul><li>作用：提供流的读取、写入的速度</li><li>提高读写速度的原因：内部提供了一个缓冲区。默认情况下是8kb</li></ul><p><img src="/../image/JavaPic/%E7%BC%93%E5%86%B2%E6%B5%81.awebp"></p><p><strong>处理流与节点流的对比图示</strong></p><p><img src="/../image/JavaPic/%E5%A4%84%E7%90%86%E6%B5%81%E4%B8%8E%E8%8A%82%E7%82%B9%E6%B5%81%E7%9A%84%E5%AF%B9%E6%AF%94%E5%9B%BE%E7%A4%BA-1.awebp"></p><p><img src="/../image/JavaPic/%E5%A4%84%E7%90%86%E6%B5%81%E4%B8%8E%E8%8A%82%E7%82%B9%E6%B5%81%E7%9A%84%E5%AF%B9%E6%AF%94%E5%9B%BE%E7%A4%BA-2.awebp"></p><h4 id="使用说明-4"><a href="#使用说明-4" class="headerlink" title="使用说明"></a>使用说明</h4><ul><li><p>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区。</p></li><li><p>当使用 <code>BufferedInputStream</code> 读取字节文件时，<code>BufferedInputStream</code> 会一次性从文件中读取8192个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个8192个字节数组。</p></li><li><p>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满，<code>BufferedOutputStream</code> 才会把缓冲区中的数据一次性写到文件里。使用方法 <code>flush()</code> 可以强制将缓冲区的内容全部写入输出流。</p></li><li><p>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也会相应关闭内层节点流。</p></li><li><p><code>flush()</code> 方法的使用：手动将 buffer 中内容写入文件。</p></li><li><p>如果是带缓冲区的流对象的 <code>close()</code> 方法，不但会关闭流，还会在关闭流之前刷新缓冲区，关闭后不能再写出。</p></li></ul><blockquote><h5 id="使用-BufferInputStream-和-BufferOutputStream-实现非文本文件的复制"><a href="#使用-BufferInputStream-和-BufferOutputStream-实现非文本文件的复制" class="headerlink" title="使用 BufferInputStream 和 BufferOutputStream 实现非文本文件的复制"></a>使用 BufferInputStream 和 BufferOutputStream 实现非文本文件的复制</h5></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test4.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        <span class="comment">//2.1造节点流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">//2.2造缓冲流，可以合并书写</span></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.文件读取、写出操作</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (bos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bis != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="使用-BufferedReader-和-BufferedWriter-实现文本文件的复制"><a href="#使用-BufferedReader-和-BufferedWriter-实现文本文件的复制" class="headerlink" title="使用 BufferedReader 和 BufferedWriter 实现文本文件的复制"></a>使用 BufferedReader 和 BufferedWriter 实现文本文件的复制</h5></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedReaderBufferedWriter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件和相应的流</span></span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>)));</span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp1.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读写操作</span></span><br><span class="line">        <span class="comment">//方式一：使用char[]数组</span></span><br><span class="line">        <span class="comment">//            char[] cbuf = new char[1024];</span></span><br><span class="line">        <span class="comment">//            int len;</span></span><br><span class="line">        <span class="comment">//            while((len = br.read(cbuf)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//                bw.write(cbuf,0,len);</span></span><br><span class="line">        <span class="comment">//    //            bw.flush();</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二：使用String</span></span><br><span class="line">        String data;</span><br><span class="line">        <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//方法一：</span></span><br><span class="line">            <span class="comment">//                bw.write(data + &quot;\n&quot;);//data中不包含换行符</span></span><br><span class="line">            <span class="comment">//方法二：</span></span><br><span class="line">            bw.write(data);<span class="comment">//data中不包含换行符</span></span><br><span class="line">            bw.newLine();<span class="comment">//提供换行的操作</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(bw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h4><blockquote><h5 id="测试缓冲流和节点流文件复制速度"><a href="#测试缓冲流和节点流文件复制速度" class="headerlink" title="测试缓冲流和节点流文件复制速度"></a>测试缓冲流和节点流文件复制速度</h5></blockquote><p>节点流实现复制方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定路径下文件的复制</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFile</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缓冲流实现复制操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现文件复制的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileWithBuffered</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        <span class="comment">//2.1 造节点流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((srcFile));</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">//2.2 造缓冲流</span></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.复制的细节：读取、写入</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.资源关闭</span></span><br><span class="line">        <span class="comment">//要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">        <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试二者速度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCopyFileWithBuffered</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">srcPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\01-视频.avi&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">destPath</span> <span class="operator">=</span> <span class="string">&quot;C:\\Users\\Administrator\\Desktop\\03-视频.avi&quot;</span>;</span><br><span class="line"></span><br><span class="line">    copyFileWithBuffered(srcPath,destPath);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;复制操作花费的时间为：&quot;</span> + (end - start));<span class="comment">//618 - 176</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="实现图片加密操作"><a href="#实现图片加密操作" class="headerlink" title="实现图片加密操作"></a>实现图片加密操作</h5></blockquote><p>加密操作</p><ul><li>将图片文件通过字节流读取到程序中</li><li>将图片的字节流逐一进行 <code>^</code> 操作</li><li>将处理后的图片字节流输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片的加密</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;testSecret.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buffer[i] = (<span class="type">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密操作</p><ul><li>将加密后图片文件通过字节流读取到程序中</li><li>将图片的字节流逐一进行 <code>^</code> 操作（原理：<code>A^B^B = A</code>）</li><li>将处理后的图片字节流输出</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片的解密</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;testSecret.jpg&quot;</span>);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test4.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                buffer[i] = (<span class="type">byte</span>) (buffer[i] ^ <span class="number">5</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fis != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="统计文本字符出现次数"><a href="#统计文本字符出现次数" class="headerlink" title="统计文本字符出现次数"></a>统计文本字符出现次数</h5></blockquote><p>实现思路：</p><ol><li>遍历文本每一个字符</li><li>字符出现的次数存在Map中</li><li>把map中的数据写入文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWordCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建Map集合</span></span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.遍历每一个字符,每一个字符出现的次数放到map中</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((c = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//int 还原 char</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> (<span class="type">char</span>) c;</span><br><span class="line">            <span class="comment">// 判断char是否在map中第一次出现</span></span><br><span class="line">            <span class="keyword">if</span> (map.get(ch) == <span class="literal">null</span>) &#123;</span><br><span class="line">                map.put(ch, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(ch, map.get(ch) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.把map中数据存在文件count.txt</span></span><br><span class="line">        <span class="comment">//3.1 创建Writer</span></span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;wordcount.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.2 遍历map,再写入数据</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Character, Integer&gt; entry : entrySet) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (entry.getKey()) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                    bw.write(<span class="string">&quot;空格=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:<span class="comment">//\t表示tab 键字符</span></span><br><span class="line">                    bw.write(<span class="string">&quot;tab键=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:<span class="comment">//</span></span><br><span class="line">                    bw.write(<span class="string">&quot;回车=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:<span class="comment">//</span></span><br><span class="line">                    bw.write(<span class="string">&quot;换行=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    bw.write(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bw.newLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关流</span></span><br><span class="line">        <span class="keyword">if</span> (fr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bw != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li><p>转换流提供了在字节流和字符流之间的转换</p></li><li><p>Java API提供了两个转换流：</p><ul><li><p><code>InputstreamReader</code>：将 <code>Inputstream</code> 转换为 <code>Reader</code></p></li><li><p><code>OutputStreamWriter</code>：将 <code>Writer</code> 转换为 <code>OutputStream</code></p></li></ul></li><li><p>字节流中的数据都是字符时，转成字符流操作更高效。</p></li><li><p>很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能。</p></li></ul><blockquote><h4 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h4></blockquote><p>InputStreamReader 将一个字节的输入流转换为字符的输入流</p><p>解码：字节、字节数组 —&gt;字符数组、字符串</p><p>构造器：</p><ul><li><code>public InputStreamReader(InputStream in)</code></li><li><code>public InputStreamReader(Inputstream in,String charsetName)//可以指定编码集</code></li></ul><blockquote><h4 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h4></blockquote><p>OutputStreamWriter 将一个字符的输出流转换为字节的输出流</p><p>编码：字符数组、字符串 —&gt; 字节、字节数组</p><p>构造器：</p><ul><li><code>public OutputStreamWriter(OutputStream out)</code></li><li><code>public OutputStreamWriter(Outputstream out,String charsetName)//可以指定编码集</code></li></ul><p><img src="/../image/JavaPic/OutputStreamWriter.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">综合使用InputStreamReader和OutputStreamWriter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件、造流</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp_gbk.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line"></span><br><span class="line">        isr = <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        osw = <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读写过程</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关流</span></span><br><span class="line">        <span class="keyword">if</span> (isr != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                isr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (osw != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                osw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：文件编码的方式（比如：GBK），决定了解析时使用的字符集（也只能是GBK）。</p><h4 id="编码集"><a href="#编码集" class="headerlink" title="编码集"></a>编码集</h4><blockquote><h5 id="常见的编码表"><a href="#常见的编码表" class="headerlink" title="常见的编码表"></a>常见的编码表</h5></blockquote><ul><li><p>ASCII：美国标准信息交换码。用一个字节的7位可以表示。</p></li><li><p>ISO8859-1：拉丁码表。欧洲码表用一个字节的8位表示。</p></li><li><p>GB2312：中国的中文编码表。最多两个字节编码所有字符</p></li><li><p>GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码</p></li><li><p>Unicode：国际标准码，融合了目前人类使用的所字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示。</p></li><li><p>UTF-8：变长的编码方式，可用1-4个字节来表示一个字符。</p></li></ul><p><img src="/../image/JavaPic/%E7%BC%96%E7%A0%81%E8%A1%A8.awebp"></p><p><strong>说明：</strong></p><ul><li>面向传输的众多UTF(UCS Transfer Format)标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了。</li><li>Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16。</li></ul><p><strong>UTF-8变长编码表示</strong></p><p><img src="/../image/JavaPic/UTF-8%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81%E8%A1%A8%E7%A4%BA.awebp"></p><blockquote><h5 id="编码应用"><a href="#编码应用" class="headerlink" title="编码应用"></a>编码应用</h5></blockquote><ul><li>编码：字符串–&gt;字节数组</li><li>解码：字节数组–&gt;字符串</li><li>转换流的编码应用<ul><li>可以将字符按指定编码格式存储</li><li>可以对文本数据按指定编码格式来解读</li><li>指定编码表的动作由构造器完成</li></ul></li></ul><p><strong>使用要求：</strong></p><p>客户端&#x2F;浏览器端 &lt;—-&gt; 后台(java,GO,Python,Node.js,php) &lt;—-&gt; 数据库</p><p>要求前前后后使用的字符集都要统一：UTF-8.</p><h3 id="标准输入、输出流"><a href="#标准输入、输出流" class="headerlink" title="标准输入、输出流"></a>标准输入、输出流</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><code>System.in</code>:标准的输入流，默认从键盘输入</p><p><code>System.out</code>:标准的输出流，默认从控制台输出</p><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><p><code>System</code> 类的 <code>setIn(InputStream is)</code> 方式重新指定输入的流</p><p><code>System</code> 类的 <code>setOut(PrintStream ps)</code> 方式重新指定输出的流。</p><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><p>从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，</p><p>直至当输入 <code>e</code> 或者 <code>exit</code> 时，退出程序。</p><p><strong>设计思路</strong></p><p>方法一：使用 <code>Scanner</code> 实现，调用 <code>next()</code> 返回一个字符串</p><p>方法二：使用 <code>System.in</code> 实现。<code>System.in</code> —&gt; 转换流 —&gt;<code> BufferedReader</code>的<code>readLine()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> br.readLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(data) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(data)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序结束&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">upperCase</span> <span class="operator">=</span> data.toUpperCase();</span><br><span class="line">            System.out.println(upperCase);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计实现 Scanner 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInput</span> &#123;</span><br><span class="line">    <span class="comment">// Read a string from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">readString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Declare and initialize the string</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the string from the keyboard</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            string = br.readLine();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            System.out.println(ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return the string obtained from the keyboard</span></span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read an int value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">readInt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a double value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readDouble</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.parseDouble(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a byte value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readByte</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Byte.parseByte(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a short value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readShort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Short.parseShort(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a long value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readLong</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(readString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read a float value from the keyboard</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">readFloat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Float.parseFloat(readString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h3><p><code>PrintStream</code> 和 <code>PrintWriter</code> <strong>说明：</strong></p><ul><li>提供了一系列重载的 <code>print()</code> 和 <code>println()</code> 方法，用于多种数据类型的输出</li><li><code>System.out</code> 返回的是 <code>PrintStream</code> 的实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\text.txt&quot;</span>));</span><br><span class="line">        <span class="comment">// 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\n&#x27; 时都会刷新输出缓冲区)</span></span><br><span class="line">        ps = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fos, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;<span class="comment">// 把标准输出流(控制台输出)改成文件</span></span><br><span class="line">            System.setOut(ps);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123; <span class="comment">// 输出ASCII字符</span></span><br><span class="line">            System.out.print((<span class="type">char</span>) i);</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span>) &#123; <span class="comment">// 每50个数据一行</span></span><br><span class="line">                System.out.println(); <span class="comment">// 换行</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">            ps.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p><code>DataInputStream</code> 和 <code>DataOutputStream</code> <strong>作用：</strong> 用于读取或写出基本数据类型的变量或字符串</p><p><strong>示例代码：</strong></p><p>将内存中的字符串、基本数据类型的变量写出到文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//1.造对象、造流</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dos = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//数据输出</span></span><br><span class="line">        dos.writeUTF(<span class="string">&quot;Bruce&quot;</span>);</span><br><span class="line">        dos.flush();<span class="comment">//刷新操作，将内存的数据写入到文件</span></span><br><span class="line">        dos.writeInt(<span class="number">23</span>);</span><br><span class="line">        dos.flush();</span><br><span class="line">        dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">        dos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (dos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造对象、造流</span></span><br><span class="line">        dis = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//2.从文件读入数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;age:&quot;</span>+age);</span><br><span class="line">        System.out.println(<span class="string">&quot;isMale:&quot;</span>+isMale);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        <span class="keyword">if</span> (dis != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h3><h4 id="对象流-1"><a href="#对象流-1" class="headerlink" title="对象流"></a>对象流</h4><p><code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code></p><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul><li><code>ObjectOutputStream</code>:内存中的对象—&gt;存储中的文件、通过网络传输出去：序列化过程</li><li><code>ObjectInputStream</code>:存储中的文件、通过网络接收过来 —&gt;内存中的对象：反序列化过程</li></ul><h4 id="对象的序列化"><a href="#对象的序列化" class="headerlink" title="对象的序列化"></a>对象的序列化</h4><ul><li><p>对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。&#x2F;&#x2F;当其它程序获取了这种二进制流，就可以恢复成原来的Java对象。</p></li><li><p>序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原。</p></li><li><p>序列化是RMI(Remote Method Invoke-远程方法调用)过程的参数和返回值都必须实现的机制，RMI是JavaEE的基础。因此序列化机制是JavaEE平台的基础。</p></li><li><p>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出 <code>NotserializableEXception</code> 异常</p><ul><li><p>Serializable</p></li><li><p>Externalizable</p></li></ul></li><li><p>凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：</p><ul><li><p><code>private static final long serialVersionUID;</code></p></li><li><p><code>serialVersionUID</code> 用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容</p></li><li><p>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID可能发生变化。故建议显式声明。</p></li></ul></li><li><p>简单来说，Java 的序列化机制是通过在运行时判断类的 <code>serialversionUID</code> 来验证版本一致性的。在进行反序列化时，JVM 会把传来的字节流中的 <code>serialversionUID</code> 与本地相应实体类的  <code>serialversionUID</code> 进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。(<code>InvalidCastException</code>)</p></li></ul><h4 id="实现序列化的对象所属的类需要满足："><a href="#实现序列化的对象所属的类需要满足：" class="headerlink" title="实现序列化的对象所属的类需要满足："></a>实现序列化的对象所属的类需要满足：</h4><ol><li>需要实现接口：<code>Serializable</code>（标识接口）</li><li>当前类提供一个全局常量：<code>serialVersionUID</code>（序列版本号）</li><li>除了当前 <code>Person</code> 类需要实现 <code>Serializable</code> 接口之外，还必须保证其内部所属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</li></ol><p>补充：<code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 不能序列化 <code>static</code> 和 <code>transient</code> 修饰的成员变量</p><h4 id="对象流的使用"><a href="#对象流的使用" class="headerlink" title="对象流的使用"></a>对象流的使用</h4><blockquote><h5 id="序列化代码实现"><a href="#序列化代码实现" class="headerlink" title="序列化代码实现"></a>序列化代码实现</h5></blockquote><p>序列化：将对象写入磁盘或进行网络传输</p><p>要求被序列化对象必须实现序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectOutputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建对象，创建流</span></span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">        <span class="comment">//2.操作流</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱北京天安门&quot;</span>));</span><br><span class="line">        oos.flush();<span class="comment">//刷新操作</span></span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王铭&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张学良&quot;</span>,<span class="number">23</span>,<span class="number">1001</span>,<span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">5000</span>)));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(oos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//3.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="反序列化代码实现"><a href="#反序列化代码实现" class="headerlink" title="反序列化代码实现"></a>反序列化代码实现</h5></blockquote><p>反序列化：将磁盘的对象数据源读出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectInputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ois != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任意存取文件流"><a href="#任意存取文件流" class="headerlink" title="任意存取文件流"></a>任意存取文件流</h3><p><code>RandomAccessFile</code> 的使用</p><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><ul><li><p><code>RandomAccessFile</code> 直接继承于 <code>java.lang.Object</code> 类，实现了 <code>DataInput</code> <code>和DataOutput</code> 接口</p></li><li><p><code>RandomAccessFile</code> 既可以作为一个输入流，又可以作为一个输出流</p></li><li><p><code>RandomAccessFile</code> 类支持“随机访问”的方式，程序可以直接跳到文件的任意地方来读、写文件</p><ul><li><p>支持只访问文件的部分内容</p></li><li><p>可以向已存在的文件后追加内容</p></li></ul></li><li><p><code>RandomAccessFile</code> 对象包含一个记录指针，用以标示当前读写处的位置</p></li><li><p><code>RandomaccessFile</code> 类对象可以自由移动记录指针：</p><ul><li><p><code>long getFilePointer()</code>：获取文件记录指针的当前位置</p></li><li><p><code> void seek(long pos)</code>：将文件记录指针定位到 <code>pos</code> 位置</p></li></ul></li></ul><p><strong>构造器</strong></p><p><code>public RandomAccessFile(File file,String mode)</code> </p><p><code>public RandomAccessFile(String name,String mode)</code></p><h4 id="使用说明-5"><a href="#使用说明-5" class="headerlink" title="使用说明"></a>使用说明</h4><p>如果 <code>RandomAccessFile</code> 作为输出流时，写出到的文件如果不存在，则在执行过程中自动创建。</p><p>如果写出到的文件存在，则会对原文件内容进行覆盖。（默认情况下，从头覆盖）</p><p>可以通过相关的操作，实现 <code>RandomAccessFile</code> <strong>“插入”</strong>数据的效果。借助 <code>seek(int pos)</code> 方法</p><p>创建 <code>RandomAccessFile</code> 类实例需要指定一个 <code>mode</code> 参数，<code>该参数指定RandomAccessFile</code> 的访问模式:</p><ul><li>r：以只读方式打开</li><li>rw：打开以便读取和写入</li><li>rwd：打开以便读取和写入；同步文件内容的更新</li><li>rws：打开以便读取和写入；同步文件内容和元数据的更新</li></ul><p>如果模式为只读 r ,则不会创建文件，而是会去读取一个已经存在的文件,读取的文件不存在则会出现异常。如果模式为 rw 读写,文件不存在则会去创建文件，存在则不会创建</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><p>文件的读取和写出操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建对象，创建流</span></span><br><span class="line">        raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        raf2 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;test1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//2.操作流</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            raf2.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关闭流</span></span><br><span class="line">        <span class="keyword">if</span>(raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(raf2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>RandomAccessFile</code> 实现数据的插入效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">        raf1.seek(<span class="number">3</span>);<span class="comment">//将指针调到角标为3的位置</span></span><br><span class="line">        <span class="comment">//            //方式一</span></span><br><span class="line">        <span class="comment">//            //保存指针3后面的所有数据到StringBuilder中</span></span><br><span class="line">        <span class="comment">//            StringBuilder builder = new StringBuilder((int) new File(&quot;hello.txt&quot;).length());</span></span><br><span class="line">        <span class="comment">//            byte[] buffer = new byte[20];</span></span><br><span class="line">        <span class="comment">//            int len;</span></span><br><span class="line">        <span class="comment">//            while ((len = raf1.read(buffer)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//                builder.append(new String(buffer,0,len));</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//方式二</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调回指针，写入“xyz”</span></span><br><span class="line">        raf1.seek(<span class="number">3</span>);</span><br><span class="line">        raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line">        <span class="comment">//将StringBuilder中的数据写入到文件中</span></span><br><span class="line">        raf1.write(baos.toString().getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流的基本应用总结"><a href="#流的基本应用总结" class="headerlink" title="流的基本应用总结"></a>流的基本应用总结</h3><ul><li><p>流是用来处理数据的。</p></li><li><p>处理数据时，一定要先明确数据源，与数据目的地数据源可以是文件，可以是键盘数据目的地可以是文件、显示器或者其他设备</p></li><li><p>而流只是在帮助数据进行传输，并对传输的数据进行处理，比如过滤处理、转换处理等</p></li><li><p>除去RandomAccessFile类外所有的流都继承于四个基本数据流抽象类InputSteam、OutputSteam、Reader、Writer</p></li><li><p>不同的操作流对应的后缀均为四个抽象基类中的某一个</p><p><img src="/../image/JavaPic/%E6%B5%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93.awebp"></p></li><li><p>不同处理流的使用方式都是标准操作：</p><ul><li>创建文件对象，创建相应的流</li><li>处理流数据</li><li>关闭流</li><li>用try-catch-finally处理异常</li></ul></li></ul><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><p>Path、Paths、Files的使用，介绍比较简单，后期会再抽时间详细写有关 <code>NIO</code> 的博客。</p><h4 id="NIO的使用说明"><a href="#NIO的使用说明" class="headerlink" title="NIO的使用说明"></a>NIO的使用说明</h4><ul><li><p>Java NIO (New IO，Non-Blocking IO)是从Java 1.4版本开始引入的一套新的IO API，可以替代标准的Java IO AP。</p></li><li><p>NIO 与原来的 IO 同样的作用和目的，但是使用的方式完全不同，NIO 支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。</p></li><li><p>NIO 将以更加高效的方式进行文件的读写操作。</p></li><li><p>JDK 7.0对 NIO 进行了极大的扩展，增强了对文件处理和文件系统特性的支持，称他为 NIO.2。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO</span><br><span class="line">|-----java.nio.channels.Channel</span><br><span class="line">      |---- FileChannel：处理本地文件</span><br><span class="line">      |---- SocketChannel：TCP网络编程的客户端的Channel</span><br><span class="line">      |---- ServerSocketChannel：TCP网络编程的服务器端的Channel</span><br><span class="line">      |---- DatagramChannel：UDP网络编程中发送端和接收端的Channel</span><br></pre></td></tr></table></figure><h4 id="Path接口—JDK7-0提供"><a href="#Path接口—JDK7-0提供" class="headerlink" title="Path接口—JDK7.0提供"></a>Path接口—JDK7.0提供</h4><ul><li><p>早期的 Java 只提供了一个 <code>File</code> 类来访问文件系统，但 <code>File</code> 类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息。</p></li><li><p>NIO.2为了弥补这种不足，引入了 <code>Path</code> 接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置。<code>Path</code> 可以看成是 <code>File</code> 类的升级版本，实际引用的资源也可以不存在。</p></li></ul><blockquote><h5 id="Path的说明："><a href="#Path的说明：" class="headerlink" title="Path的说明："></a>Path的说明：</h5></blockquote><p>Path替换原有的File类。</p><ul><li>在以前IO操作都是这样写的：<ul><li><code>import java.io.File</code></li><li><code>File file = new File(&quot;index.html&quot;);</code></li></ul></li><li>但在Java7中，我们可以这样写：<ul><li><code>import java.nio.file.Path;</code></li><li><code>import java.nio.file.Paths;</code></li><li><code>Path path = Paths.get(&quot;index. html&quot;);</code></li></ul></li></ul><blockquote><h5 id="Paths的使用"><a href="#Paths的使用" class="headerlink" title="Paths的使用"></a>Paths的使用</h5></blockquote><ul><li><p><code>Paths</code> 类提供的静态 <code>get()</code> 方法用来获取 <code>Path</code> 对象：</p></li><li><p><code>static Path get(String first， String….more)</code>：用于将多个字符串串连成路径</p></li><li><p><code>static Path get(URI uri)</code>：返回指定 uri 对应的 Path 路径</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;hello.txt&quot;</span>);<span class="comment">//new File(String filepath)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\&quot;</span>, <span class="string">&quot;test\\test1\\haha.txt&quot;</span>);<span class="comment">//new File(String parent,String filename);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path3</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;E:\\&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(path1);</span><br><span class="line">    System.out.println(path2);</span><br><span class="line">    System.out.println(path3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="常用方法-5"><a href="#常用方法-5" class="headerlink" title="常用方法"></a>常用方法</h5></blockquote><ul><li><p><code>String toString()</code> ： 返回调用 <code>Path</code> 对象的字符串表示形式</p></li><li><p><code>boolean startsWith(String path)</code> : 判断是否以 <code>path</code> 路径开始</p></li><li><p><code>boolean endsWith(String path)</code> : 判断是否以 <code>path</code> 路径结束</p></li><li><p><code>boolean isAbsolute()</code> : 判断是否是绝对路径</p></li><li><p><code>Path getParent()</code> ：返回 <code>Path</code> 对象包含整个路径，不包含 <code>Path</code> 对象指定的文件路径</p></li><li><p><code>Path getRoot()</code> ：返回调用 <code>Path</code> 对象的根路径</p></li><li><p><code>Path getFileName()</code> : 返回与调用 <code>Path</code> 对象关联的文件名</p></li><li><p><code>int getNameCount()</code> : 返回 <code>Path</code> 根目录后面元素的数量</p></li><li><p><code>Path getName(int idx)</code> : 返回指定索引位置 <code>idx</code> 的路径名称</p></li><li><p><code>Path toAbsolutePath()</code> : 作为绝对路径返回调用 <code>Path</code> 对象</p></li><li><p><code>Path resolve(Path p)</code> :合并两个路径，返回合并后的路径对应的 <code>Path</code> 对象</p></li><li><p><code>File toFile()</code>: 将 <code>Path</code> 转化为 <code>File</code> 类的对象</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\&quot;</span>, <span class="string">&quot;nio\\nio1\\nio2\\hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String toString() ： 返回调用 Path 对象的字符串表示形式</span></span><br><span class="line">    System.out.println(path1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean startsWith(String path) : 判断是否以 path 路径开始</span></span><br><span class="line">    System.out.println(path1.startsWith(<span class="string">&quot;d:\\nio&quot;</span>));</span><br><span class="line">    <span class="comment">//boolean endsWith(String path) : 判断是否以 path 路径结束</span></span><br><span class="line">    System.out.println(path1.endsWith(<span class="string">&quot;hello.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//boolean isAbsolute() : 判断是否是绝对路径</span></span><br><span class="line">    System.out.println(path1.isAbsolute() + <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    System.out.println(path2.isAbsolute() + <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    <span class="comment">//Path getParent() ：返回Path对象包含整个路径，不包含 Path 对象指定的文件路径</span></span><br><span class="line">    System.out.println(path1.getParent());</span><br><span class="line">    System.out.println(path2.getParent());</span><br><span class="line">    <span class="comment">//Path getRoot() ：返回调用 Path 对象的根路径</span></span><br><span class="line">    System.out.println(path1.getRoot());</span><br><span class="line">    System.out.println(path2.getRoot());</span><br><span class="line">    <span class="comment">//Path getFileName() : 返回与调用 Path 对象关联的文件名</span></span><br><span class="line">    System.out.println(path1.getFileName() + <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    System.out.println(path2.getFileName() + <span class="string">&quot;~&quot;</span>);</span><br><span class="line">    <span class="comment">//int getNameCount() : 返回Path 根目录后面元素的数量</span></span><br><span class="line">    <span class="comment">//Path getName(int idx) : 返回指定索引位置 idx 的路径名称</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; path1.getNameCount(); i++) &#123;</span><br><span class="line">        System.out.println(path1.getName(i) + <span class="string">&quot;*****&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Path toAbsolutePath() : 作为绝对路径返回调用 Path 对象</span></span><br><span class="line">    System.out.println(path1.toAbsolutePath());</span><br><span class="line">    System.out.println(path2.toAbsolutePath());</span><br><span class="line">    <span class="comment">//Path resolve(Path p) :合并两个路径，返回合并后的路径对应的Path对象</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path3</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\&quot;</span>, <span class="string">&quot;nio&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path4</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;nioo\\hi.txt&quot;</span>);</span><br><span class="line">    path3 = path3.resolve(path4);</span><br><span class="line">    System.out.println(path3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//File toFile(): 将Path转化为File类的对象</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> path1.toFile();<span class="comment">//Path---&gt;File的转换</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Path</span> <span class="variable">newPath</span> <span class="operator">=</span> file.toPath();<span class="comment">//File---&gt;Path的转换</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Files类"><a href="#Files类" class="headerlink" title="Files类"></a>Files类</h4><p><code>java.nio.file.Files</code> 用于操作文件或目录的工具类</p><blockquote><h5 id="Files类常用方法"><a href="#Files类常用方法" class="headerlink" title="Files类常用方法"></a>Files类常用方法</h5></blockquote><ul><li><p><code>Path copy(Path src, Path dest, CopyOption … how)</code> : 文件的复制</p><p>要想复制成功，要求 <code>path1</code> 对应的物理上的文件存在。<code>path1</code> 对应的文件没有要求。</p></li><li><p>Files.copy(path1,path2,StandardCopyOption.REPLACE_EXISTING);</p></li><li><p><code>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr)</code> : 创建一个目录</p><p>要想执行成功，要求 <code>path</code> 对应的物理上的文件目录不存在。一旦存在，抛出异常。</p></li><li><p><code>Path createFile(Path path, FileAttribute&lt;?&gt; … arr)</code> : 创建一个文件</p><p>要想执行成功，要求 <code>path</code> 对应的物理上的文件不存在。一旦存在，抛出异常。</p></li><li><p><code>void delete(Path path)</code> : 删除一个文件&#x2F;目录，如果不存在，执行报错</p></li><li><p><code>void deleteIfExists(Path path)</code> : <code>Path</code> 对应的文件&#x2F;目录如果存在，执行删除.如果不存在，正常执行结束</p></li><li><p><code>Path move(Path src, Path dest, CopyOption…how)</code> : 将 <code>src</code> 移动到 <code>dest</code> 位置</p><p>要想执行成功，<code>src</code> 对应的物理上的文件需要存在，<code>dest</code> 对应的文件没有要求。</p></li><li><p><code>long size(Path path)</code> : 返回 <code>path</code> 指定文件的大小</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Path copy(Path src, Path dest, CopyOption … how) : 文件的复制</span></span><br><span class="line">    <span class="comment">//要想复制成功，要求path1对应的物理上的文件存在。path1对应的文件没有要求。</span></span><br><span class="line">    <span class="comment">//Files.copy(path1, path2, StandardCopyOption.REPLACE_EXISTING);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) : 创建一个目录</span></span><br><span class="line">    <span class="comment">//要想执行成功，要求path对应的物理上的文件目录不存在。一旦存在，抛出异常。</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path3</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio\\nio1&quot;</span>);</span><br><span class="line">    <span class="comment">//Files.createDirectory(path3);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Path createFile(Path path, FileAttribute&lt;?&gt; … arr) : 创建一个文件</span></span><br><span class="line">    <span class="comment">//要想执行成功，要求path对应的物理上的文件不存在。一旦存在，抛出异常。</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path4</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio\\hi.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//Files.createFile(path4);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void delete(Path path) : 删除一个文件/目录，如果不存在，执行报错</span></span><br><span class="line">    <span class="comment">//Files.delete(path4);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//void deleteIfExists(Path path) : Path对应的文件/目录如果存在，执行删除.如果不存在，正常执行结束</span></span><br><span class="line">    Files.deleteIfExists(path3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Path move(Path src, Path dest, CopyOption…how) : 将 src 移动到 dest 位置</span></span><br><span class="line">    <span class="comment">//要想执行成功，src对应的物理上的文件需要存在，dest对应的文件没有要求。</span></span><br><span class="line">    <span class="comment">//Files.move(path1, path2, StandardCopyOption.ATOMIC_MOVE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//long size(Path path) : 返回 path 指定文件的大小</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Files.size(path2);</span><br><span class="line">    System.out.println(size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="Files类常用方法：用于判断"><a href="#Files类常用方法：用于判断" class="headerlink" title="Files类常用方法：用于判断"></a>Files类常用方法：用于判断</h5></blockquote><ul><li><p><code>boolean exists(Path path, LinkOption … opts)</code> : 判断文件是否存在</p></li><li><p><code>boolean isDirectory(Path path, LinkOption … opts) </code>: 判断是否是目录</p></li></ul><p>​不要求此 <code>path</code> 对应的物理文件存在。</p><ul><li><p><code>boolean isRegularFile(Path path, LinkOption … opts) </code>: 判断是否是文件</p></li><li><p><code>boolean isHidden(Path path)</code> : 判断是否是隐藏文件</p><p>要求此 <code>path</code> 对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常。</p></li><li><p><code>boolean isReadable(Path path)</code> : 判断文件是否可读</p></li><li><p><code>boolean isWritable(Path path)</code> : 判断文件是否可写</p></li><li><p><code>boolean notExists(Path path, LinkOption … opts)</code> : 判断文件是否不存在</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;atguigu.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//boolean exists(Path path, LinkOption … opts) : 判断文件是否存在</span></span><br><span class="line">    System.out.println(Files.exists(path2, LinkOption.NOFOLLOW_LINKS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean isDirectory(Path path, LinkOption … opts) : 判断是否是目录</span></span><br><span class="line">    <span class="comment">//不要求此path对应的物理文件存在。</span></span><br><span class="line">    System.out.println(Files.isDirectory(path1, LinkOption.NOFOLLOW_LINKS));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean isRegularFile(Path path, LinkOption … opts) : 判断是否是文件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean isHidden(Path path) : 判断是否是隐藏文件</span></span><br><span class="line">    <span class="comment">//要求此path对应的物理上的文件需要存在。才可判断是否隐藏。否则，抛异常。</span></span><br><span class="line">    <span class="comment">//System.out.println(Files.isHidden(path1));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//boolean isReadable(Path path) : 判断文件是否可读</span></span><br><span class="line">    System.out.println(Files.isReadable(path1));</span><br><span class="line">    <span class="comment">//boolean isWritable(Path path) : 判断文件是否可写</span></span><br><span class="line">    System.out.println(Files.isWritable(path1));</span><br><span class="line">    <span class="comment">//boolean notExists(Path path, LinkOption … opts) : 判断文件是否不存在</span></span><br><span class="line">    System.out.println(Files.notExists(path1, LinkOption.NOFOLLOW_LINKS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充：</strong></p><ul><li><code>StandardOpenOption.READ</code>:表示对应的 <code>Channel</code> 是可读的。</li><li><code>StandardOpenOption.WRITE</code>：表示对应的 <code>Channel</code> 是可写的。</li><li><code>StandardOpenOption.CREATE</code>：如果要写出的文件不存在，则创建。如果存在，忽略</li><li><code>StandardOpenOption.CREATE_NEW</code>：如果要写出的文件不存在，则创建。如果存在，抛异常</li></ul><blockquote><h5 id="Files类常用方法：用于操作内容"><a href="#Files类常用方法：用于操作内容" class="headerlink" title="Files类常用方法：用于操作内容"></a>Files类常用方法：用于操作内容</h5></blockquote><ul><li><p><code>InputStream newInputStream(Path path, OpenOption…how)</code>:获取 <code>InputStream</code> 对象</p></li><li><p><code>OutputStream newOutputStream(Path path, OpenOption…how)</code> : 获取 <code>OutputStream</code> 对象</p></li><li><p><code>SeekableByteChannel newByteChannel(Path path, OpenOption…how)</code> : 获取与指定文件的连接，<code>how</code> 指定打开方式。</p></li><li><p><code>DirectoryStream&lt;Path&gt; newDirectoryStream(Path path)</code> : 打开 <code>path</code> 指定的目录</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\nio&quot;</span>, <span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//InputStream newInputStream(Path path, OpenOption…how):获取 InputStream 对象</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Files.newInputStream(path1, StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//OutputStream newOutputStream(Path path, OpenOption…how) : 获取 OutputStream 对象</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> Files.newOutputStream(path1, StandardOpenOption.WRITE,StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//SeekableByteChannel newByteChannel(Path path, OpenOption…how) : 获取与指定文件的连接，how 指定打开方式。</span></span><br><span class="line">    <span class="type">SeekableByteChannel</span> <span class="variable">channel</span> <span class="operator">=</span> Files.newByteChannel(path1, StandardOpenOption.READ,StandardOpenOption.WRITE,StandardOpenOption.CREATE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DirectoryStream&lt;Path&gt;  newDirectoryStream(Path path) : 打开 path 指定的目录</span></span><br><span class="line">    <span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;e:\\teach&quot;</span>);</span><br><span class="line">    DirectoryStream&lt;Path&gt; directoryStream = Files.newDirectoryStream(path2);</span><br><span class="line">    Iterator&lt;Path&gt; iterator = directoryStream.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java之网络编程"><a href="#Java之网络编程" class="headerlink" title="Java之网络编程"></a>Java之网络编程</h2><p><code>InternetAccess</code> 类的使用</p><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>计算机网络：</p><ul><li>把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息共享硬件、软件、数据信息等资源。</li></ul><p>网络编程的目的: 直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯</p><p>实现网络通信需要解决的两个问题:</p><ul><li>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用</li><li>找到主机后如何可靠高效地进行数据传输</li></ul><h3 id="网络通讯要素"><a href="#网络通讯要素" class="headerlink" title="网络通讯要素"></a>网络通讯要素</h3><ul><li>解决问题一：IP 和端口号</li><li>解决问题二：提供网络通信协议：TCP&#x2F;IP 参考模型（应用层、传输层、网络层、物理+数据链路层）</li></ul><p><strong>网络通讯协议</strong></p><p><img src="/../image/JavaPic/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE.awebp"></p><p><strong>通讯过程</strong></p><p><img src="/../image/JavaPic/%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B.awebp"></p><h4 id="通讯要素一：IP和端口号"><a href="#通讯要素一：IP和端口号" class="headerlink" title="通讯要素一：IP和端口号"></a>通讯要素一：IP和端口号</h4><blockquote><h5 id="IP的理解"><a href="#IP的理解" class="headerlink" title="IP的理解"></a>IP的理解</h5></blockquote><ul><li><p>IP:唯一的标识 Internet 上的计算机（通信实体）</p></li><li><p>在Java中使用InetAddress类代表IP</p></li><li><p>IP分类：IPv4 和 IPv6 ; 万维网 和 局域网</p></li><li><p>域名: 通过域名解析服务器将域名解析为IP地址，如： <a href="https://link.juejin.cn/?target=http://www.baidu.com">www.baidu.com</a> <a href="https://link.juejin.cn/?target=http://www.mi.com">www.mi.com</a> <a href="https://link.juejin.cn/?target=http://www.jd.com">www.jd.com</a></p></li><li><p>域名解析：域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器(DNS)负责将域名转化成IP地址，这样才能和主机建立连接。</p></li><li><p>本地回路地址：<code>127.0.0.1</code> 对应着：<code>localhost</code></p></li></ul><blockquote><h5 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h5></blockquote><p>用于标识正在计算机上运行的进程。</p><ul><li>要求：不同的进程不同的端口号</li><li>范围：被规定为一个 16 位的整数 0~65535。</li><li>分类：<ul><li>公认端口：0~1023.被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，TeInet占用端口23）。</li><li>注册端口：1024~49151.分配给用户进程或应用程序。（如：Tomcat占用端口8080，MSQL占用端口3306，Oracle占用端口1521等）。</li><li>动态私有端口：49152~65535。</li></ul></li></ul><blockquote><h5 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h5></blockquote><p>此类的一个对象就代表着一个具体的IP地址</p><p>实例化</p><p><code>getByName(String host)</code> &#x2F;<code>getLocalHost()</code></p><p>常用方法</p><p><code>getHostName()</code> &#x2F; <code>getHostAddress()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InetAddressTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet1</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.10.14&quot;</span>);</span><br><span class="line"></span><br><span class="line">            System.out.println(inet1);</span><br><span class="line"></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet2</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">            System.out.println(inet2);</span><br><span class="line"></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet3</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            System.out.println(inet3);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取本地ip</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet4</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">            System.out.println(inet4);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//getHostName()</span></span><br><span class="line">            System.out.println(inet2.getHostName());</span><br><span class="line">            <span class="comment">//getHostAddress()</span></span><br><span class="line">            System.out.println(inet2.getHostAddress());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="通信要素二：网络通信协议"><a href="#通信要素二：网络通信协议" class="headerlink" title="通信要素二：网络通信协议"></a>通信要素二：网络通信协议</h4><blockquote><h5 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h5></blockquote><p><img src="/../image/JavaPic/%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.awebp"></p><blockquote><h5 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h5></blockquote><p><strong>TCP协议</strong>：</p><ul><li>使用TCP协议前，须先建立TCP连接，形成传输数据通道</li><li>传输前，采用“三次握手”方式，点对点通信，是可靠的</li><li>TCP协议进行通信的两个应用进程：客户端、服务端。</li><li>在连接中可进行大数据量的传输</li><li>传输完毕，需释放已建立的连接，效率低</li></ul><p><strong>UDP协议：</strong></p><ul><li>将数据、源、目的封装成数据包，不需要建立连接</li><li>每个数据报的大小限制在64K内</li><li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li><li>可以广播发送</li><li>发送数据结束时无需释放资源，开销小，速度快</li></ul><blockquote><h5 id="TCP三次握手和四次挥手"><a href="#TCP三次握手和四次挥手" class="headerlink" title="TCP三次握手和四次挥手"></a>TCP三次握手和四次挥手</h5></blockquote><p><img src="/../image/JavaPic/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.awebp"></p><p><img src="/../image/JavaPic/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.awebp"></p><h4 id="套接字Socket"><a href="#套接字Socket" class="headerlink" title="套接字Socket"></a>套接字Socket</h4><p>端口号与 IP 地址的组合得出一个网络套接字：<code>Socket</code></p><ul><li>利用套接字(<code>Socket</code>)开发网络应用程序早已被广泛的采用，以至于成为事实上的标准。</li><li>网络上具有唯一标识的 IP 地址和端口号组合在一起才能构成唯一能识别的标识符套接字。</li><li>通信的两端都要有 <code>Socket</code>，是两台机器间通信的端点。</li><li>网络通信其实就是 <code>Socket</code> 间的通信。</li><li><code>Socket</code> 允许程序把网络连接当成一个流，数据在两个 <code>Socket</code> 间通过 <code>IO</code> 传输。</li><li>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端</li><li><code>Socket</code> 分类<ul><li>流套接字(<code>stream socket</code>)：使用TCP提供可依赖的字节流服务</li><li>数据报套接字(<code>datagram socket</code>)：使用UDP提供“尽力而为”的数据报服务</li></ul></li></ul><p><img src="/../image/JavaPic/Socket.awebp"></p><h3 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h3><p>Java语言的基于套接字Socket编程分为客户端和服务端</p><p><strong>基于TCP的Socket通信模型</strong></p><p><img src="/../image/JavaPic/%E5%9F%BA%E4%BA%8ETCP%E7%9A%84Socket%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B.awebp"></p><h4 id="基于Socket的TCP编程"><a href="#基于Socket的TCP编程" class="headerlink" title="基于Socket的TCP编程"></a>基于Socket的TCP编程</h4><blockquote><h5 id="客户端Socket的工作过程"><a href="#客户端Socket的工作过程" class="headerlink" title="客户端Socket的工作过程"></a>客户端Socket的工作过程</h5></blockquote><ul><li>创建 <code>Socket</code>：根据指定服务端的 IP地址或端口号构造 <code>Sσcket</code> 类对象。若服务器端响应，则建立客户端到服务器的通信线路。若连接失败，会出现异常。</li><li>打开连接到 <code>Socket</code> 的输入出流：使用 <code>getInputstream()</code> 方法获得输入流，使用<code>getOutputStream()</code> 方法获得输出流，进行数据传输</li><li>按照一定的协议对 <code>Socket</code> 进行读&#x2F;写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程</li><li>关闭 <code>Socket</code>：断开客户端到服务器的连接，释放线路</li></ul><p><strong>说明</strong>：</p><ul><li>客户端程序可以使用 <code>Socket</code> 类创建对象，创建的同时会自动向服务器方发起连接。</li><li><code>Socket</code> 的构造器是：<ul><li><code>Socket(String host，int port) throws UnknownHostException</code>，<code>EXCeption</code>：向服务器（域名是 <code>host</code>,端口号为 <code>port</code> ）发起 <code>TCP</code> 连接，若成功，则创建 <code>Socket</code> 对象，否则抛出异常。</li><li><code>Socket(InetAddress address，int port)throws IOException</code>：根据 <code>InetAddress</code> 对象所表示的 <code>IP</code> 地址以及端口号 <code>port</code> 发起连接</li></ul></li><li>客户端建立 socketAtClient对象的过程就是向服务器发出套接字连接请求</li></ul><blockquote><h5 id="服务器端Socket的工作过程："><a href="#服务器端Socket的工作过程：" class="headerlink" title="服务器端Socket的工作过程："></a>服务器端Socket的工作过程：</h5></blockquote><ul><li>调用 <code>ServerSocket(int port)</code>：创建一个服务器端套接字，并绑定到指定端口上。用于监听客户端的请求。</li><li>调用 <code>accept0()</code>：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象。</li><li>调用该 <code>Socket</code> 类对象的 <code>getOutputStream()</code> 和 <code>getInputStream()</code>：获取输出流和输入流，开始网络数据的发送和接收。</li><li>关闭 <code>ServerSocket</code> 和 <code>Socket</code> 对象：客户端访问结束，关闭通信套接字。</li></ul><p><strong>说明：</strong></p><ul><li><code>ServerSocket</code> 对象负责等待客户端请求建立套接字连接，类似邮局某个窗口中的业务员。也就是说，服务器必须事先建立一个等待客户请求建立套接字连接的 <code>Server Socket</code> 对象。</li><li>所谓“接收”客户的套接字请求，就是 <code>accept()</code> 方法会返回一个 <code>Socket</code> 对象</li></ul><p>客户端发送信息给服务端，服务端将数据显示在控制台上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span>  &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.14.100&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet,<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.获取一个输出流，用于输出数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3.写出数据的操作</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是客户端mm&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.资源的关闭</span></span><br><span class="line">            <span class="keyword">if</span>(os != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">            <span class="comment">//2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">            socket = ss.accept();</span><br><span class="line">            <span class="comment">//3.获取输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不建议这样写，可能会有乱码</span></span><br><span class="line">            <span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line">            <span class="comment">//        int len;</span></span><br><span class="line">            <span class="comment">//        while((len = is.read(buffer)) != -1)&#123;</span></span><br><span class="line">            <span class="comment">//            String str = new String(buffer,0,len);</span></span><br><span class="line">            <span class="comment">//            System.out.print(str);</span></span><br><span class="line">            <span class="comment">//        &#125;</span></span><br><span class="line">            <span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自于：&quot;</span> + socket.getInetAddress().getHostAddress() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(baos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//5.关闭资源</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ss != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ss.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端发送文件给服务端，服务端将文件保存在本地。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.</span></span><br><span class="line">        fis.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty1.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//5.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//6.</span></span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPTest3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭数据的输出</span></span><br><span class="line">        socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.接收来自于服务器端的数据，并显示到控制台上</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] bufferr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="type">int</span> len1;</span><br><span class="line">        <span class="keyword">while</span>((len1 = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer,<span class="number">0</span>,len1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.</span></span><br><span class="line">        fis.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        baos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="comment">//4.</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty2.jpg&quot;</span>));</span><br><span class="line">        <span class="comment">//5.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;图片传输完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.服务器端给予客户端反馈</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;你好，美女，照片我已收到，非常漂亮！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.</span></span><br><span class="line">        fos.close();</span><br><span class="line">        is.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        ss.close();</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h3><h4 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h4><ul><li><p>类 <code>DatagramSocket</code> 和 <code>DatagramPacket</code> 实现了基于 <code>UDP</code> 协议网络程序。</p></li><li><p><code>UDP</code> 数据报通过数据报套接字 <code>DatagramSocket</code> 发送和接收，系统不保证 <code>UDP</code> 数据报一定能够安全送到目的地，也不能确定什么时候可以抵达。</p></li><li><p><code>DatagramPacket</code> 对象封装了 <code>UDP</code> 数据报，在数据报中包含了发送端的 <code>IP</code> 地址和端口号以及接收端的 <code>IP</code> 地址和端口号</p></li><li><p><code>UDP</code> 协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样。</p></li></ul><h4 id="DatagramSocket类常用方法"><a href="#DatagramSocket类常用方法" class="headerlink" title="DatagramSocket类常用方法"></a>DatagramSocket类常用方法</h4><p><img src="/../image/JavaPic/DatagramSocket%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-1.awebp"></p><p><img src="/../image/JavaPic/DatagramSocket%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-2.awebp"></p><h4 id="DatagramSocket类的使用"><a href="#DatagramSocket类的使用" class="headerlink" title="DatagramSocket类的使用"></a>DatagramSocket类的使用</h4><p>流程：</p><ol><li><code>DatagramSocket</code> 与 <code>DatagramPacket</code></li><li>建立发送端，接收端</li><li>建立数据包</li><li>调用 <code>Socket</code> 的发送、接收方法</li><li>关闭 <code>Socket</code></li></ol><p>注意：发送端与接收端是两个独立的运行程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sender</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是UDP方式发送的导弹&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = str.getBytes();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,<span class="number">0</span>,data.length,inet,<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接收端</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiver</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line"></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line"></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="URL编程"><a href="#URL编程" class="headerlink" title="URL编程"></a>URL编程</h3><ul><li><p><code>URL(Uniform Resource Locator)</code>：统一资源定位符，它表示 Internet 上某一资源的地址。</p></li><li><p>它是一种具体的 <code>URI</code>，即 <code>URL</code> 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</p></li><li><p>通过 <code>URL</code> 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp站点。浏览器通过解析给定的 <code>URL</code> 可以在网络上查找相应的文件或其他资源</p></li><li><p>URL的基本结构由5部分组成: &lt;传输协议&gt;：&#x2F;&#x2F;&lt;主机名&gt;：&lt;端口号&gt;&#x2F;&lt;文件名&gt;#片段名？参数列表</p><p>例如： <code>http://192.168.1.100:8080/helloworld/indexjsp#a?username=shkstart&amp;password=123</code></p></li></ul><p><strong>#片段名</strong>：即锚点，例如看小说，直接定位到章节</p><p><strong>参数列表格式</strong>：参数名&#x3D;参数值&amp;参数名&#x3D;参数值…</p><h4 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h4><blockquote><h5 id="构造器-2"><a href="#构造器-2" class="headerlink" title="构造器"></a>构造器</h5></blockquote><p>为了表示 <code>URL</code>，<code>java.net</code>中实现了类 <code>URL</code>。我们可以通过下面的构造器来初始化一个 <code>URL</code> 对象</p><ul><li><p><code>public URL(String spec)</code>：通过一个表示 <code>URL</code> 地址的字符串可以构造一个 <code>URL</code> 对象。 例如：<code>URL url = new URL（&quot;[http://www.baidu.com/](http://www.baidu.com/)&quot;);</code></p></li><li><p><code>public URL(URL context,String spec)</code>：通过基URL和相对URL构造一个URL对象</p><p>例如： <code>URL downloadeUrl = new URL(url,&quot;download.html&quot;);</code></p></li><li><p><code>public URL(String protocol,String host,String file);</code> &#96;&#96; 例如：<code>new URL(&quot;http&quot;,&quot;[www.baidu.com](http://www.baidu.com)&quot;,80,&quot;download.html&quot;);</code></p></li><li><p><code>public URL(String protocol,String host,int port,String file);</code></p><p>例如：<code>new URL(&quot;http&quot;,&quot;[www.baidu.com](http://www.baidu.com)&quot;,80,&quot;download.html&quot;);</code></p></li></ul><p>注意：<code>URL</code> 类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 <code>try-catch</code> 语句进行捕获。</p><blockquote><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5></blockquote><ul><li><p><code>public String getProtocol()</code> 获取该 <code>URL</code> 的协议名</p></li><li><p><code>public String getHost()</code> 获取该 <code>URL</code> 的主机名</p></li><li><p><code>public String getPort()</code> 获取该 <code>URL</code> 的端口号</p></li><li><p><code>public String getPath()</code> 获取该 <code>URL</code> 的文件路径</p></li><li><p><code>public String getFile()</code> 获取该 <code>URL</code> 的文件名</p></li><li><p><code>public String getQuery()</code> 获取该 <code>URL</code> 的查询名</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?username=Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            public String getProtocol(  )     获取该URL的协议名</span></span><br><span class="line">            System.out.println(url.getProtocol());</span><br><span class="line"><span class="comment">//            public String getHost(  )           获取该URL的主机名</span></span><br><span class="line">            System.out.println(url.getHost());</span><br><span class="line"><span class="comment">//            public String getPort(  )            获取该URL的端口号</span></span><br><span class="line">            System.out.println(url.getPort());</span><br><span class="line"><span class="comment">//            public String getPath(  )           获取该URL的文件路径</span></span><br><span class="line">            System.out.println(url.getPath());</span><br><span class="line"><span class="comment">//            public String getFile(  )             获取该URL的文件名</span></span><br><span class="line">            System.out.println(url.getFile());</span><br><span class="line"><span class="comment">//            public String getQuery(   )        获取该URL的查询名</span></span><br><span class="line">            System.out.println(url.getQuery());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过URL下载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">URLTest1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">            urlConnection.connect();</span><br><span class="line"></span><br><span class="line">            is = urlConnection.getInputStream();</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;beauty3.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;下载完成&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(urlConnection != <span class="literal">null</span>)&#123;</span><br><span class="line">                urlConnection.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java之反射"><a href="#Java之反射" class="headerlink" title="Java之反射"></a>Java之反射</h2><h3 id="反射的概述"><a href="#反射的概述" class="headerlink" title="反射的概述"></a>反射的概述</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><ul><li>Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于 <code>Reflection API</code> 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</li><li>加载完类之后，在堆内存的方法区中就产生了一个 <code>Class</code> 类型的对象（一个类只有一个 <code>Class</code> 对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。</li></ul><p>通常的方式：引入需要的“包类”名称—-&gt;通过 <code>new</code> 实例化—-&gt;获得实例化对象</p><p>反射的方式：实例化对象—-&gt; <code>getClass()</code> 方法—-&gt;得到完整的“包类”名称</p><p>框架 &#x3D; 注解 + 反射 + 设计模式</p><h4 id="反射动态性体现"><a href="#反射动态性体现" class="headerlink" title="反射动态性体现"></a>反射动态性体现</h4><p>只有当程序运行时我们才能知道调用的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);<span class="comment">//0,1,2</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                classPath = <span class="string">&quot;com.atguigu.java.Person&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> getInstance(classPath);</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建一个指定类的对象。</span></span><br><span class="line"><span class="comment">    classPath:指定类的全类名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span>  Class.forName(classPath);</span><br><span class="line">    <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射机制提供的功能"><a href="#反射机制提供的功能" class="headerlink" title="反射机制提供的功能"></a>反射机制提供的功能</h4><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时获取泛型信息</li><li>在运行时调用任意一个对象的成员变量和方法</li><li>在运行时处理注解</li><li>生成动态代理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">    <span class="comment">//1.通过反射，创建Person类对象</span></span><br><span class="line">    Constructor&lt;Person&gt; cons = clazz.getConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    System.out.println(person);<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=12&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.通过反射，调用对象指定的属性、方法</span></span><br><span class="line">    <span class="comment">//调用属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    age.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    age.set(person, <span class="number">10</span>);</span><br><span class="line">    System.out.println(person.toString());<span class="comment">//Person&#123;name=&#x27;Tom&#x27;, age=10&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    show.invoke(person);<span class="comment">//my name is Tom and age is 10</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;===================================&quot;</span>);</span><br><span class="line">    <span class="comment">//通过反射，可以调用Person类的私有结构的。比如：私有的构造器、方法、属性</span></span><br><span class="line">    <span class="comment">//调用私有的构造器</span></span><br><span class="line">    Constructor&lt;Person&gt; cons1 = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    cons1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> cons1.newInstance(<span class="string">&quot;Bruce&quot;</span>);</span><br><span class="line">    System.out.println(p1);<span class="comment">//Person&#123;name=&#x27;Bruce&#x27;, age=0&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    name.set(p1, <span class="string">&quot;Jarry&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用私有的方法</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">nation</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;nation&quot;</span>, String.class);</span><br><span class="line">    nation.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">nation1</span> <span class="operator">=</span> (String) nation.invoke(p1, <span class="string">&quot;China&quot;</span>);<span class="comment">//相当于String nation = p1.showNation(&quot;China&quot;)</span></span><br><span class="line">    System.out.println(nation1);<span class="comment">//I come from China</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h4><ul><li><code>java.lang.Class</code>：反射的源头</li><li><code>java.lang.reflect.Method</code>：反射方法</li><li><code>java.lang.reflect.Field</code>：反射参数</li><li><code>java.lang.reflect.Constructor</code>：反射构造器</li><li>….</li></ul><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><h4 id="Class类简述"><a href="#Class类简述" class="headerlink" title="Class类简述"></a>Class类简述</h4><ul><li>在 <code>Object</code> 类中定义了以下的方法，此方法将被所有子类继承：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final Class getClass()</span><br></pre></td></tr></table></figure><ul><li>以上的方法返回值的类型是一个 <code>Class</code> 类，此类是Java反射的源头，实际上所谓反射从程序的运行结果来看也很好理解，即可以通过对象反射求出类的名称。</li><li>对象使用反射后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE都为其保留一个不变的Class类型的对象。一个Class对象包含了特定某个结构（ <code>class/interface/enum/annotation/primitive type/void/[]</code>）的有关信息。<ul><li><code>Class</code> 本身也是一个类</li><li><code>Class</code> 对象只能由系统建立对象</li><li>一个加载的类在 JVM 中只会有一个 <code>Class</code> 实例</li><li>一个 <code>Class</code> 对象对应的是一个加载到 JVM 中的一个 <code>.class</code> 文件</li><li>每个类的实例都会记得自己是由哪个 <code>Class</code> 实例所生成</li><li>通过 <code>Class</code> 可以完整地得到一个类中的所有被加载的结构</li><li><code>Class</code> 类是 Reflection 的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 <code>Class</code> 对象</li></ul></li></ul><p><strong>类的加载过程：</strong></p><ul><li>程序经过 <code>javac.exe</code> 命令以后，会生成一个或多个字节码文件(<code>.class</code> 结尾)。接着我们使用 <code>java.exe</code> 命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为 <code>Class</code> 的一个实例。</li><li>换句话说，<code>Class</code> 的实例就对应着一个运行时类。</li><li>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</li></ul><h4 id="Class类的常用方法"><a href="#Class类的常用方法" class="headerlink" title="Class类的常用方法"></a>Class类的常用方法</h4><p><img src="/../image/JavaPic/Class%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Class的实例</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;test1.Person&quot;</span>;</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(str);</span><br><span class="line"><span class="comment">//调用Class的空参构造器创建对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance;</span><br><span class="line"><span class="comment">//获取clazz的name属性</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> clazz.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">field.set(obj,<span class="string">&quot;Jarry&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">name</span> <span class="operator">=</span> filed.get(obj);</span><br><span class="line">System.out.println(name);</span><br><span class="line"><span class="comment">//test1.Person为test1包下的Person类</span></span><br></pre></td></tr></table></figure><h4 id="获取Class实例的几种方式"><a href="#获取Class实例的几种方式" class="headerlink" title="获取Class实例的几种方式"></a>获取Class实例的几种方式</h4><p>1）已知具体的类，通过类的 <code>class</code> 属性获取，该方法最为安全可靠，程序性能最高 实例：<code>Class clazz = String.class;</code></p><p>2）已知某个类的实例，调用该实例的 <code>getclass()</code> 方法获取 <code>Class</code> 对象 实例：<code>Class clazz=person.getclass(); </code></p><p>3）已知一个类的全类名，且该类在类路径下，可通过 <code>Class</code> 类的静态方法 <code>forName()</code> 获取，可能抛出 <code>ClassNotFoundException</code>（比较常用）</p><p>实例：<code>Class clazz = Class.forName(String classPath)</code></p><p>4）通过类加载器 <code>ClassLoader cl = this.getclass().getClassLoader();</code> <code>Class clazz = cl.loadClass(&quot;类的全类名&quot;);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="comment">//方式一：调用运行时类的属性：.class</span></span><br><span class="line">    Class&lt;Person&gt; clazz1 = Person.class;</span><br><span class="line">    System.out.println(clazz1);<span class="comment">//class cn.bruce.java.Person</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：通过运行时类的对象,调用getClass()</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; clazz2 = p1.getClass();</span><br><span class="line">    System.out.println(clazz2);<span class="comment">//class cn.bruce.java.Person</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式三：调用Class的静态方法：forName(String classPath)</span></span><br><span class="line">    Class&lt;?&gt; clazz3 = Class.forName(<span class="string">&quot;cn.bruce.java.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz3);<span class="comment">//class cn.bruce.java.Person</span></span><br><span class="line"></span><br><span class="line">    System.out.println(clazz1 == clazz2);<span class="comment">//true</span></span><br><span class="line">    System.out.println(clazz1 == clazz3);<span class="comment">//true</span></span><br><span class="line">    <span class="comment">//方式四：使用类的加载器：ClassLoader  (了解)</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectionTest.class.getClassLoader();</span><br><span class="line">    Class&lt;?&gt; clazz4 = classLoader.loadClass(<span class="string">&quot;cn.bruce.java.Person&quot;</span>);</span><br><span class="line">    System.out.println(clazz4);<span class="comment">//class cn.bruce.java.Person</span></span><br><span class="line">    System.out.println(clazz1 == clazz4);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：创建类的对象的方式?</p><p>方式一：new + 构造器</p><p>方式二：要创建Xxx类的对象，可以考虑：Xxx、Xxxs、XxxFactory、XxxBuilder类中查看是否有静态方法的存在。可以调用其静态方法，创建Xxx对象。</p><p>方式三：通过反射</p><h4 id="Class示例可以代表的结构"><a href="#Class示例可以代表的结构" class="headerlink" title="Class示例可以代表的结构"></a>Class示例可以代表的结构</h4><p>（1）<code>class</code>：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</p><p>（2）<code>interface</code>：接口</p><p>（3）<code>[]</code>：数组</p><p>（4）<code>enum</code>：枚举</p><p>（5）<code>annotation</code>：注解@interface</p><p>（6）<code>primitive type</code>：基本数据类型</p><p>（7）<code>void</code>：无返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    Class&lt;Object&gt; c1 = Object.class;</span><br><span class="line">    Class&lt;Comparable&gt; c2 = Comparable.class;</span><br><span class="line">    Class&lt;String[]&gt; c3 = String[].class;</span><br><span class="line">    Class&lt;<span class="type">int</span>[][]&gt; c4 = <span class="type">int</span>[][].class;</span><br><span class="line">    Class&lt;ElementType&gt; c5 = ElementType.class;</span><br><span class="line">    Class&lt;Override&gt; c6 = Override.class;</span><br><span class="line">    Class&lt;Integer&gt; c7 = <span class="type">int</span>.class;</span><br><span class="line">    Class&lt;Void&gt; c8 = <span class="keyword">void</span>.class;</span><br><span class="line">    Class&lt;Class&gt; c9 = Class.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] i1 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[] i2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">int</span>[]&gt; c10 = i1.getClass();</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">int</span>[]&gt; c11 = i2.getClass();</span><br><span class="line">    <span class="comment">// 只要数组的元素类型与维度一样，就是同一个Class</span></span><br><span class="line">    System.out.println(c10 == c11);<span class="comment">//true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h3><h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过以下三个步骤对该类进行初始化。</p><p><img src="/../image/JavaPic/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.awebp"></p><ul><li><p>加载：将 <code>class</code> 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个 <code>Class</code> 对象。这个加载的过程需要类加载器参与。</p></li><li><p>链接：将 <code>Java</code> 类的二进制代码合并到JVM的运行状态之中的过程。</p><ul><li><p>验证：确保加载的类信息符合JVM规范，例如：以 <code>cafe</code> 开头，没有安全方面的问题。</p></li><li><p>准备：正式为类变量(<code>static</code>)分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配。</p></li><li><p>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</p></li></ul></li><li><p>初始化：</p><ul><li><p>执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。类构造器 <code>&lt;clinit&gt;()</code> 方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</p></li><li><p>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。</p></li><li><p>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 方法在多线程环境中被正确加锁和同步。</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoadingTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String [] args)</span>&#123;</span><br><span class="line">        System.out.println(test.m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m = <span class="number">300</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一步：加载</span></span><br><span class="line"><span class="comment">//第二步：链接结束后m=0</span></span><br><span class="line"><span class="comment">//第三步：初始化结束后，m的值由&lt;clinit&gt;()方法执行决定</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这个test构造器&lt;clinit&gt;()方法由类变量的赋值和静态代码块中的语句按照顺序合并产生，类似于</span></span><br><span class="line"><span class="comment">&lt;clinit&gt;()&#123;</span></span><br><span class="line"><span class="comment">m = 300;</span></span><br><span class="line"><span class="comment">m = 100;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="Java类编译、运行的执行流程"><a href="#Java类编译、运行的执行流程" class="headerlink" title="Java类编译、运行的执行流程"></a>Java类编译、运行的执行流程</h4><p><img src="/../image/JavaPic/Java%E7%B1%BB%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.awebp"></p><h4 id="类的加载器的作用"><a href="#类的加载器的作用" class="headerlink" title="类的加载器的作用"></a>类的加载器的作用</h4><ul><li><p>将 <code>class</code> 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区中类数据的访问入口。</p></li><li><p>类缓存：标准的 <code>JavaSE</code> 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些 <code>Class</code> 对象</p></li></ul><h4 id="类的加载器的分类"><a href="#类的加载器的分类" class="headerlink" title="类的加载器的分类"></a>类的加载器的分类</h4><p><img src="/../image/JavaPic/%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//对于自定义类，使用系统类加载器进行加载</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader);</span><br><span class="line">    <span class="comment">//调用系统类加载器的getParent()：获取扩展类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> classLoader.getParent();</span><br><span class="line">    System.out.println(classLoader1);</span><br><span class="line">    <span class="comment">//调用扩展类加载器的getParent()：无法获取引导类加载器</span></span><br><span class="line">    <span class="comment">//引导类加载器主要负责加载java的核心类库，无法加载自定义类的。</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader2</span> <span class="operator">=</span> classLoader1.getParent();</span><br><span class="line">    System.out.println(classLoader2);</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader3</span> <span class="operator">=</span> String.class.getClassLoader();</span><br><span class="line">    System.out.println(classLoader3);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Classloader加载src目录下的配置文件"><a href="#使用Classloader加载src目录下的配置文件" class="headerlink" title="使用Classloader加载src目录下的配置文件"></a>使用Classloader加载src目录下的配置文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//        //读取配置文件的方式一：</span></span><br><span class="line">    <span class="comment">//        //此时的文件默认在当前的module下。</span></span><br><span class="line">    <span class="comment">//        FileInputStream fis = null;</span></span><br><span class="line">    <span class="comment">//        try &#123;</span></span><br><span class="line">    <span class="comment">//            fis = new FileInputStream(&quot;jdbc1.properties&quot;);</span></span><br><span class="line">    <span class="comment">//            pros.load(fis);</span></span><br><span class="line">    <span class="comment">//        &#125; catch (IOException e) &#123;</span></span><br><span class="line">    <span class="comment">//            e.printStackTrace();</span></span><br><span class="line">    <span class="comment">//        &#125; finally &#123;</span></span><br><span class="line">    <span class="comment">//            if (fis != null) &#123;</span></span><br><span class="line">    <span class="comment">//                try &#123;</span></span><br><span class="line">    <span class="comment">//                    fis.close();</span></span><br><span class="line">    <span class="comment">//                &#125; catch (IOException e) &#123;</span></span><br><span class="line">    <span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">    <span class="comment">//                &#125;</span></span><br><span class="line">    <span class="comment">//            &#125;</span></span><br><span class="line">    <span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取配置文件的方式二：使用ClassLoader</span></span><br><span class="line">    <span class="comment">//配置文件默认识别为：当前module的src下</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        pros.load(is);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user + <span class="string">&quot; password =&quot;</span> + password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射的作用"><a href="#反射的作用" class="headerlink" title="反射的作用"></a>反射的作用</h3><h4 id="创建运行时类的对象"><a href="#创建运行时类的对象" class="headerlink" title="创建运行时类的对象"></a>创建运行时类的对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//方式一</span></span><br><span class="line">    Class&lt;Person&gt; clazz1 = Person.class;</span><br><span class="line">    <span class="comment">//方式二</span></span><br><span class="line">    Class&lt;Person&gt; clazz2 = (Class&lt;Person&gt;) Class.forName(<span class="string">&quot;cn.bruce.java.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> clazz1.newInstance();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> clazz2.newInstance();</span><br><span class="line">    System.out.println(person1);</span><br><span class="line">    System.out.println(person2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>newInstance()</code>:调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。</p><p>要想此方法正常的创建运行时类的对象，要求：</p><ul><li>运行时类必须提供空参的构造器</li><li>空参的构造器的访问权限得够。通常，设置为 <code>public</code>。</li></ul><p>在 <code>javabean</code> 中要求提供一个 <code>public</code> 的空参构造器。原因：</p><ul><li>便于通过反射，创建运行时类的对象</li><li>便于子类继承此运行时类时，默认调用 <code>super()</code> 时，保证父类此构造器</li></ul><h4 id="获取运行时类的完整结构"><a href="#获取运行时类的完整结构" class="headerlink" title="获取运行时类的完整结构"></a>获取运行时类的完整结构</h4><p>我们可以通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等。。。</p><blockquote><h5 id="使用反射可以取得"><a href="#使用反射可以取得" class="headerlink" title="使用反射可以取得"></a>使用反射可以取得</h5></blockquote><ul><li><p>实现的全部接口： <code>public Class&lt;?&gt;[] getInterfaces()</code> 确定此对象所表示的类或接口实现的接口。</p></li><li><p>所继承的父类： <code>public Class&lt;? Super T&gt; getSuperclass()</code> 返回表示此 <code>Class</code> 所表示的实体（类、接口、基本类型）的父类的 <code>Class</code>。</p></li><li><p>全部的构造器：</p><p><code>public Constructor&lt;T&gt;[] getConstructors()</code></p><p>返回此 <code>Class</code> 对象所表示的类的所有 <code>public</code> 构造方法。</p><p><code>public Constructor&lt;T&gt;[] getDeclaredConstructors()</code></p><p>返回此Class对象表示的类声明的所有构造方法。</p><p>在Constructor类中:</p><ul><li>取得修饰符：<code>public int getModifiers();</code></li><li>取得方法名称： <code>public String getName();</code></li><li>取得参数的类型： <code>public Class&lt;?&gt; getParameterTypes();</code></li></ul></li><li><p>全部的方法：</p><p><code>public Method[] getDeclaredMethods()</code></p><p>返回此Class对象所表示的类或接口的全部方法</p><p><code>public Method[] getMethods()</code></p><p>返回此 <code>Class</code> 对象所表示的类或接口的 <code>public</code> 的方法</p><p><code>Method</code> 类中：</p><ul><li><code>public Class&lt;?&gt; getReturnType()</code>：取得全部的返回值</li><li><code>public Class&lt;?&gt;[] getParameterTypes()</code>：取得全部的参数</li><li><code>public int getModifiers()</code>：取得修饰符</li><li><code>public Class&lt;?&gt; [] getEXceptionTypes()</code>：取得异常信息</li></ul></li><li><p>全部的 <code>Field</code>:</p><p><code>public Field[] getFields()</code></p><p>返回此 <code>Class</code> 对象所表示的类或接口的 <code>public</code> 的 <code>Field</code>。</p><p><code>public Field[] getDeclaredFields()</code></p><p>返回此 <code>Class</code> 对象所表示的类或接口的全部 <code>Field</code></p><p><code>Field</code> 方法中</p><ul><li><code>public int getModifiers()</code>：以整数形式返回此 <code>Field</code> 的修饰符</li><li><code>public Class&lt;?&gt; getType()</code>：得到 <code>Field</code> 的属性类型</li><li><code>public String getName()</code>：返回 <code>Field</code> 的名称。</li></ul></li><li><p><code>Annotation</code> 相关</p><p><code>get Annotation(Class&lt;T&gt; annotationClass)</code><br><code>getDeclaredAnnotations()</code></p></li><li><p>泛型相关</p></li></ul><p>​获取父类泛型类型：<code>Type getGenericSuperclass()</code></p><p>​泛型类型：<code>ParameterizedType</code></p><p>​获取实际的泛型类型参数数<code>getActualTypeArguments()</code></p><ul><li>类所在的包 <code>Package getPackage()</code></li></ul><p><strong>获取属性 Fieled</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FiledTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">//获取属性结构</span></span><br><span class="line">        <span class="comment">//getFields():获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">        Field[] fields = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             fields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所有属性。（不包含父类中声明的属性）</span></span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             declaredFields) &#123;</span><br><span class="line">            System.out.println(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//权限修饰符  数据类型 变量名</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cn.bruce.java1.Person&quot;</span>);</span><br><span class="line">        Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field f :</span><br><span class="line">             declaredFields) &#123;</span><br><span class="line">            <span class="comment">//1.权限修饰符</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">modifiers</span> <span class="operator">=</span> f.getModifiers();</span><br><span class="line">            System.out.print(Modifier.toString(modifiers)+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.数据类型</span></span><br><span class="line">            Class&lt;?&gt; type = f.getType();</span><br><span class="line">            System.out.print(type.getName()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.变量名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">fName</span> <span class="operator">=</span> f.getName();</span><br><span class="line">            System.out.print(fName);</span><br><span class="line"></span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取方法 Method</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">//getMethods():获取当前运行时类及其所有父类中声明为public权限的方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             methods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;============&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredMethods():获取当前运行时类中声明的所有方法。（不包含父类中声明的方法）</span></span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             declaredMethods) &#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Xxxx</span></span><br><span class="line"><span class="comment">    权限修饰符  返回值类型  方法名(参数类型1 形参名1,...) throws XxxException&#123;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">&quot;cn.bruce.java1.Person&quot;</span>);</span><br><span class="line">        Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method m :</span><br><span class="line">             declaredMethods) &#123;</span><br><span class="line">            <span class="comment">//1.获取方法声明的注解</span></span><br><span class="line">            Annotation[] annos = m.getAnnotations();</span><br><span class="line">            <span class="keyword">for</span> (Annotation a :</span><br><span class="line">                 annos) &#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.权限修饰符</span></span><br><span class="line">            System.out.print(Modifier.toString(m.getModifiers())+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.返回值类型</span></span><br><span class="line">            System.out.print(m.getReturnType().getName() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.方法名</span></span><br><span class="line">            System.out.print(m.getName());</span><br><span class="line">            System.out.print(<span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//5.形参列表</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = m.getParameterTypes();</span><br><span class="line">            <span class="keyword">if</span> (!(parameterTypes == <span class="literal">null</span> &amp;&amp; parameterTypes.length == <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i == parameterTypes.length - <span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.print(parameterTypes[i].getName() + <span class="string">&quot; args_&quot;</span> + i);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(parameterTypes[i].getName() + <span class="string">&quot;args_&quot;</span> + i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//6.抛出的异常</span></span><br><span class="line">            Class&lt;?&gt;[] exceptionTypes = m.getExceptionTypes();</span><br><span class="line">            <span class="keyword">if</span> (exceptionTypes.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;throws &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; exceptionTypes.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i==exceptionTypes.length -<span class="number">1</span>)&#123;</span><br><span class="line">                        System.out.print(exceptionTypes[i].getName());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(exceptionTypes[i].getName()+<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取其他结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OtherTest</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取构造器结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">        <span class="comment">//getConstructors():获取当前运行时类中声明为public的构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c :</span><br><span class="line">             constructors) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;================&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredConstructors():获取当前运行时类中声明的所有的构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor c :</span><br><span class="line">             declaredConstructors) &#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的父类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        Class&lt;? <span class="built_in">super</span> Person&gt; superclass = clazz.getSuperclass();</span><br><span class="line">        System.out.println(superclass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">        System.out.println(genericSuperclass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类的泛型</span></span><br><span class="line"><span class="comment">    代码：逻辑性代码  vs 功能性代码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">        <span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">        <span class="comment">//获取泛型类型</span></span><br><span class="line">        Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line">        <span class="comment">//        System.out.println(actualTypeArguments[0].getTypeName());</span></span><br><span class="line">        System.out.println(((Class)actualTypeArguments[<span class="number">0</span>]).getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类实现的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class c : interfaces)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//获取运行时类的父类实现的接口</span></span><br><span class="line">        Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">        <span class="keyword">for</span>(Class c : interfaces1)&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取运行时类所在的包</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        <span class="type">Package</span> <span class="variable">pack</span> <span class="operator">=</span> clazz.getPackage();</span><br><span class="line">        System.out.println(pack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        获取运行时类声明的注解</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">        Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annos : annotations)&#123;</span><br><span class="line">            System.out.println(annos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用运行时类的指定结构"><a href="#调用运行时类的指定结构" class="headerlink" title="调用运行时类的指定结构"></a>调用运行时类的指定结构</h4><blockquote><h5 id="调用指定的属性"><a href="#调用指定的属性" class="headerlink" title="调用指定的属性"></a>调用指定的属性</h5></blockquote><p>在反射机制中，可以直接通过 <code>Field</code> 类操作类中的属性，通过 <code>Field</code> 类提供的 <code>set()</code> 和<code>get()</code> 方法就可以完成设置和取得属性内容的操作。</p><ul><li><p><code>public Field getField(String name)</code> 返回此 <code>Class</code> 对象表示的类或接口的指定的 <code>public</code> 的 <code>Field</code>。</p></li><li><p><code>public Field getDeclaredField(String name)</code> 返回此 <code>Class</code> 对象表示的类或接口的指定的 <code>Field</code>。</p><p>在 <code>Field</code> 中:</p></li><li><p><code>public Object get(object obj)</code> 取得指定对象 <code>obj</code> 上此 <code>Field</code> 的属性内容</p></li><li><p><code>public void set(Object obj,Object value)</code> 设置指定对象 <code>obj</code> 上此 <code>Field</code> 的属性内容</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testField</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前属性是可访问的</span></span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//3.获取、设置指定对象的此属性值</span></span><br><span class="line">    name.set(p,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(name.get(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="调用指定的方法（常用）"><a href="#调用指定的方法（常用）" class="headerlink" title="调用指定的方法（常用）"></a>调用指定的方法（常用）</h5></blockquote><p>通过反射，调用类中的方法，通过 <code>Method</code> 类完成。步骤:</p><ol><li><p>通过 <code>Class</code> 类的 <code>getMethod(String name,Class… parameterTypes)</code> 方法取得一个 <code>Method</code> 对象，并设置此方法操作时所需要的参数类型。</p></li><li><p>之后使用 <code>Object invoke(Object obj， Object[] args)</code> 进行调用，并向方法中传递要设置的 <code>obj</code> 对象的参数信息。</p><p><img src="/../image/JavaPic/%E8%B0%83%E7%94%A8%E6%8C%87%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88%E5%B8%B8%E7%94%A8%EF%BC%89.awebp"></p></li></ol><p><strong>Object invoke(object obj,Object… args)方法：</strong></p><ol><li><code>Object</code> 对应原方法的返回值，若原方法无返回值，此时返回 <code>null</code></li><li>若原方法若为静态方法，此时形参 <code>Object obj</code> 可为 <code>null</code></li><li>若原方法形参列表为空，则 <code>Object[] args</code> 为 <code>null</code></li><li>若原方法声明为 <code>private</code>，则需要在调用此 <code>invoke()</code> 方法前，显式调用方法对象的 <code>setAccessible(true)</code> 方法，将可访问 <code>private</code> 的方法。</li></ol><p><strong>关于 setAccessible 方法的使用：</strong></p><ul><li><code>Method</code> 和 <code>Field</code>、<code>Constructor</code> 对象都有 <code>setAccessible()</code> 方法。</li><li><code>setAccessible</code> 是启动和禁用访问安全检查的开关</li><li>参数值为 <code>true</code> 则指示反射的对象在使用时应该取消 Java 语言访问检査。</li><li>提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true. 使得原本无法访问的私有成员也可以访问</li><li>参数值为 <code>false</code> 则指示反射的对象应该实施 Java 语言访问检査。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的某个方法</span></span><br><span class="line"><span class="comment">        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前方法是可访问的</span></span><br><span class="line">    show.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参</span></span><br><span class="line"><span class="comment">        invoke()的返回值即为对应类中调用的方法的返回值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> show.invoke(person, <span class="string">&quot;CHN&quot;</span>);</span><br><span class="line">    System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************如何调用静态方法*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">showDesc</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">    showDesc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//如果调用的运行时类中的方法没有返回值，则此invoke()返回null</span></span><br><span class="line">    <span class="comment">//Object returnVal = showDesc.invoke(null);</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> showDesc.invoke(Person.class);</span><br><span class="line">    System.out.println(returnVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="调用指定的构造器"><a href="#调用指定的构造器" class="headerlink" title="调用指定的构造器"></a>调用指定的构造器</h5></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Person(String name)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的构造器</span></span><br><span class="line"><span class="comment">        getDeclaredConstructor():参数：指明构造器的参数列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证此构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调用此构造器创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(per);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><blockquote><h5 id="代理设计模式的原理"><a href="#代理设计模式的原理" class="headerlink" title="代理设计模式的原理:"></a>代理设计模式的原理:</h5></blockquote><p>使用一个代理将对象包装起来，然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。</p><blockquote><h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ClothFactory</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NikeClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Nike 生产衣服&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyClothFactory</span> <span class="keyword">implements</span> <span class="title class_">ClothFactory</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ClothFactory factory;<span class="comment">//用被代理类对象进行实例化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ProxyClothFactory</span><span class="params">(ClothFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produceCloth</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些准备工作&quot;</span>);</span><br><span class="line"></span><br><span class="line">        factory.produceCloth();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;代理工厂做一些后续的收尾工作&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建被代理类的对象</span></span><br><span class="line">        <span class="type">ClothFactory</span> <span class="variable">nike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NikeClothFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建代理类的对象</span></span><br><span class="line">        <span class="type">ProxyClothFactory</span> <span class="variable">proxyClothFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyClothFactory</span>(nike);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态代理的缺点：</strong></p><p>① 代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。</p><p>② 每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。</p><blockquote><h5 id="动态代理的特点："><a href="#动态代理的特点：" class="headerlink" title="动态代理的特点："></a>动态代理的特点：</h5></blockquote><p>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</p><p><strong>相比于静态代理的优点：</strong></p><p>抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。</p><blockquote><h5 id="动态代理的实现"><a href="#动态代理的实现" class="headerlink" title="动态代理的实现"></a>动态代理的实现</h5></blockquote><ul><li><p>需要解决的两个主要问题：</p><ul><li><p>问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。</p><p>（通过 <code>Proxy.newProxyInstance()</code> 实现）</p></li><li><p>问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法。</p><p>（通过 <code>InvocationHandler</code> 接口的实现类及其方法 <code>invoke()</code> )</p></li></ul></li><li><p>动态代理相关的API：</p><p>Proxy：专门完成代理的操作类，是所有动态代理类的父类。通过此类为一个或多个接口动态地生成实现类。提供用于创建动态代理类和动态代理对象的静态方法。</p><ul><li><code>static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;...interface)</code> 创建一个动态代理类所对应的  <code>Class</code> 对象</li><li><code>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;...interface, InvocationHandler h)</code> 直接创建一个动态代理对象</li></ul></li><li><p>动态代理实现步骤：</p><ul><li><p>创建一个实现接口 <code>InvocationHandler</code> 的类，它必须实现invoke方法，以完成代理的具体操作。</p></li><li><p>创建被代理类以及接口</p></li><li><p>通过Proxy的静态方法 <code>newProxyInstance(ClassLoader loader, Class&lt;?&gt;...interface, InvocationHandler h)</code> 创建一个接口代理</p></li><li><p>通过代理类的实例调用被代理类的方法</p></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    String <span class="title function_">getBelief</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">implements</span> <span class="title class_">Human</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBelief</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I like eat &quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">要想实现动态代理，需要解决的问题？</span></span><br><span class="line"><span class="comment">问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。</span></span><br><span class="line"><span class="comment">问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建继承了InvocationHandler接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHanlder</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(obj, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中的invoke()的返回值。</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">    <span class="comment">//调用此方法，返回一个代理类的对象。解决问题一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="type">MyInvocationHanlder</span> <span class="variable">hanlder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHanlder</span>();</span><br><span class="line">        hanlder.bind(obj);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),hanlder);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SuperMan</span> <span class="variable">superMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();</span><br><span class="line">        <span class="comment">//proxyInstance:代理类的对象</span></span><br><span class="line">        <span class="type">Human</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">belief</span> <span class="operator">=</span> proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;火锅&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态代理与AOP"><a href="#动态代理与AOP" class="headerlink" title="动态代理与AOP"></a>动态代理与AOP</h4><ul><li><p>使用 <code>Proxy</code> 生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义。通常都是为指定的目标对象生成动态代理。</p></li><li><p>这种动态代理在 <code>AOP</code> 中被称为 <code>AOP</code> 代理，<code>AOP</code> 代理可代替目标对象，<code>AOP</code> 代理包含了目标对象的全部方法。但 <code>AOP</code> 代理中的方法与目标对象的方法存在差异：</p></li><li><p><code>AOP</code> 代理里的方法可以在执行目标方法之前、之后插入一些通用处理</p><p><img src="/../image/JavaPic/AOP.awebp"></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HuntingDog</span> <span class="keyword">implements</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一只猎狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我跑的很快&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通用方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogUtils</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======通用方法一=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;=======通用方法二=======&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态代理实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler1</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">//需要被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">SetTarget</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">DogUtils</span> <span class="variable">dogUtils</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DogUtils</span>();</span><br><span class="line">        <span class="comment">//执行DogUtils对象中的method1</span></span><br><span class="line">        dogUtils.method1();</span><br><span class="line">        <span class="comment">//通过obj对象来调用执行method方法</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="comment">//执行DogUtils对象中的method2</span></span><br><span class="line">        dogUtils.method2();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyProxyFactory1</span> &#123;</span><br><span class="line">    <span class="comment">//为target生成动态代理对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个MyInvocationHandler对象</span></span><br><span class="line">        <span class="type">MyInvocationHandler1</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler1</span>();</span><br><span class="line">        <span class="comment">//为MyInvocationHandler设置target对象</span></span><br><span class="line">        handler.SetTarget(target);</span><br><span class="line">        <span class="comment">//创建返回一个动态代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AOPTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HuntingDog</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) MyProxyFactory1.getProxy(target);</span><br><span class="line">        dog.info();</span><br><span class="line">        dog.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java之Java-8新特性"><a href="#Java之Java-8新特性" class="headerlink" title="Java之Java 8新特性"></a>Java之Java 8新特性</h2><p><strong>Java 8新特性汇总</strong></p><p>![](..&#x2F;image&#x2F;JavaPic&#x2F;Java 8新特性汇总.awebp)</p><p><strong>Java 8的改进</strong></p><ul><li>速度更快</li><li>代码更少（增加了新的语法：Lambda表达式）</li><li>引入强大的 <code>Stream APl</code></li><li>便于并行</li><li>最大化减少空指针异常：<code>Optional</code></li><li><code>Nashorn</code> 引擎，允许在JVM上运行 <code>JS</code> 应用</li><li>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。相比较串行的流，并行的流可以很大程度上提高程序的执行效率。</li><li>Java 8中将并行进行了优化，我们可以很容易的对数据进行并行操作。<code>Stream API</code> 可以声明性地通过 <code>parallel()</code> 与 <code>sequential()</code> 在并行流与顺序流之间进行切换</li></ul><h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><h4 id="Lambda表达式概述"><a href="#Lambda表达式概述" class="headerlink" title="Lambda表达式概述"></a>Lambda表达式概述</h4><p>Lambda 是一个匿名函数，可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使 Java 的语言表达能力得到了提升。</p><h4 id="使用Lambda表达式前后对比"><a href="#使用Lambda表达式前后对比" class="headerlink" title="使用Lambda表达式前后对比"></a>使用Lambda表达式前后对比</h4><p>调用 Runable 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//未使用Lambda表达式的写法</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello Lambda!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    r1.run();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;========================&quot;</span>);</span><br><span class="line">    <span class="comment">//Lamdba表达式写法</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;hi Lambda!&quot;</span>);</span><br><span class="line">    r2.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Comparator接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//未使用Lambda表达式的写法</span></span><br><span class="line">    Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compare1</span> <span class="operator">=</span> com1.compare(<span class="number">12</span>, <span class="number">32</span>);</span><br><span class="line">    System.out.println(compare1);<span class="comment">//-1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Lambda表达式的写法</span></span><br><span class="line">    Comparator&lt;Integer&gt; com2 = (o1,o2) -&gt; Integer.compare(o1,o2);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">compare2</span> <span class="operator">=</span> com2.compare(<span class="number">54</span>, <span class="number">21</span>);</span><br><span class="line">    System.out.println(compare2);<span class="comment">//1</span></span><br><span class="line">    System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法引用</span></span><br><span class="line">    Comparator&lt;Integer&gt; cpm3 = Integer::compareTo;</span><br><span class="line">    <span class="type">int</span> <span class="variable">compare3</span> <span class="operator">=</span> cpm3.compare(<span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">    System.out.println(compare3);<span class="comment">//0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="怎样使用Lambda表达式"><a href="#怎样使用Lambda表达式" class="headerlink" title="怎样使用Lambda表达式"></a>怎样使用Lambda表达式</h4><blockquote><h5 id="Lamdba表达式基本语法"><a href="#Lamdba表达式基本语法" class="headerlink" title="Lamdba表达式基本语法"></a>Lamdba表达式基本语法</h5></blockquote><p>1.举例： <code>(o1,o2) -&gt; Integer.compare(o1,o2);</code></p><p>2.格式：</p><ul><li><code>-&gt;</code> ：lambda 操作符 或 箭头操作符</li><li><code>-&gt;</code> 左边：lambda 形参列表 （其实就是接口中的抽象方法的形参列表）</li><li><code>-&gt;</code> 右边：lambda 体（其实就是重写的抽象方法的方法体）</li></ul><blockquote><h5 id="Lamdba表达式使用（包含六种情况）"><a href="#Lamdba表达式使用（包含六种情况）" class="headerlink" title="Lamdba表达式使用（包含六种情况）"></a>Lamdba表达式使用（包含六种情况）</h5></blockquote><p><strong>语法格式一：无参，有返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> () -&gt; &#123;System.out.println(“hello Lamdba!”)&#125;</span><br></pre></td></tr></table></figure><p><strong>语法格式二：Lamdba需要一个参数，但没有返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = (String str) -&gt; &#123;System.out.println(str)&#125;</span><br></pre></td></tr></table></figure><p><strong>语法格式三：数据类型可省略，因为可由编译器推断得出，称为类型推断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = (str) -&gt; &#123;System.out.println(str)&#125;</span><br></pre></td></tr></table></figure><p><strong>语法格式四：Lamdba若只需要一个参数时，小括号可以省略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con = str -&gt; &#123;System.out.println(str)&#125;</span><br></pre></td></tr></table></figure><p><strong>语法格式五：Lamdba需要两个以上的参数，多条执行语句，并且可以有返回值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt;com = (o1,o1) -&gt; &#123;</span><br><span class="line">Syste.out.println(<span class="string">&quot;Lamdba表达式使用&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(o1,o2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>语法格式六：当Lamdba体只有一条语句时，return和大括号若有，都可以省略</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt;com = (o1,o1) -&gt;Integer.compare(o1,o2);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LamdbaTest2</span> &#123;</span><br><span class="line">    <span class="comment">//语法格式一：无参，无返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//未使用Lambda表达式</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello Lamdba&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        r1.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">r2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi Lamdba&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        r2.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式二：Lambda 需要一个参数，但是没有返回值。</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//未使用Lambda表达式</span></span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;你好啊Lambda！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        Consumer&lt;String&gt; con1 = (String s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">&quot;我是Lambda&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//未使用Lambda表达式</span></span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;你好啊Lambda！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        Consumer&lt;String&gt; con1 = (s) -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">&quot;我是Lambda&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//类型推断，用左边推断右边</span></span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//类型推断，用左边推断右边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//未使用Lambda表达式</span></span><br><span class="line">        Consumer&lt;String&gt; con = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con.accept(<span class="string">&quot;你好啊Lambda！&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        Consumer&lt;String&gt; con1 = s -&gt; &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">&quot;我是Lambda&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//未使用Lambda表达式</span></span><br><span class="line">        Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                System.out.println(o1);</span><br><span class="line">                System.out.println(o2);</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1, o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(com1.compare(<span class="number">23</span>, <span class="number">45</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123;</span><br><span class="line">            System.out.println(o1);</span><br><span class="line">            System.out.println(o2);</span><br><span class="line">            <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(com2.compare(<span class="number">23</span>, <span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//未使用Lambda表达式</span></span><br><span class="line">        Comparator&lt;Integer&gt; com1 = <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1, o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(com1.compare(<span class="number">23</span>, <span class="number">45</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2);</span><br><span class="line"></span><br><span class="line">        System.out.println(com2.compare(<span class="number">23</span>, <span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//未使用Lambda表达式</span></span><br><span class="line">        Consumer&lt;String&gt; con1 = <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        con1.accept(<span class="string">&quot;hi!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s);</span><br><span class="line">        con2.accept(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="Lambda-表达式使用总结"><a href="#Lambda-表达式使用总结" class="headerlink" title="Lambda 表达式使用总结"></a>Lambda 表达式使用总结</h5></blockquote><ul><li><p><code>-&gt;</code> 左边：lambda 形参列表的参数类型可以省略(类型推断)；如果 lambda 形参列表只有一个参数，其一对 <code>()</code> 也可以省略</p></li><li><p><code>-&gt;</code> 右边：lambda 体应该使用一对 <code>&#123;&#125;</code> 包裹；如果 lambda 体只有一条执行语句（可能是 <code>return</code> 语句），省略这一对 <code>&#123;&#125;</code> 和 <code>return</code> 关键字</p></li></ul><h4 id="Lambda表达式总结"><a href="#Lambda表达式总结" class="headerlink" title="Lambda表达式总结"></a>Lambda表达式总结</h4><ul><li><p>Lambda 表达式的本质：作为函数式接口的实例</p></li><li><p>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用 <code>@FunctionalInterface</code> 注解，这样做可以检查它是否是一个函数式接口。</p></li><li><p>因此以前用匿名实现类表示的现在都可以用 Lambda 表达式来写。</p></li></ul><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><h4 id="函数式接口概述"><a href="#函数式接口概述" class="headerlink" title="函数式接口概述"></a>函数式接口概述</h4><ul><li><p>只包含一个抽象方法的接口，称为函数式接口。</p></li><li><p>可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda 表达式抛出一个受检异常（即：非运行时异常），那么该异常需要在目标接口的抽象方法上进行声明）。</p></li><li><p>可以在一个接口上使用 <code>@FunctionalInterface</code> 注解，这样做可以检查它是否是一个函数式接口。同时 <code>javadoc</code> 也会包含一条声明，说明这个接口是一个函数式接口。</p></li><li><p>Lambda 表达式的本质：作为函数式接口的实例</p></li><li><p>在 <code>java.util.function</code> 包下定义了Java 8的丰富的函数式接口</p></li></ul><p><strong>自定义函数式接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java内置函数式接口"><a href="#Java内置函数式接口" class="headerlink" title="Java内置函数式接口"></a>Java内置函数式接口</h4><blockquote><h5 id="四大核心函数式接口"><a href="#四大核心函数式接口" class="headerlink" title="四大核心函数式接口"></a>四大核心函数式接口</h5></blockquote><p><img src="/../image/JavaPic/%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest3</span> &#123;</span><br><span class="line">    <span class="comment">//    消费型接口 Consumer&lt;T&gt;     void accept(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//未使用Lambda表达式</span></span><br><span class="line">        Learn(<span class="string">&quot;java&quot;</span>, <span class="keyword">new</span> <span class="title class_">Consumer</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(String s)</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;学习什么？ &quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="comment">//使用Lambda表达</span></span><br><span class="line">        Learn(<span class="string">&quot;html&quot;</span>, s -&gt; System.out.println(<span class="string">&quot;学习什么？ &quot;</span> + s));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">Learn</span><span class="params">(String s, Consumer&lt;String&gt; stringConsumer)</span> &#123;</span><br><span class="line">        stringConsumer.accept(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    供给型接口 Supplier&lt;T&gt;     T get()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//未使用Lambdabiaodas</span></span><br><span class="line">        Supplier&lt;String&gt; sp = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我能提供东西&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(sp.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">        <span class="comment">//使用Lambda表达</span></span><br><span class="line">        Supplier&lt;String&gt; sp1 = () -&gt; <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我能通过lambda提供东西&quot;</span>);</span><br><span class="line">        System.out.println(sp1.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//函数型接口 Function&lt;T,R&gt;   R apply(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;Tom&quot;</span>, <span class="number">45</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        Function&lt;Employee, String&gt; func1 =e-&gt;e.getName();</span><br><span class="line">        System.out.println(func1.apply(employee));</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用方法引用</span></span><br><span class="line">        Function&lt;Employee,String&gt;func2 = Employee::getName;</span><br><span class="line">        System.out.println(func2.apply(employee));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//断定型接口 Predicate&lt;T&gt;    boolean test(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类</span></span><br><span class="line">        Function&lt;Double, Long&gt; func = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double aDouble)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.round(aDouble);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(func.apply(<span class="number">10.5</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        Function&lt;Double, Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class="line">        System.out.println(func1.apply(<span class="number">12.3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用方法引用</span></span><br><span class="line">        Function&lt;Double,Long&gt;func2 = Math::round;</span><br><span class="line">        System.out.println(func2.apply(<span class="number">12.6</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h5 id="其他函数式接口"><a href="#其他函数式接口" class="headerlink" title="其他函数式接口"></a>其他函数式接口</h5></blockquote><p><img src="/../image/JavaPic/%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3.awebp"></p><h4 id="使用总结"><a href="#使用总结" class="headerlink" title="使用总结"></a>使用总结</h4><blockquote><p><strong>何时使用lambda表达式？</strong></p></blockquote><p>当需要对一个函数式接口实例化的时候，可以使用 lambda 表达式。</p><blockquote><p><strong>何时使用给定的函数式接口？</strong></p></blockquote><p>如果我们开发中需要定义一个函数式接口，首先看看在已有的jdk提供的函数式接口是否提供了能满足需求的函数式接口。如果有，则直接调用即可，不需要自己再自定义了。</p><h3 id="方法的引用"><a href="#方法的引用" class="headerlink" title="方法的引用"></a>方法的引用</h3><blockquote><p>方法引用概述</p></blockquote><p>方法引用可以看做是 Lambda 表达式深层次的表达。换句话说，方法引用就是 Lambda 表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法。</p><blockquote><p>使用情景</p></blockquote><p>当要传递给 Lambda 体的操作，已经实现的方法了，可以使用方法引用！</p><blockquote><p>使用格式</p></blockquote><p><code>类(或对象) :: 方法名</code></p><blockquote><p>使用情况</p></blockquote><ul><li>情况1 对象 <code>::</code> 非静态方法</li><li>情况2 类 <code>::</code> 静态方法</li><li>情况3 类 <code>::</code> 非静态方法</li></ul><blockquote><p>使用要求</p></blockquote><ul><li><p>要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同！（针对于情况1和情况2）</p></li><li><p>当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数(或无参数)时：<code>ClassName::methodName</code>（针对于情况3）</p></li></ul><blockquote><p>使用建议</p></blockquote><p>如果给函数式接口提供实例，恰好满足方法引用的使用情境，就可以考虑使用方法引用给函数式接口提供实例。如果不熟悉方法引用，那么还可以使用 lambda 表达式</p><blockquote><p>例子</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodRefTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况一：对象 :: 实例方法</span></span><br><span class="line">    <span class="comment">//Consumer中的void accept(T t)</span></span><br><span class="line">    <span class="comment">//PrintStream中的void println(T t)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用Lambda表达</span></span><br><span class="line">        Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class="line">        con1.accept(<span class="string">&quot;中国&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用方法引用</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> System.out;</span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">con2</span> <span class="operator">=</span> ps::println;</span><br><span class="line">        con2.accept(<span class="string">&quot;China&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Supplier中的T get()</span></span><br><span class="line">    <span class="comment">//Employee中的String getName()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用Lambda表达</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;Bruce&quot;</span>, <span class="number">34</span>, <span class="number">600</span>);</span><br><span class="line">        Supplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class="line">        System.out.println(sup1.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用方法引用</span></span><br><span class="line">        <span class="type">Supplier</span> <span class="variable">sup2</span> <span class="operator">=</span> emp::getName;</span><br><span class="line">        System.out.println(sup2.get());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况二：类 :: 静态方法</span></span><br><span class="line">    <span class="comment">//Comparator中的int compare(T t1,T t2)</span></span><br><span class="line">    <span class="comment">//Integer中的int compare(T t1,T t2)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用Lambda表达</span></span><br><span class="line">        Comparator&lt;Integer&gt; com1 = (t1, t2) -&gt; Integer.compare(t1, t2);</span><br><span class="line">        System.out.println(com1.compare(<span class="number">32</span>, <span class="number">45</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用方法引用</span></span><br><span class="line">        Comparator&lt;Integer&gt; com2 = Integer::compareTo;</span><br><span class="line">        System.out.println(com2.compare(<span class="number">43</span>, <span class="number">34</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Function中的R apply(T t)</span></span><br><span class="line">    <span class="comment">//Math中的Long round(Double d)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类</span></span><br><span class="line">        Function&lt;Double, Long&gt; func = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double aDouble)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.round(aDouble);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(func.apply(<span class="number">10.5</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        Function&lt;Double, Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class="line">        System.out.println(func1.apply(<span class="number">12.3</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用方法引用</span></span><br><span class="line">        Function&lt;Double, Long&gt; func2 = Math::round;</span><br><span class="line">        System.out.println(func2.apply(<span class="number">12.6</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况三：类 :: 实例方法</span></span><br><span class="line">    <span class="comment">// Comparator中的int comapre(T t1,T t2)</span></span><br><span class="line">    <span class="comment">// String中的int t1.compareTo(t2)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        Comparator&lt;String&gt; com1 = (s1, s2) -&gt; s1.compareTo(s2);</span><br><span class="line">        System.out.println(com1.compare(<span class="string">&quot;abd&quot;</span>, <span class="string">&quot;aba&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用方法引用</span></span><br><span class="line">        Comparator&lt;String&gt; com2 = String::compareTo;</span><br><span class="line">        System.out.println(com2.compare(<span class="string">&quot;abd&quot;</span>, <span class="string">&quot;abc&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//BiPredicate中的boolean test(T t1, T t2);</span></span><br><span class="line">    <span class="comment">//String中的boolean t1.equals(t2)</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        BiPredicate&lt;String, String&gt; pre1 = (s1, s2) -&gt; s1.equals(s2);</span><br><span class="line">        System.out.println(pre1.test(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用方法引用</span></span><br><span class="line">        BiPredicate&lt;String, String&gt; pre2 = String::equals;</span><br><span class="line">        System.out.println(pre2.test(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abd&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function中的R apply(T t)</span></span><br><span class="line">    <span class="comment">// Employee中的String getName();</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用Lambda表达式</span></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;Tom&quot;</span>, <span class="number">45</span>, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        Function&lt;Employee, String&gt; func1 =e-&gt;e.getName();</span><br><span class="line">        System.out.println(func1.apply(employee));</span><br><span class="line">        System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用方法引用</span></span><br><span class="line">        Function&lt;Employee,String&gt;func2 = Employee::getName;</span><br><span class="line">        System.out.println(func2.apply(employee));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器和数组的引用"><a href="#构造器和数组的引用" class="headerlink" title="构造器和数组的引用"></a>构造器和数组的引用</h3><h4 id="使用格式"><a href="#使用格式" class="headerlink" title="使用格式"></a>使用格式</h4><p>方法引用：类名 <code>::new</code></p><p>数组引用：数组类型 <code>[] :: new</code></p><h4 id="使用要求"><a href="#使用要求" class="headerlink" title="使用要求"></a>使用要求</h4><blockquote><p>构造器引用</p></blockquote><p>和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致。抽象方法的返回值类型即为构造器所属的类的类型</p><blockquote><p>数组引用</p></blockquote><p>可以把数组看做是一个特殊的类，则写法与构造器引用一致</p><h4 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h4><blockquote><p>构造器引用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器引用</span></span><br><span class="line"><span class="comment">//Supplier中的T get()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//使用匿名内部类</span></span><br><span class="line">    Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(sup.get());</span><br><span class="line">    <span class="comment">//使用Lambda表达式</span></span><br><span class="line">    System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">    Supplier&lt;Employee&gt; sup1 = () -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;Tom&quot;</span>, <span class="number">43</span>, <span class="number">13333</span>);</span><br><span class="line">    System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用方法引用</span></span><br><span class="line">    Supplier&lt;Employee&gt; sup2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//使用Lambda表达式</span></span><br><span class="line">    Function&lt;Integer, Employee&gt; func1 = id -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id);</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> func1.apply(<span class="number">1001</span>);</span><br><span class="line">    System.out.println(employee);</span><br><span class="line">    System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用方法引用</span></span><br><span class="line">    Function&lt;Integer, Employee&gt; func2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee1</span> <span class="operator">=</span> func2.apply(<span class="number">1002</span>);</span><br><span class="line">    System.out.println(employee1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BiFunction中的R apply(T t,U u)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//使用Lambda表达式</span></span><br><span class="line">    BiFunction&lt;Integer, String, Employee&gt; func1 = (id, name) -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id, name);</span><br><span class="line">    System.out.println(func1.apply(<span class="number">1001</span>, <span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用方法引用</span></span><br><span class="line">    BiFunction&lt;Integer, String, Employee&gt; func2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(func2.apply(<span class="number">1002</span>, <span class="string">&quot;Jarry&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组引用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组引用</span></span><br><span class="line"><span class="comment">//Function中的R apply(T t)</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">    Function&lt;Integer, String[]&gt; func1 = length -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[length];</span><br><span class="line">    String[] arr1 = func1.apply(<span class="number">5</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用方法引用</span></span><br><span class="line">    Function&lt;Integer,String[]&gt;func2=String[]::<span class="keyword">new</span>;</span><br><span class="line">    String[] arr2 = func2.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h3><h4 id="StreamAPI概述"><a href="#StreamAPI概述" class="headerlink" title="StreamAPI概述"></a>StreamAPI概述</h4><ul><li><code>Stream</code> 关注的是对数据的运算，与 <code>CPU</code> 打交道;集合关注的是数据的存储，与内存打交道;</li><li>Java 8 提供了一套 <code>api</code> ，使用这套 <code>api</code> 可以对内存中的数据进行过滤、排序、映射、归约等操作。类似于 <code>sql</code> 对数据库中表的相关操作。</li><li><code>Stream</code> 是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。<strong>“集合讲的是数据， Stream讲的是计算！”</strong></li></ul><p><strong>使用注意点:</strong></p><p>① <code>Stream</code> 自己不会存储元素。</p><p>② <code>Stream</code> 不会改变源对象。相反，他们会返回一个持有结果的新 <code>Stream</code>。</p><p>③ <code>Stream</code> 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</p><h4 id="StreamAPI使用流程"><a href="#StreamAPI使用流程" class="headerlink" title="StreamAPI使用流程"></a>StreamAPI使用流程</h4><p>① Stream 的实例化</p><p>② 一系列的中间操作（过滤、映射、…)</p><p>③ 终止操作</p><p><img src="/../image/JavaPic/StreamAPI%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B.awebp"></p><p><strong>使用流程中的注意点：</strong></p><ul><li>一个中间操作链，对数据源的数据进行处理</li><li>一旦执行终止操作，就执行中间操作链，并产生结果。之后，不会再被使用</li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><blockquote><p>步骤一 创建 Stream</p></blockquote><p><em>创建方式一：通过集合</em></p><p>Java 8的 <code>Collection</code> 接口被扩展，提供了两个获取流的方法：</p><ul><li><code>default Stream\&lt;E&gt; stream()</code> : 返回一个顺序流</li><li><code>default Stream\&lt;E&gt; parallelStream()</code> : 返回一个并行流</li></ul><p><em>创建方式二：通过数组</em></p><p>Java 8中的 <code>Arrays</code> 的静态方法 <code>stream()</code> 可以获取数组流</p><ul><li>调用 <code>Arrays</code> 类的 <code>static\&lt;T&gt; Stream\&lt;T&gt; stream(T[] array)</code>: 返回一个流</li><li>重载形式，能够处理对应基本类型的数组：<ul><li><code>public static IntStream stream（int[] array）</code></li><li><code>public static LongStream stream（long[] array）</code></li><li><code>public static DoubleStream stream（double[] array）</code></li></ul></li></ul><p><em>创建方式三：通过Stream的of()方法</em></p><p>可以调用Stream类静态方法of()，通过显示值创建一个流。可以用于接收任意数量的参数</p><ul><li><code>public static \&lt;T&gt;Stream\&lt;T&gt; of(T...values)</code>:返回一个流</li></ul><p><em>创建方式四：创建无限流</em></p><ul><li>迭代: <code>public static\&lt;T&gt; Stream\&lt;T&gt; iterate(final T seed, final UnaryOperator\&lt;T&gt; f)</code></li><li>生成: <code>public static\&lt;T&gt; Stream\&lt;T&gt; generate(Supplier\&lt;T&gt; s)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamAPITest1</span> &#123;</span><br><span class="line">    <span class="comment">//创建 Stream方式一：通过集合</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">        <span class="comment">//efault Stream&lt;E&gt; stream() : 返回一个顺序流</span></span><br><span class="line">        Stream&lt;Employee&gt; stream = employees.stream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span></span><br><span class="line">        Stream&lt;Employee&gt; employeeStream = employees.parallelStream();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Stream方式二：通过数组</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arrs = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//调用Arrays类的static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class="line">        <span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arrs);</span><br><span class="line"></span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        <span class="type">Employee</span> <span class="variable">e2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1002</span>, <span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        Employee[] employees = &#123;e1, e2&#125;;</span><br><span class="line">        Stream&lt;Employee&gt; stream1 = Arrays.stream(employees);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Stream方式三：通过Stream的of()</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">45</span>, <span class="number">65</span>, <span class="number">76</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Stream方式四：创建无限流</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代</span></span><br><span class="line">        <span class="comment">//public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</span></span><br><span class="line">        <span class="comment">//遍历前10个偶数</span></span><br><span class="line">        Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成</span></span><br><span class="line">        <span class="comment">//public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</span></span><br><span class="line">        Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>步骤二 中间操作</p></blockquote><p>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为<strong>惰性求值</strong></p><p><strong>筛选与切片</strong></p><p><img src="/../image/JavaPic/**%E7%AD%9B%E9%80%89%E4%B8%8E%E5%88%87%E7%89%87**.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1-筛选与切片,注意执行终止操作后，Stream流就被关闭了，使用时需要再次创建Stream流</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    <span class="comment">//filter(Predicate p)——接收 Lambda ， 从流中排除某些元素。</span></span><br><span class="line">    Stream&lt;Employee&gt; employeeStream = employees.stream();</span><br><span class="line">    <span class="comment">//练习：查询员工表中薪资大于7000的员工信息</span></span><br><span class="line">    employeeStream.filter(e -&gt; e.getSalary() &gt; <span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//limit(n)——截断流，使其元素不超过给定数量。</span></span><br><span class="line">    employeeStream.limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</span></span><br><span class="line">    employeeStream.skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class="line">    employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1010</span>,<span class="string">&quot;刘庆东&quot;</span>,<span class="number">56</span>,<span class="number">8000</span>));</span><br><span class="line">    employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1010</span>,<span class="string">&quot;刘庆东&quot;</span>,<span class="number">56</span>,<span class="number">8000</span>));</span><br><span class="line">    employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1010</span>,<span class="string">&quot;刘庆东&quot;</span>,<span class="number">56</span>,<span class="number">8000</span>));</span><br><span class="line">    employees.add(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1010</span>,<span class="string">&quot;刘庆东&quot;</span>,<span class="number">56</span>,<span class="number">8000</span>));</span><br><span class="line"></span><br><span class="line">    employeeStream.distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>映射</strong></p><p><img src="/../image/JavaPic/%E6%98%A0%E5%B0%84.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2-映射</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line">    <span class="comment">//map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class="line">    list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//练习1：获取员工姓名长度大于3的员工的姓名。</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    Stream&lt;String&gt; nameStream = employees.stream().map(Employee::getName);</span><br><span class="line">    nameStream.filter(name -&gt; name.length() &gt;<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//练习2：使用map()中间操作实现flatMap()中间操作方法</span></span><br><span class="line">    Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest2::fromStringToStream);</span><br><span class="line">    streamStream.forEach(s -&gt;&#123;</span><br><span class="line">        s.forEach(System.out::println);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</span></span><br><span class="line">    Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest2::fromStringToStream);</span><br><span class="line">    characterStream.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将字符串中的多个字符构成的集合转换为对应的Stream的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt;fromStringToStream(String str)&#123;</span><br><span class="line">    ArrayList&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Character c :</span><br><span class="line">         str.toCharArray()) &#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.stream();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//map()和flatMap()方法类似于List中的add()和addAll()方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Object&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list1.add(<span class="number">1</span>);</span><br><span class="line">    list1.add(<span class="number">2</span>);</span><br><span class="line">    list1.add(<span class="number">3</span>);</span><br><span class="line">    list1.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Object&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list2.add(<span class="number">5</span>);</span><br><span class="line">    list2.add(<span class="number">6</span>);</span><br><span class="line">    list2.add(<span class="number">7</span>);</span><br><span class="line">    list2.add(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    list1.add(list2);</span><br><span class="line">    System.out.println(list1);<span class="comment">//[1, 2, 3, 4, [5, 6, 7, 8]]</span></span><br><span class="line">    list1.addAll(list2);</span><br><span class="line">    System.out.println(list1);<span class="comment">//[1, 2, 3, 4, [5, 6, 7, 8], 5, 6, 7, 8]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>排序</strong></p><p><img src="/../image/JavaPic/%E6%8E%92%E5%BA%8F.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3-排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//sorted()——自然排序</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">65</span>, <span class="number">32</span>);</span><br><span class="line">    list.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抛异常，原因:Employee没有实现Comparable接口</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    employees.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sorted(Comparator com)——定制排序</span></span><br><span class="line">    List&lt;Employee&gt; employees1 = EmployeeData.getEmployees();</span><br><span class="line">    employees1.stream().sorted((e1,e2)-&gt;&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ageValue</span> <span class="operator">=</span> Integer.compare(e1.getAge(), e2.getAge());</span><br><span class="line">        <span class="keyword">if</span> (ageValue != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ageValue;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -Double.compare(e1.getSalary(),e2.getSalary());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>步骤三 终止操作</p></blockquote><ul><li>终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：<code>List</code>、 <code>Integer</code>，甚至是 <code>void</code></li><li>流进行了终止操作后，不能再次使用。</li></ul><p><strong>匹配与查找</strong></p><p><img src="/../image/JavaPic/%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%9F%A5%E6%89%BE-1.awebp"></p><p><img src="/../image/JavaPic/%E5%8C%B9%E9%85%8D%E4%B8%8E%E6%9F%A5%E6%89%BE-2.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1-匹配与查找</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//allMatch(Predicate p)——检查是否匹配所有元素。</span></span><br><span class="line">    <span class="comment">//练习：是否所有的员工的年龄都大于18</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> employees.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">    System.out.println(allMatch);</span><br><span class="line">    <span class="comment">//anyMatch(Predicate p)——检查是否至少匹配一个元素。</span></span><br><span class="line">    <span class="comment">//练习：是否存在员工的工资大于 5000</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> employees.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class="number">5000</span>);</span><br><span class="line">    System.out.println(anyMatch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//noneMatch(Predicate p)——检查是否没有匹配的元素。</span></span><br><span class="line">    <span class="comment">//练习：是否存在员工姓“雷”</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">noneMatch</span> <span class="operator">=</span> employees.stream().noneMatch(e -&gt; e.getName().startsWith(<span class="string">&quot;雷&quot;</span>));</span><br><span class="line">    System.out.println(noneMatch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//findFirst——返回第一个元素</span></span><br><span class="line">    Optional&lt;Employee&gt; first = employees.stream().findFirst();</span><br><span class="line">    System.out.println(first);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//findAny——返回当前流中的任意元素</span></span><br><span class="line">    Optional&lt;Employee&gt; employee = employees.parallelStream().findAny();</span><br><span class="line">    System.out.println(employee);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    <span class="comment">// count——返回流中元素的总个数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> employees.stream().filter(e -&gt; e.getSalary()&gt;<span class="number">5000</span>).count();</span><br><span class="line">    System.out.println(count);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//max(Comparator c)——返回流中最大值</span></span><br><span class="line">    <span class="comment">//练习：返回最高的工资</span></span><br><span class="line">    Stream&lt;Double&gt; salaryStream = employees.stream().map(e -&gt; e.getSalary());</span><br><span class="line">    Optional&lt;Double&gt; maxSalary = salaryStream.max(Double::compareTo);</span><br><span class="line">    System.out.println(maxSalary);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//min(Comparator c)——返回流中最小值</span></span><br><span class="line">    <span class="comment">//练习：返回最低工资的员工</span></span><br><span class="line">    Optional&lt;Double&gt; minSalary = employees.stream().map(e -&gt; e.getSalary()).min(Double::compareTo);</span><br><span class="line">    System.out.println(minSalary);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//forEach(Consumer c)——内部迭代</span></span><br><span class="line">    employees.stream().forEach(System.out::println);</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//使用集合的遍历操作</span></span><br><span class="line">    employees.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>归约</strong></p><p><img src="/../image/JavaPic/%E5%BD%92%E7%BA%A6.awebp"></p><p>备注：<code>map</code> 和 <code>reduce</code> 的连接通常称为 <code>map-reduce</code> 模式，因 Google 用它来进行网络搜索而出名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2-归约</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值。返回 T</span></span><br><span class="line">    <span class="comment">//练习1：计算1-10的自然数的和</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt;</span></span><br><span class="line">    <span class="comment">//练习2：计算公司所有员工工资的总和</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    Optional&lt;Double&gt; sumSalary = employees.stream().map(e -&gt; e.getSalary()).reduce(Double::sum);</span><br><span class="line">    System.out.println(sumSalary);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>收集</strong></p><p><img src="/../image/JavaPic/%E6%94%B6%E9%9B%86-1.awebp"></p><p><code>Collector</code> 接口中方法的实现决定了如何对流执行收集的操作（如收集到 <code>List</code>、<code>Set</code>、<code>Map</code>）</p><p><code>Collectors</code> 实用类提供了很多静态方法，可以方便地创建常见收集器实例具体方法与实例如下表：</p><p><img src="/../image/JavaPic/%E6%94%B6%E9%9B%86-2.awebp"></p><p><img src="/../image/JavaPic/%E6%94%B6%E9%9B%86-3.awebp"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3-收集</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//collect(Collector c)——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class="line">    <span class="comment">//练习1：查找工资大于6000的员工，结果返回为一个List或Set</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    List&lt;Employee&gt; employeeList = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    employeeList.forEach(System.out::println);</span><br><span class="line">    System.out.println();</span><br><span class="line">    Set&lt;Employee&gt; employeeSet = employees.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>).collect(Collectors.toSet());</span><br><span class="line">    employeeSet.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Optional类的使用"><a href="#Optional类的使用" class="headerlink" title="Optional类的使用"></a>Optional类的使用</h3><h4 id="Optional类的概述"><a href="#Optional类的概述" class="headerlink" title="Optional类的概述"></a>Optional类的概述</h4><ul><li><p>为了解决 java 中的空指针问题而生！</p></li><li><p><code>Optional&lt;T&gt; 类(java.util.Optional)</code> 是一个容器类，它可以保存类型 <code>T</code> 的值，代表这个值存在。或者仅仅保存 <code>null</code>，表示这个值不存在。原来用 <code>null</code> 表示一个值不存在，现在 <code>Optional</code> 可以更好的表达这个概念。并且可以避免空指针异常。</p></li></ul><h4 id="Optional类提供的方法"><a href="#Optional类提供的方法" class="headerlink" title="Optional类提供的方法"></a>Optional类提供的方法</h4><p><code>Optional</code> 类提供了很多方法，可以不用再现实的进行空值检验。</p><blockquote><h5 id="创建-Optional-类对象的方法"><a href="#创建-Optional-类对象的方法" class="headerlink" title="创建 Optional 类对象的方法"></a>创建 Optional 类对象的方法</h5></blockquote><ul><li><code>Optional.of(T t)</code> : 创建一个 <code>Optional</code> 实例，<code>t</code> 必须非空；</li><li><code>Optional.empty()</code> : 创建一个空的 <code>Optional</code> 实例</li><li><code>Optional.ofNullable(T t)</code>：<code>t</code> 可以为 <code>null</code></li></ul><blockquote><h5 id="判断Optional容器是否包含对象"><a href="#判断Optional容器是否包含对象" class="headerlink" title="判断Optional容器是否包含对象"></a>判断Optional容器是否包含对象</h5></blockquote><ul><li><code>boolean isPresent()</code>：判断是否包含对象</li><li><code>void ifPresent(Consumer&lt;? super T&gt; consumer)</code>：如果有值，就执行 <code>Consumer</code> 接口的实现代码，并且该值会作为参数传给它。</li></ul><blockquote><h5 id="获取-Optional-容器的对象"><a href="#获取-Optional-容器的对象" class="headerlink" title="获取 Optional 容器的对象"></a>获取 Optional 容器的对象</h5></blockquote><ul><li><p><code>T get()</code>：如果调用对象包含值，返回该值，否则抛异常</p></li><li><p><code>T orElse(T other)</code>：如果有值则将其返回，否则返回指定的 <code>other</code> 对象</p></li><li><p><code>T orElseGet(Supplier&lt;? extends t&gt; other)</code>：如果有值则将其返回，否则返回由 <code>Supplier</code> 接口实现提供的对象。</p></li><li><p><code>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code>：如果有值则将其返回，否则抛出由 <code>Supplier</code> 接口实现提供的异常。</p></li></ul><blockquote><h5 id="搭配使用"><a href="#搭配使用" class="headerlink" title="搭配使用"></a>搭配使用</h5></blockquote><ul><li><code>of()</code> 和 <code>get()</code> 方法搭配使用，明确对象非空</li><li><code>ofNullable()</code> 和 <code>orElse()</code> 搭配使用，不确定对象非空</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//empty():创建的Optional对象内部的value = null</span></span><br><span class="line">        Optional&lt;Object&gt; op1 = Optional.empty();</span><br><span class="line">        <span class="keyword">if</span> (!op1.isPresent())&#123;<span class="comment">//Optional封装的数据是否包含数据</span></span><br><span class="line">            System.out.println(<span class="string">&quot;数据为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(op1);</span><br><span class="line">        System.out.println(op1.isPresent());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果Optional封装的数据value为空，则get()报错。否则，value不为空时，返回value.</span></span><br><span class="line">        System.out.println(op1.get());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//        str = null;</span></span><br><span class="line">        <span class="comment">//of(T t):封装数据t生成Optional对象。要求t非空，否则报错。</span></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.of(str);</span><br><span class="line">        <span class="comment">//get()通常与of()方法搭配使用。用于获取内部的封装的数据value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> op1.get();</span><br><span class="line">        System.out.println(str1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span><span class="string">&quot;Beijing&quot;</span>;</span><br><span class="line">        str = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//ofNullable(T t) ：封装数据t赋给Optional内部的value。不要求t非空</span></span><br><span class="line">        Optional&lt;String&gt; op1 = Optional.ofNullable(str);</span><br><span class="line">        System.out.println(op1);</span><br><span class="line">        <span class="comment">//orElse(T t1):如果Optional内部的value非空，则返回此value值。如果</span></span><br><span class="line">        <span class="comment">//value为空，则返回t1.</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> op1.orElse(<span class="string">&quot;shanghai&quot;</span>);</span><br><span class="line">        System.out.println(str2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>Optional</code> 类避免产生空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GirlBoyOptionalTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用原始方法进行非空检验</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGrilName1</span><span class="params">(Boy boy)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (boy != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> boy.getGirl();</span><br><span class="line">            <span class="keyword">if</span> (girl != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> girl.getName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用Optional类的getGirlName()进行非空检验</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGirlName2</span><span class="params">(Boy boy)</span>&#123;</span><br><span class="line">        Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class="line">        <span class="comment">//此时的boy1一定非空,boy为空是返回“迪丽热巴”</span></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">boy1</span> <span class="operator">=</span> boyOptional.orElse(<span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;迪丽热巴&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> boy1.getGirl();</span><br><span class="line">        <span class="comment">//girl1一定非空,girl为空时返回“古力娜扎”</span></span><br><span class="line">        Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class="line">        <span class="type">Girl</span> <span class="variable">girl1</span> <span class="operator">=</span> girlOptional.orElse(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;古力娜扎&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> girl1.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试手动写的控制检测</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(getGrilName1(boy));</span><br><span class="line"></span><br><span class="line">        boy = <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">        System.out.println(getGrilName1(boy));</span><br><span class="line"></span><br><span class="line">        boy = <span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;杨幂&quot;</span>));</span><br><span class="line">        System.out.println(getGrilName1(boy));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试用Optional类写的控制检测</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(getGirlName2(boy));</span><br><span class="line"></span><br><span class="line">        boy = <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">        System.out.println(getGirlName2(boy));</span><br><span class="line"></span><br><span class="line">        boy = <span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;杨幂&quot;</span>));</span><br><span class="line">        System.out.println(getGirlName2(boy));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对反射的支持增强"><a href="#对反射的支持增强" class="headerlink" title="对反射的支持增强"></a>对反射的支持增强</h3><p>提高了创建对象、对象赋值和反射创建对象的时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testReflection</span> &#123;</span><br><span class="line">    <span class="comment">// 循环次数10亿次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">loopCnt</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">// 输出jdk版本</span></span><br><span class="line">        System.out.println(<span class="string">&quot;java version is&quot;</span> + System.getProperty(<span class="string">&quot;java.version&quot;</span>));</span><br><span class="line">        creatNewObject();</span><br><span class="line">        optionObject();</span><br><span class="line">        reflectCreatObject();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// person对象</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次创建新对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">creatNewObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopCnt; i++) &#123;</span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">            person.setAge(<span class="number">30</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;循环十亿次创建对象所需的时间：&quot;</span> + (endTime - startTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为同一个对象赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">optionObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopCnt; i++) &#123;</span><br><span class="line">            p.setAge(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;循环十亿次为同一对象赋值所需的时间：&quot;</span> + (endTime - startTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射创建对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reflectCreatObject</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Class&lt;Person&gt; personClass = Person.class;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> personClass.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">setAge</span> <span class="operator">=</span> personClass.getMethod(<span class="string">&quot;setAge&quot;</span>, Integer.class);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; loopCnt; i++) &#123;</span><br><span class="line">            setAge.invoke(person, <span class="number">90</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;循环十亿次反射创建对象所需的时间：&quot;</span> + (endTime - startTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译级别为JDK8时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java version is 1.8.0_201</span><br><span class="line">循环十亿次创建对象所需的时间：9</span><br><span class="line">循环十亿次为同一对象赋值所需的时间：59</span><br><span class="line">循环十亿次反射创建对象所需的时间：2622</span><br></pre></td></tr></table></figure><p><strong>编译级别为JDK7时</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java version is 1.7</span><br><span class="line">循环十亿次创建对象所需的时间：6737</span><br><span class="line">循环十亿次为同一对象赋值所需的时间：3394</span><br><span class="line">循环十亿次反射创建对象所需的时间：293603</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring5-笔记</title>
      <link href="/2024/04/13/Spring5/"/>
      <url>/2024/04/13/Spring5/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-概述"><a href="#Spring-概述" class="headerlink" title="Spring 概述"></a>Spring 概述</h1><p><img src="/../image/Spring5Pic/Spring%E6%A6%82%E8%BF%B0.png"></p><h2 id="Spring-简介"><a href="#Spring-简介" class="headerlink" title="Spring 简介"></a>Spring 简介</h2><ul><li>春天 ：给软件行业带来春天</li><li>2002 年，Rod Johnson 首次推出了 Spring 的框架雏形 interface21 框架</li><li>2004 年 3.24，Spring 框架以 interface21 为基础，经过重新设计，发布了 1.0 正式版</li><li>Rod Johnson 是悉尼大学音乐学博士</li><li>Spring 理念：使现有的技术更加实用，大杂烩，整合了现有的技术框架</li></ul><p>官网 : <a href="http://spring.io/">http://spring.io/</a></p><p>官方下载地址 : <a href="https://repo.spring.io/libs-release-local/org/springframework/spring/">https://repo.spring.io/libs-release-local/org/springframework/spring/</a></p><p>GitHub : <a href="https://github.com/spring-projects">https://github.com/spring-projects</a></p><h2 id="Spring-优点"><a href="#Spring-优点" class="headerlink" title="Spring 优点"></a>Spring 优点</h2><ul><li>Spring 是一个开源免费的框架、容器</li><li>Spring 是一个轻量级的、非侵入式的框架</li><li>IOC（控制反转）、AOP（面向切面）</li><li>支持事务与框架</li></ul><p>总结：<strong>Spring 是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器（框架）</strong></p><h2 id="Spring-的组成"><a href="#Spring-的组成" class="headerlink" title="Spring 的组成"></a>Spring 的组成</h2><p><img src="/../image/Spring5Pic/Spring%E7%BB%84%E6%88%90.png"><br>Spring 框架是一个分层结构，由 7 个定义良好的接口组成。Spring 模块构建在核心容器之上，核心容器定义了创建、配置和管理 bean 的方式</p><p><img src="/../image/Spring5Pic/Spring7%E4%B8%AA%E6%A8%A1%E5%9D%97.png"></p><p>组成 Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现，每个模块的功能如下：</p><ul><li><strong>核心容器</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 <code>BeanFactory</code>，它是工厂模式的实现。<code>BeanFactory</code> 使用控制反转（IOC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</li><li>Spring 上下文：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</li><li>Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向切面的编程功能 , 集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理任何支持 AOP 的对象。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖组件，就可以将声明性事务管理集成到应用程序中。</li><li>Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</li><li>Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</li><li>Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</li><li>Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>Spring Boot 与 Spring Cloud</p><ul><li>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于 Spring Boot 快速开发单个微服务</li><li>Spring Cloud 是基于 Spring Boot 实现的</li><li>Spring Boot 专注于快速、方便继承的单个微服务个体，Spring Cloud 关注全局的服务治理框架</li><li>Spring Boot 使用了约束优于配置的理念，很多集成方案已经自动选择好了，能不配置就不配置，Spring Cloud 很大一部分是基于 Spring Boot 实现的，Spring Boot 可以离开 Spring Cloud 独立开发项目，但 Spring Cloud 不能离开 Spring Boot，两者是以来关系</li><li>Spring Boot 在 Spring Cloud 中起到承上启下的作用，如果学习 Spring Cloud 必须学习 Spring Boot<br><img src="/../image/Spring5Pic/Spring%E6%8B%93%E5%B1%95.png"></li></ul><h1 id="IOC-基础"><a href="#IOC-基础" class="headerlink" title="IOC 基础"></a>IOC 基础</h1><p>新建一个空白的 maven 项目</p><h2 id="分析实现"><a href="#分析实现" class="headerlink" title="分析实现"></a>分析实现</h2><p>先写一个 UserDao 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Dao 的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取用户数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>UserService 的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>service 的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">UserService</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    service.getUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>———-修改之后———</p><p>增加一个 UserDao 实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoMySqlImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MySql获取用户数据&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果想要使用这个类，就要修改 service 实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoMySqlImpl</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果要增加许多个 UserDao 的实现类，这种就要修改大量代码，耦合性太高</p><p>解决方法：<br>在需要用到 UserDao 实现类的地方，不在具体的实现类，而是留出一个接口，利用 set 将每次需要的实现类传给 service，由 service 实现类传回选择的功能</p><p>修改的 service 实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">// 利用set实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">UserServiceImpl</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    service.setUserDao( <span class="keyword">new</span> <span class="title class_">UserDaoMySqlImpl</span>() );</span><br><span class="line">    service.getUser();</span><br><span class="line">    <span class="comment">//那我们现在又想用Oracle去实现呢</span></span><br><span class="line">    service.setUserDao( <span class="keyword">new</span> <span class="title class_">UserDaoOracleImpl</span>() );</span><br><span class="line">    service.getUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>个人理解：其实就是原先由客户提出需求，开发者接收需求，根据需求修改代码将对应的功能传给客户，主动权在开发者这里； 现在是用户提出的需求可以直接返回功能，主动权在客户。相当于有没有售货员的区别</p><h2 id="IOC-本质"><a href="#IOC-本质" class="headerlink" title="IOC 本质"></a>IOC 本质</h2><p><strong>控制反转 IOC（Inversion of Control），是一种设计思想，DI（依赖注入）是实现 IOC 的一种方法</strong>。也有人认为 DI 知识 IOC 的另一种说法，没有 IOC 的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建对程序自己控制。控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是，获得依赖对象的方式反转了<br><img src="/../image/Spring5Pic/Spring-IOC.png"><br>Spring 容器在初始化时先读取配置文件，根据配置文件或者元数据创建与组织对象存入容器中，程序使用时再从 IOC 容器中取出需要的对象<br><img src="/../image/Spring5Pic/Spring-IOC%E5%9B%BE%E8%A7%A3.png"><br>采用 XML 方式配置 Bean 的时候，Bean 的定义信息时和实现分离的，而采用注解的方式可以把两者合为一体，Bean 的定义信息直接一注解的方式定义在是啊先类中，从而达到零配置的目的</p><p><strong>控制反转是一种通过描述（XML 或注解）并通过第三方去生产或获取特定对象的方式。在 Spring 中实现控制反转的是 IOC 容器，他的实现方法是依赖注入（Dependency Injection，DI）。</strong></p><h1 id="Hello-Spring"><a href="#Hello-Spring" class="headerlink" title="Hello Spring"></a>Hello Spring</h1><h2 id="导入-jar-包"><a href="#导入-jar-包" class="headerlink" title="导入 jar 包"></a>导入 jar 包</h2><p>注：Spring 需要导入 commons-logging 进行日志记录，利用 maven 可以自动下载对应的依赖项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>Hello 的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello,&quot;</span>+ name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写 spring 文件，bean.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean就是java对象 , 由Spring创建和管理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//解析beans.xml文件 , 生成管理相应的Bean对象</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//getBean : 参数即为spring配置文件中bean的id .</span></span><br><span class="line">    <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello) context.getBean(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    hello.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul><li>hello 对象是谁创建的？—由 Spring 创建</li><li>hello 对象的属性怎么设置？—由 Spring 容器设置<br>这个过程就叫做控制反转</li><li>控制：谁来控制对象的创建，传统应用程序的对象是由程序本身控制创建的，使用 Spring 后，对象由 Spring 进行创建，存储在 spring 容器中</li><li>反转：程序本身不创建对象，而变成被动的接收对象</li></ul><p>依赖注入：利用 set 方法进行注入</p><p>IOC 是一种编程思想，由主动的编程变为被动的接收<br>可以通过 newClassPathXmlApplicationContext 去浏览底层源码</p><h2 id="修改案例"><a href="#修改案例" class="headerlink" title="修改案例"></a>修改案例</h2><p>XML 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;MysqlImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.impl.UserDaoMySqlImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;OracleImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.impl.UserDaoOracleImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--引用另外一个bean , 不是用value 而是用 ref--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;OracleImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserServiceImpl</span> <span class="variable">serviceImpl</span> <span class="operator">=</span> (UserServiceImpl) context.getBean(<span class="string">&quot;ServiceImpl&quot;</span>);</span><br><span class="line">    serviceImpl.getUser();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要实现不同的操作，只需要在 xml 中进行修改，IOC 简单来说就是：对象由 Spring 来进行创建、管理、装配</p><h1 id="IOC-创建对象方式"><a href="#IOC-创建对象方式" class="headerlink" title="IOC 创建对象方式"></a>IOC 创建对象方式</h1><h2 id="通过无参构造方法来创建"><a href="#通过无参构造方法来创建" class="headerlink" title="通过无参构造方法来创建"></a>通过无参构造方法来创建</h2><p>User.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user无参构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span>+ name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Bean.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//在执行getBean的时候, user已经创建好了 , 通过无参构造</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="comment">//调用对象的方法 .</span></span><br><span class="line">    user.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以发现，在 show 之前，User 对象就已经通过无参构造初始化了</p><h2 id="通过有参构造来创建"><a href="#通过有参构造来创建" class="headerlink" title="通过有参构造来创建"></a>通过有参构造来创建</h2><p>UserT.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserT</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserT</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span>+ name );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Bean.xml(三种)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一种根据index参数下标设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- index指构造方法 , 下标从0开始 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第二种根据参数名字设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name指参数名 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第三种根据参数类型设置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.UserT&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;kuangshen2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testT</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserT</span> <span class="variable">user</span> <span class="operator">=</span> (UserT) context.getBean(<span class="string">&quot;userT&quot;</span>);</span><br><span class="line">    user.show();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在配置文件加载的时候，其中管理的对象都已经初始化了</p><h1 id="Spring-配置"><a href="#Spring-配置" class="headerlink" title="Spring 配置"></a>Spring 配置</h1><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>alias 设置别名，为 bean 设置别名，可以有多个别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置别名：在获取Bean的时候可以使用别名获取--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;userT&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;userNew&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Bean-的配置"><a href="#Bean-的配置" class="headerlink" title="Bean 的配置"></a>Bean 的配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--bean就是java对象,由Spring创建和管理--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    id 是bean的标识符,要唯一,如果没有配置id,name就是默认标识符</span></span><br><span class="line"><span class="comment">    如果配置id,又配置了name,那么name是别名</span></span><br><span class="line"><span class="comment">    name可以设置多个别名,可以用逗号,分号,空格隔开</span></span><br><span class="line"><span class="comment">    如果不配置id和name,可以根据applicationContext.getBean(.class)获取对象;</span></span><br><span class="line"><span class="comment">    class是bean的全限定名=包名+类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">name</span>=<span class="string">&quot;hello2 h2,h3;h4&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Hello&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Import"><a href="#Import" class="headerlink" title="Import"></a>Import</h2><p>团队合作通过 import 来实现<br><code>&lt;import resource=&quot;&#123;path&#125;/beans.xml&quot;/&gt;</code></p><h1 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h1><ul><li>依赖注入（Dependency Injection，DI）</li><li>依赖：指 Bena 对象的创建依赖于容器</li><li>注入：指 Bean 对象所依赖的资源，又容器来设置和调配</li></ul><h2 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h2><ul><li>无参</li><li>有参</li></ul><h2 id="set-注入（重点）"><a href="#set-注入（重点）" class="headerlink" title="set 注入（重点）"></a>set 注入（重点）</h2><p>要求被注入的属性，必须有 set 方法，set 方法的方法名由 set+属性首字母大写，如果属性是 boolean 类型则没有 set 方法，而是 is</p><p>测试 pojo 类：</p><p>Address.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAddress</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Student.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pojo;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String[] books;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbys;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; card;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; games;</span><br><span class="line">    <span class="keyword">private</span> String wife;</span><br><span class="line">    <span class="keyword">private</span> Properties info;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAddress</span><span class="params">(Address address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBooks</span><span class="params">(String[] books)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.books = books;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHobbys</span><span class="params">(List&lt;String&gt; hobbys)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hobbys = hobbys;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCard</span><span class="params">(Map&lt;String, String&gt; card)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.card = card;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGames</span><span class="params">(Set&lt;String&gt; games)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.games = games;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWife</span><span class="params">(String wife)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.wife = wife;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(Properties info)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span>+ name</span><br><span class="line">                + <span class="string">&quot;,address=&quot;</span>+ address.getAddress()</span><br><span class="line">                + <span class="string">&quot;,books=&quot;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">for</span> (String book:books)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;&lt;&lt;&quot;</span>+book+<span class="string">&quot;&gt;&gt;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n爱好:&quot;</span>+hobbys);</span><br><span class="line">        System.out.println(<span class="string">&quot;card:&quot;</span>+card);</span><br><span class="line">        System.out.println(<span class="string">&quot;games:&quot;</span>+games);</span><br><span class="line">        System.out.println(<span class="string">&quot;wife:&quot;</span>+wife);</span><br><span class="line">        System.out.println(<span class="string">&quot;info:&quot;</span>+info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常量注入"><a href="#常量注入" class="headerlink" title="常量注入"></a>常量注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">    System.out.println(student.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Bean-注入"><a href="#Bean-注入" class="headerlink" title="Bean 注入"></a>Bean 注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;addr&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Address&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;重庆&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;addr&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组注入"><a href="#数组注入" class="headerlink" title="数组注入"></a>数组注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;addr&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="List-注入"><a href="#List-注入" class="headerlink" title="List 注入"></a>List 注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;小明&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;addr&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>西游记<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>水浒传<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Map-注入"><a href="#Map-注入" class="headerlink" title="Map 注入"></a>Map 注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;中国邮政&quot;</span> <span class="attr">value</span>=<span class="string">&quot;456456456465456&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;建设&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1456682255511&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="set-注入"><a href="#set-注入" class="headerlink" title="set 注入"></a>set 注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>BOB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>COC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="NULL-注入"><a href="#NULL-注入" class="headerlink" title="NULL 注入"></a>NULL 注入</h3><p><code>&lt;property name=&quot;wife&quot;&gt;&lt;null/&gt;&lt;/property&gt;</code></p><h3 id="Properties-注入"><a href="#Properties-注入" class="headerlink" title="Properties 注入"></a>Properties 注入</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;学号&quot;</span>&gt;</span>20190604<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;性别&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果：<br><img src="/../image/Spring5Pic/Spring%E6%B3%A8%E5%85%A5%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p><h2 id="拓展注入现实"><a href="#拓展注入现实" class="headerlink" title="拓展注入现实"></a>拓展注入现实</h2><p>User.java 【没有有参构造器】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="P（properties）命名空间注入：需要在头文件中加入约束文件"><a href="#P（properties）命名空间注入：需要在头文件中加入约束文件" class="headerlink" title="P（properties）命名空间注入：需要在头文件中加入约束文件"></a>P（properties）命名空间注入：需要在头文件中加入约束文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">导入约束 : xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line"><span class="comment">&lt;!--P(属性: properties)命名空间 , 属性依然要设置set方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;狂神&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="c（construct）命名空间注入：需要在头文件中加入约束文件"><a href="#c（construct）命名空间注入：需要在头文件中加入约束文件" class="headerlink" title="c（construct）命名空间注入：需要在头文件中加入约束文件"></a>c（construct）命名空间注入：需要在头文件中加入约束文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">导入约束 : xmlns:c=&quot;http://www.springframework.org/schema/c&quot;</span><br><span class="line"><span class="comment">&lt;!--C(构造: Constructor)命名空间 , 属性依然要设置set方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;狂神&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>未添加有参构造时报错</strong>：相当于无参注入和有参注入</p><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test02</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h2><p>在 Spring 中，那些组成应用程序的主体及由 Spring IoC 容器所管理的对象，被称之为 bean。简单地讲，bean 就是由 IoC 容器初始化、装配及管理的对象 .<br><img src="/../image/Spring5Pic/Spring-Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F.png"><br>几种作用域中，request、session 作用域仅在基于 web 的应用中使用（不必关心你所采用的是什么 web 应用框架），只能用在基于 web 的 Spring ApplicationContext 环境。</p><h3 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h3><p>当一个 bean 的作用域为 Singleton，那么 Spring IoC 容器中只会存在一个共享的 bean 实例，并且所有对 bean 的请求，只要 id 与该 bean 定义相匹配，则只会返回 bean 的同一实例。Singleton 是单例类型，就是在创建起容器时就同时自动创建了一个 bean 的对象，不管你是否使用，他都存在了，每次获取到的对象都是同一个对象。注意，Singleton 作用域是 Spring 中的缺省作用域。要在 XML 中将 bean 定义成 singleton，可以这样配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;ServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.csdn.service.ServiceImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test03</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(user==user2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h3><p>当一个 bean 的作用域为 Prototype，表示一个 bean 定义对应多个对象实例。Prototype 作用域的 bean 会导致在每次对该 bean 请求（将其注入到另一个 bean 中，或者以程序的方式调用容器的 getBean()方法）时都会创建一个新的 bean 实例。Prototype 是原型类型，它在我们创建容器的时候并没有实例化，而是当我们获取 bean 的时候才会去创建一个对象，而且我们每次获取到的对象都不是同一个对象。根据经验，对有状态的 bean 应该使用 prototype 作用域，而对无状态的 bean 则应该使用 singleton 作用域。在 XML 中将 bean 定义成 prototype，可以这样配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;account&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.DefaultAccount&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br><span class="line"> 或者</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;account&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.DefaultAccount&quot;</span> <span class="attr">singleton</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h3><p>当一个 bean 的作用域为 Request，表示在一次 HTTP 请求中，一个 bean 定义对应一个实例；即每个 HTTP 请求都会有各自的 bean 实例，它们依据某个 bean 定义创建而成。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。考虑下面 bean 定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;loginAction&quot;</span> <span class="attr">class</span>=<span class="string">cn.csdn.LoginAction</span>&quot; <span class="attr">scope</span>=<span class="string">&quot;request&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>针对每次 HTTP 请求，Spring 容器会根据 loginAction bean 的定义创建一个全新的 LoginAction bean 实例，且该 loginAction bean 实例仅在当前 HTTP request 内有效，因此可以根据需要放心的更改所建实例的内部状态，而其他请求中根据 loginAction bean 定义创建的实例，将不会看到这些特定于某个请求的状态变化。当处理请求结束，request 作用域的 bean 实例将被销毁。</p><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>当一个 bean 的作用域为 Session，表示在一个 HTTP Session 中，一个 bean 定义对应一个实例。该作用域仅在基于 web 的 Spring ApplicationContext 情形下有效。考虑下面 bean 定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userPreferences&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.foo.UserPreferences&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;session&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>针对某个 HTTP Session，Spring 容器会根据 userPreferences bean 定义创建一个全新的 userPreferences bean 实例，且该 userPreferences bean 仅在当前 HTTP Session 内有效。与 request 作用域一样，可以根据需要放心的更改所创建实例的内部状态，而别的 HTTP Session 中根据 userPreferences 创建的实例，将不会看到这些特定于某个 HTTP Session 的状态变化。当 HTTP Session 最终被废弃的时候，在该 HTTP Session 作用域内的 bean 也会被废弃掉。</p><h1 id="Bean-的自动装配"><a href="#Bean-的自动装配" class="headerlink" title="Bean 的自动装配"></a>Bean 的自动装配</h1><ul><li>自动装配是使用 spring 满足 bean 依赖的一种方法</li><li>spring 会在应用上下文中为某个 bean 寻找其依赖的 bean。</li></ul><p>Spring 中 bean 有三种装配机制，分别是：</p><ul><li>在 xml 中显式配置；</li><li>在 java 中显式配置；</li><li>隐式的 bean 发现机制和自动装配。</li></ul><p>Spring 的自动装配需要从两个角度来实现，或者说是两个操作：</p><ul><li>组件扫描(component scanning)：spring 会自动发现应用上下文中所创建的 bean；</li><li>自动装配(autowiring)：spring 自动满足 bean 之间的依赖，也就是我们说的 IoC&#x2F;DI；</li></ul><p>组件扫描和自动装配组合发挥巨大威力，使的显示的配置降低到最少。<br><strong>推荐不使用自动装配 xml 配置 , 而使用注解</strong></p><h2 id="测试环境搭建"><a href="#测试环境搭建" class="headerlink" title="测试环境搭建"></a>测试环境搭建</h2><p>新建一个项目<br>新建两个实体类，分别为 Cat.java \ Dog.java 都有一个叫的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;miao~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shout</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;wang~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>新建一个用户类 User</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;cat&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dog&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;qinjiang&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethodAutowire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        user.getCat().shout();</span><br><span class="line">        user.getDog().shout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="byName"><a href="#byName" class="headerlink" title="byName"></a>byName</h2><p><strong>autowire byName (按名称自动装配)</strong><br>由于在手动配置 xml 过程中，常常发生字母缺漏和大小写等错误，而无法对其进行检查，使得开发效率降低。</p><p>采用自动装配将避免这些错误，并且使配置简单化。</p><p>测试：<br>修改 bean 配置，增加一个属性 autowire&#x3D;”byName”</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;qinjiang&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再次测试，结果依旧成功输出！</p><p>我们将 cat 的 bean id 修改为 catXXX</p><p>再次测试， 执行时报空指针 java.lang.NullPointerException。因为按 byName 规则找不对应 set 方法，真正的 setCat 就没执行，对象就没有初始化，所以调用时就会报空指针错误。</p><p><strong>总结：</strong><br>当一个 bean 节点带有 autowire byName 的属性时。</p><p>将查找其类中所有的 set 方法名，例如 setCat，获得将 set 去掉并且首字母小写的字符串，即 cat。<br>去 spring 容器中寻找是否有此字符串名称 id 的对象。<br>如果有，就取出注入；如果没有，就报空指针异常。</p><h2 id="byType"><a href="#byType" class="headerlink" title="byType"></a>byType</h2><p><strong>autowire byType (按类型自动装配)</strong><br>使用 autowire byType 首先需要保证：同一类型的对象，在 spring 容器中唯一。如果不唯一，会报不唯一的异常。<br><code>NoUniqueBeanDefinitionException</code><br>测试：</p><p>将 user 的 bean 配置修改一下 ： <code>autowire=&quot;byType&quot;</code></p><p>测试，正常输出</p><p>在注册一个 cat 的 bean 对象！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">value</span>=<span class="string">&quot;qinjiang&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试，报错：NoUniqueBeanDefinitionException</p><p>删掉 cat2，将 cat 的 bean 名称改掉！测试！因为是按类型装配，所以并不会报异常，也不影响最后的结果。甚至将 id 属性去掉，也不影响结果。</p><p>这就是按照类型自动装配！</p><h2 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h2><p>jdk1.5 开始支持注解，spring2.5 开始全面支持注解。</p><p>准备工作： 利用注解的方式注入属性。</p><p>在 spring 配置文件中引入 context 文件头</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">http://www.springframework.org/schema/context/spring-context.xsd</span><br></pre></td></tr></table></figure><p>开启属性注解支持！</p><p><code>&lt;context:annotation-config/&gt;</code></p><h3 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h3><ul><li>@Autowired 是按类型自动转配的，不支持 id 匹配。</li><li>需要导入 spring-aop 的包！</li></ul><p>测试：<br>将 User 类中的 set 方法去掉，使用@Autowired 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    <span class="keyword">public</span> Cat <span class="title function_">getCat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">getDog</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dog;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>@Autowired(required&#x3D;false) 说明： false，对象可以为 null；true，对象必须存对象，不能为 null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果允许对象为null，设置required = false,默认为true</span></span><br><span class="line"><span class="meta">@Autowired(required = false)</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br></pre></td></tr></table></figure><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><ul><li><p>@Autowired 是根据类型自动装配的，加上@Qualifier 则可以根据 byName 的方式自动装配</p></li><li><p>@Qualifier 不能单独使用。</p></li></ul><p>配置文件修改内容，保证类型存在对象。且名字不为类的默认名字！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>没有加 Qualifier 测试，直接报错</p><p>在属性上添加 Qualifier 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;cat2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;dog2&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><ul><li>@Resource 如有指定的 name 属性，先按该属性进行 byName 方式查找装配；</li><li>其次再进行默认的 byName 方式进行装配；</li><li>如果以上都不成功，则按 byType 的方式自动装配。</li><li>都不成功，则报异常。</li></ul><p>实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="comment">//如果允许对象为null，设置required = false,默认为true</span></span><br><span class="line">    <span class="meta">@Resource(name = &quot;cat2&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>beans.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试：结果 OK</p><p>配置文件 2：beans.xml ， 删掉 cat2</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Dog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cat1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.pojo.Cat&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>实体类上只保留注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Cat cat;</span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> Dog dog;</span><br></pre></td></tr></table></figure><p>结果：OK</p><p>结论：先进行 byName 查找，失败；再进行 byType 查找，成功。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>@Autowired 与@Resource 异同：</p><p>@Autowired 与@Resource 都可以用来装配 bean。都可以写在字段上，或写在 setter 方法上。<br>@Autowired 默认按类型装配（属于 spring 规范），默认情况下必须要求依赖对象必须存在，如果要允许 null 值，可以设置它的 required 属性为 false，如：@Autowired(required&#x3D;false) ，如果我们想使用名称装配可以结合@Qualifier 注解进行使用<br>@Resource（属于 J2EE 复返），默认按照名称进行装配，名称可以通过 name 属性进行指定。如果没有指定 name 属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在 setter 方法上默认取属性名进行装配。 当找不到与名称匹配的 bean 时才按照类型进行装配。但是需要注意的是，如果 name 属性一旦指定，就只会按照名称进行装配。<br>它们的作用相同都是用注解方式注入对象，但执行顺序不同。@Autowired 先 byType，@Resource 先 byName。</p><h1 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>在 spring4 之后，想要使用注解形式，必须得要引入 aop 的包<br><img src="/../image/Spring5Pic/Spring-AOP%E7%9A%84jar.png"><br>在配置文件当中，还得要引入一个 context 约束</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Bean-的实现"><a href="#Bean-的实现" class="headerlink" title="Bean 的实现"></a>Bean 的实现</h2><p>我们之前都是使用 bean 的标签进行 bean 注入，但是实际开发中，我们一般都会使用注解！</p><p>配置扫描哪些包下的注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定注解扫描包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.kuang.pojo&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>在指定包下编写类，增加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="comment">// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;秦疆&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) applicationContext.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    System.out.println(user.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><p>使用注解注入属性</p><p>可以不用提供 set 方法，直接在直接名上添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@value(“值”)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="comment">// 相当于配置文件中 &lt;bean id=&quot;user&quot; class=&quot;当前注解的类&quot;/&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;秦疆&quot;)</span></span><br><span class="line">    <span class="comment">// 相当于配置文件中 &lt;property name=&quot;name&quot; value=&quot;秦疆&quot;/&gt;</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果提供了 set 方法，在 set 方法上添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@value(“值”)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="meta">@Value(&quot;秦疆&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="衍生注解"><a href="#衍生注解" class="headerlink" title="衍生注解"></a>衍生注解</h2><p>我们这些注解，就是替代了在配置文件当中配置步骤而已！更加的方便快捷！</p><p>@Component 三个衍生注解</p><p>为了更好的进行分层，Spring 可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。</p><ul><li>@Controller：web 层</li><li>@Service：service 层</li><li>@Repository：dao 层</li></ul><p>写上这些注解，就相当于将这个类交给 Spring 管理装配了！</p><h2 id="自动装配注解"><a href="#自动装配注解" class="headerlink" title="自动装配注解"></a>自动装配注解</h2><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>@scope</p><ul><li>singleton：默认的，Spring 会采用单例模式创建这个对象。关闭工厂 ，所有的对象都会销毁。</li><li>prototype：多例模式。关闭工厂 ，所有的对象不会销毁。内部的垃圾回收机制会回收</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller(&quot;user&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;秦疆&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p><strong>XML 与注解比较</strong></p><ul><li><p>XML 可以适用任何场景 ，结构清晰，维护方便</p></li><li><p>注解不是自己提供的类使用不了，开发简单方便</p></li></ul><p><strong>xml 与注解整合开发 ：推荐最佳实践</strong></p><ul><li>xml 管理 Bean</li><li>注解完成属性注入</li><li>使用过程中， 可以不用扫描，扫描是为了类上的注解<br><code>&lt;context:annotation-config/&gt;</code></li></ul><p>作用：</p><ul><li><p>进行注解驱动注册，从而使注解生效</p></li><li><p>用于激活那些已经在 spring 容器里注册过的 bean 上面的注解，也就是显示的向 Spring 注册</p></li><li><p>如果不扫描包，就需要手动配置 bean</p></li><li><p>如果不加注解驱动，则注入的值为 null！</p></li></ul><h2 id="基于-Java-类进行配置"><a href="#基于-Java-类进行配置" class="headerlink" title="基于 Java 类进行配置"></a>基于 Java 类进行配置</h2><p>JavaConfig 原来是 Spring 的一个子项目，它通过 Java 类的方式提供 Bean 的定义信息，在 Spring4 的版本， JavaConfig 已正式成为 Spring4 的核心功能 。</p><p>测试：</p><p>编写一个实体类，Dog</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">//将这个类标注为Spring的一个组件，放到容器中！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;dog&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建一个 config 配置包，编写一个 MyConfig 配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//代表这是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//通过方法注册一个bean，这里的返回值就Bean的类型，方法名就是bean的id！</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">dog</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(MyConfig.class);</span><br><span class="line">    <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> (Dog) applicationContext.getBean(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    System.out.println(dog.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功输出结果！</p><p><strong>导入其他配置如何做呢？</strong></p><p>我们再编写一个配置类！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  <span class="comment">//代表这是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig2</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在之前的配置类中我们来选择导入这个配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(MyConfig2.class)</span>  <span class="comment">//导入合并其他配置类，类似于配置文件中的 inculde 标签</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">dog</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这种 Java 类的配置方式，我们在之后的 SpringBoot 和 SpringCloud 中还会大量看到，我们需要知道这些注解的作用即可！</p><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><p>AOP 的底层机制就是动态代理</p><p>代理模式：</p><ul><li>静态代理</li><li>动态代理<br><img src="/../image/Spring5Pic/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.png"></li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理角色分析：</p><ul><li>抽象角色：一般使用接口或抽象类来实现</li><li>真实角色：被代理的角色</li><li>代理角色：代理真是角色；代理真是角色后，一般会做一些附属操作</li><li>客户：使用代理角色来进行一些操作</li></ul><p><strong>代码实现：</strong></p><p>Rent.java ：抽象角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象角色：租房</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Rent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Host.java ：真实角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真实角色: 房东，房东要出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Host</span> <span class="keyword">implements</span> <span class="title class_">Rent</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房屋出租&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Proxy.java ：代理角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理角色：中介</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Rent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">(Host host)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//租房</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>&#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        host.rent();</span><br><span class="line">        fare();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看房</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seeHouse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;带房客看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//收中介费</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fare</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收中介费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Client.java ：客户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户类，一般客户都会去找代理！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//房东要租房</span></span><br><span class="line">        <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Host</span>();</span><br><span class="line">        <span class="comment">//中介帮助房东</span></span><br><span class="line">        <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(host);</span><br><span class="line">        <span class="comment">//你去找中介！</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分析： 在这个过程中，你直接接触的就是中介，就如同现实生活中的样子，你看不到房东，但是你依旧租到了房东的房子通过代理，这就是所谓的代理模式，程序源自于生活，所以学编程的人，一般能够更加抽象的看待生活中发生的事情。</p><h2 id="静态代理的优点"><a href="#静态代理的优点" class="headerlink" title="静态代理的优点"></a>静态代理的优点</h2><ul><li>可以使真实角色更加纯粹，不在关注一些公共的事情</li><li>公共的业务由代理完成，实现了业务分工</li><li>公共业务发生拓展时变得更加集中和方便</li></ul><p>缺点：</p><ul><li>一个真实类对应一个代理类，工作量变大，开发效率变低</li></ul><h2 id="静态代理-—-联系"><a href="#静态代理-—-联系" class="headerlink" title="静态代理 — 联系"></a>静态代理 — 联系</h2><p>创建一个抽象角色，新增增删改查方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象角色：增删改查业务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现类，即真实对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真实对象，完成增删改查操作的人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设置代理类来处理新增需求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代理角色，在这里面增加日志的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserServiceImpl userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;delete&quot;</span>);</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">        userService.update();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;query&quot;</span>);</span><br><span class="line">        userService.query();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span>+msg+<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//真实业务</span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="comment">//代理类</span></span><br><span class="line">        <span class="type">UserServiceProxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceProxy</span>();</span><br><span class="line">        <span class="comment">//使用代理类实现日志功能！</span></span><br><span class="line">        proxy.setUserService(userService);</span><br><span class="line">        proxy.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>AOP：并不改变原代码的情况下，完成对原有功能的增强<br><img src="/../image/Spring5Pic/AOP%E6%A8%AA%E7%BA%B5.png"></p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><ul><li>动态代理的角色和静态代理的一样 .</li><li>动态代理的代理类是动态生成的 . 静态代理的代理类是我们提前写好的</li><li>动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理<ul><li>基于接口的动态代理——JDK 动态代理</li><li>基于类的动态代理—cglib</li><li>现在用的比较多的是 javasist 来生成动态代理 . 百度一下 javasist</li><li>我们这里使用 JDK 的原生代码来实现，其余的道理都是一样的！</li></ul></li></ul><p>JDK 的动态代理需要了解两个类</p><p>核心 : InvocationHandler 和 Proxy ， 打开 JDK 帮助文档看看</p><p>【InvocationHandler：调用处理程序】<br><img src="/../image/Spring5Pic/InvocationHandler.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="title function_">invoke</span><span class="params">(Object proxy, 方法 method, Object[] args)</span>；</span><br><span class="line"><span class="comment">//参数</span></span><br><span class="line"><span class="comment">//proxy - 调用该方法的代理实例</span></span><br><span class="line"><span class="comment">//method -所述方法对应于调用代理实例上的接口方法的实例。 方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。</span></span><br><span class="line"><span class="comment">//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。 原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean 。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>【Proxy : 代理】<br><img src="/../image/Spring5Pic/Proxy-1.png"><br><img src="/../image/Spring5Pic/Proxy-2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成代理类</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(),</span><br><span class="line">                                  rent.getClass().getInterfaces(),<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码实现</strong></p><p>Rent.java 抽象角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象角色：租房</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Rent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Host.java 真实角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//真实角色: 房东，房东要出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Host</span> <span class="keyword">implements</span> <span class="title class_">Rent</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房屋出租&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProxyInvocationHandler.java 代理角色</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Rent rent;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRent</span><span class="params">(Rent rent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(),</span><br><span class="line">                rent.getClass().getInterfaces(),<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// proxy : 代理类 method : 代理类的调用处理程序的方法对象.</span></span><br><span class="line">    <span class="comment">// 处理代理实例上的方法调用并返回结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        <span class="comment">//核心：本质利用反射实现！</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(rent, args);</span><br><span class="line">        fare();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看房</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">seeHouse</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;带房客看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//收中介费</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fare</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收中介费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Client.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//租客</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//真实角色</span></span><br><span class="line">        <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Host</span>();</span><br><span class="line">        <span class="comment">//代理实例的调用处理程序</span></span><br><span class="line">        <span class="type">ProxyInvocationHandler</span> <span class="variable">pih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>();</span><br><span class="line">        pih.setRent(host); <span class="comment">//将真实角色放置进去！</span></span><br><span class="line">        <span class="type">Rent</span> <span class="variable">proxy</span> <span class="operator">=</span> (Rent)pih.getProxy(); <span class="comment">//动态生成对应的代理类！</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心：<strong>一个动态代理 , 一般代理某一类业务 , 一个动态代理可以代理多个类，代理的是接口！</strong></p><h2 id="通用代理类"><a href="#通用代理类" class="headerlink" title="通用代理类"></a>通用代理类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTarget</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成代理类</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// proxy : 代理类</span></span><br><span class="line">    <span class="comment">// method : 代理类的调用处理程序的方法对象.</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log(method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String methodName)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span>+methodName+<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//真实对象</span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">        <span class="comment">//代理对象的调用处理程序</span></span><br><span class="line">        <span class="type">ProxyInvocationHandler</span> <span class="variable">pih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>();</span><br><span class="line">        pih.setTarget(userService); <span class="comment">//设置要代理的对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService)pih.getProxy(); <span class="comment">//动态生成代理类！</span></span><br><span class="line">        proxy.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情</li><li>公共的业务由代理来完成 . 实现了业务的分工</li><li>公共业务发生扩展时变得更加集中和方便</li><li>一个动态代理，一般代理某一类业务</li><li>一个动态代理可以代理多个类，代理的是接口</li></ul><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h2><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP 是 OOP 的延续，是软件开发中的一个热点，也是 Spring 框架中的一个重要内容，是函数式编程的一种衍生范型。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。<br><img src="/../image/Spring5Pic/%E4%BB%80%E4%B9%88%E6%98%AFAOP.png"></p><h2 id="AOP-在-Spring-中的作用"><a href="#AOP-在-Spring-中的作用" class="headerlink" title="AOP 在 Spring 中的作用"></a>AOP 在 Spring 中的作用</h2><p><strong>提供声明式事务：允许童虎自定义切面</strong></p><ul><li><p>横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ….</p></li><li><p>切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。</p></li><li><p>通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。</p></li><li><p>目标（Target）：被通知对象。</p></li><li><p>代理（Proxy）：向目标对象应用通知之后创建的对象。</p></li><li><p>切入点（PointCut）：切面通知 执行的 “地点”的定义。</p></li><li><p>连接点（JointPoint）：与切入点匹配的执行点。</p></li></ul><p><img src="/../image/Spring5Pic/AOP%E5%90%8D%E8%AF%8D.png"></p><p>SpringAOP 中，通过 Advice 定义横切逻辑，Spring 中支持 5 种类型的 Advice:<br><img src="/../image/Spring5Pic/AOP%E5%90%84%E6%8E%A5%E5%8F%A3.png"></p><p>即 Aop 在 不改变原有代码的情况下 , 去增加新的功能</p><h2 id="使用-Spring-实现-AOP"><a href="#使用-Spring-实现-AOP" class="headerlink" title="使用 Spring 实现 AOP"></a>使用 Spring 实现 AOP</h2><p>导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-通过-Spring-API-实现"><a href="#1-通过-Spring-API-实现" class="headerlink" title="1.通过 Spring API 实现"></a>1.通过 Spring API 实现</h3><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;更新用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">search</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前置增强、后置增强：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log</span> <span class="keyword">implements</span> <span class="title class_">MethodBeforeAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//method : 要执行的目标对象的方法</span></span><br><span class="line">    <span class="comment">//objects : 被调用的方法的参数</span></span><br><span class="line">    <span class="comment">//Object : 目标对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println( o.getClass().getName() + <span class="string">&quot;的&quot;</span> + method.getName() + <span class="string">&quot;方法被执行了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AfterLog</span> <span class="keyword">implements</span> <span class="title class_">AfterReturningAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//returnValue 返回值</span></span><br><span class="line">    <span class="comment">//method被调用的方法</span></span><br><span class="line">    <span class="comment">//args 被调用的方法的对象的参数</span></span><br><span class="line">    <span class="comment">//target 被调用的目标对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span> + target.getClass().getName()</span><br><span class="line">        +<span class="string">&quot;的&quot;</span>+method.getName()+<span class="string">&quot;方法,&quot;</span></span><br><span class="line">        +<span class="string">&quot;返回值：&quot;</span>+returnValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后去 spring 的文件中注册 , 并实现 aop 切入实现，注意导入约束</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.service.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.log.Log&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.log.AfterLog&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点  expression:表达式匹配要执行的方法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--执行环绕; advice-ref执行方法 . pointcut-ref切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.search();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-自定义类实现-AOP"><a href="#2-自定义类实现-AOP" class="headerlink" title="2.自定义类实现 AOP"></a>2.自定义类实现 AOP</h3><p>目标业务类不变依旧是 userServiceImpl</p><p>第一步 : 写我们自己的一个切入类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiyPointcut</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------方法执行前---------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------方法执行后---------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>去 spring 中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第二种方式自定义实现--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;diy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.config.DiyPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--aop的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--第二种方式：使用AOP的标签实现--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;diy&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;diyPonitcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-使用注解实现"><a href="#3-使用注解实现" class="headerlink" title="3.使用注解实现"></a>3.使用注解实现</h3><p>第一步：编写一个注解实现的增强类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.config;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.After;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationPointcut</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------方法执行前---------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------方法执行后---------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.kuang.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;签名:&quot;</span>+jp.getSignature());</span><br><span class="line">        <span class="comment">//执行目标方法proceed</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> jp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后&quot;</span>);</span><br><span class="line">        System.out.println(proceed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二步：在 Spring 配置文件中，注册 bean，并增加支持注解的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--第三种方式:注解实现--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;annotationPointcut&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.config.AnnotationPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>aop:aspectj-autoproxy：说明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过aop命名空间的<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span>声明自动为spring容器中那些配置@aspectJ切面的bean创建代理，织入切面。当然，spring 在内部依旧采用AnnotationAwareAspectJAutoProxyCreator进行自动代理的创建工作，但具体实现的细节已经被<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span>隐藏起来了</span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span>有一个proxy-target-class属性，默认为false，表示使用jdk动态代理织入增强，当配为<span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>  <span class="attr">poxy-target-class</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>时，表示使用CGLib动态代理技术织入增强。不过即使proxy-target-class设置为false，如果目标类没有声明接口，则spring将自动使用CGLib动态代理。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Spring-整合-MyBatis"><a href="#Spring-整合-MyBatis" class="headerlink" title="Spring 整合 MyBatis"></a>Spring 整合 MyBatis</h1><p>步骤：<br>导入相关 jar</p><p>junit</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mysql-connector-java</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>spring 相关</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>aspectJ AOP 织入器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>mybatis-spring 整合包 【重点】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 Maven 静态资源过滤问题！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写配置文件</p><p>代码实现</p><h2 id="MyBatis-的简单实现"><a href="#MyBatis-的简单实现" class="headerlink" title="MyBatis 的简单实现"></a>MyBatis 的简单实现</h2><p>编写实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.pojo;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;  <span class="comment">//id</span></span><br><span class="line">    <span class="keyword">private</span> String name;   <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> String pwd;   <span class="comment">//密码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.kuang.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.kuang.dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写 Mapper 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUser</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编写 Mapper 对应的映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.kuang.dao.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">      select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    List&lt;User&gt; userList = mapper.selectUser();</span><br><span class="line">    <span class="keyword">for</span> (User user: userList)&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="MyBatis-Spring"><a href="#MyBatis-Spring" class="headerlink" title="MyBatis-Spring"></a>MyBatis-Spring</h2><p>Mybatis-Spring 中的一些重要类<br><a href="https://github.com/mybatis/spring">https://github.com/mybatis/spring</a><br><a href="https://github.com/mybatis/ibatis-spring">https://github.com/mybatis/ibatis-spring</a></p><p><img src="/../image/Spring5Pic/Mybatis-Spring.png"><br><strong>什么是 MyBatis-Spring？</strong></p><p>MyBatis-Spring 会帮助你将 MyBatis 代码无缝地整合到 Spring 中。</p><p><strong>知识基础</strong></p><p>在开始使用 MyBatis-Spring 之前，你需要先熟悉 Spring 和 MyBatis 这两个框架和有关它们的术语。这很重要</p><p>MyBatis-Spring 需要以下版本：</p><table><thead><tr><th>MyBatis-Spring</th><th>MyBatis</th><th>Spring 框架</th><th>Spring Batch</th><th>Java</th></tr></thead><tbody><tr><td>2.0</td><td>3.5+</td><td>5.0+</td><td>4.0+</td><td>Java 8+</td></tr><tr><td>1.3</td><td>3.4+</td><td>3.2.2+</td><td>2.1+</td><td>Java 6+</td></tr></tbody></table><p>如果使用 Maven 作为构建工具，仅需要在 pom.xml 中加入以下代码即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要和 Spring 一起使用 MyBatis，需要在 Spring 应用上下文中定义至少两样东西：一个 <code>SqlSessionFactory</code> 和至少一个数据映射器类。</p><p>在 MyBatis-Spring 中，可使用 <code>SqlSessionFactoryBean</code>来创建 <code>SqlSessionFactory</code>。 要配置这个工厂 bean，只需要把下面代码放在 Spring 的 XML 配置文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：<code>SqlSessionFactory</code> 需要一个 <code>DataSource</code>（数据源）。 这可以是任意的 DataSource，只需要和配置其它 Spring 数据库连接一样配置它就可以了。</p><p>在基础的 MyBatis 用法中，是通过 <code>SqlSessionFactoryBuilder</code> 来创建 <code>SqlSessionFactory</code> 的。 而在 MyBatis-Spring 中，则使用 <code>SqlSessionFactoryBean</code> 来创建。</p><p>在 MyBatis 中，你可以使用 <code>SqlSessionFactory</code> 来创建 <code>SqlSession</code>。一旦你获得一个 session 之后，你可以使用它来执行映射了的语句，提交或回滚连接，最后，当不再需要它的时候，你可以关闭 session。</p><p><code>SqlSessionFactory</code> 有一个唯一的必要属性：用于 JDBC 的 <code>DataSource</code>。这可以是任意的 <code>DataSource</code> 对象，它的配置方法和其它 Spring 数据库连接是一样的。</p><p>一个常用的属性是 <code>configLocation</code>，它用来指定 MyBatis 的 XML 配置文件路径。它在需要修改 MyBatis 的基础配置非常有用。通常，基础配置指的是 <code>&lt;settings&gt;</code> 或 <code>&lt;typeAliases&gt; </code>元素。</p><p>需要注意的是，这个配置文件<strong>并不需要</strong>是一个完整的 MyBatis 配置。确切地说，任何环境配置（<code>&lt;environments&gt;</code>），数据源（<code>&lt;DataSource&gt;</code>）和 MyBatis 的事务管理器（<code>&lt;transactionManager&gt;</code>）都会被<strong>忽略</strong>。SqlSessionFactoryBean 会创建它自有的 MyBatis 环境配置（<code>Environment</code>），并按要求设置自定义环境的值。</p><p><code>SqlSessionTemplate</code> 是 MyBatis-Spring 的核心。作为 <code>SqlSession</code> 的一个实现，这意味着可以使用它无缝代替你代码中已经在使用的 <code>SqlSession</code>。</p><p>模板可以参与到 Spring 的事务管理中，并且由于其是线程安全的，可以供多个映射器类使用，你应该<strong>总是</strong>用 <code>SqlSessionTemplate</code> 来替换 MyBatis 默认的 <code>DefaultSqlSession</code> 实现。在同一应用程序中的不同类之间混杂使用可能会引起数据一致性的问题。</p><p>可以使用 <code>SqlSessionFactory</code> 作为构造方法的参数来创建 <code>SqlSessionTemplate</code> 对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，这个 bean 就可以直接注入到你的 DAO bean 中了。你需要在你的 bean 中添加一个 SqlSession 属性，就像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSession</span><span class="params">(SqlSession sqlSession)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sqlSession = sqlSession;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(String userId)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sqlSession.getMapper...;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按下面这样，注入 <code>SqlSessionTemplate</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.sample.dao.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSession&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="整合实现"><a href="#整合实现" class="headerlink" title="整合实现-"></a>整合实现-</h2><p>引入 Spring 配置文件 beans.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置数据源替换 mybaits 的数据源</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置数据源：数据源有非常多，可以使用第三方的，也可使使用Spring的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=utf8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置 SqlSessionFactory，关联 MyBatis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置SqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--关联Mybatis--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:com/kuang/dao/*.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注册 sqlSessionTemplate，关联 sqlSessionFactory；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册sqlSessionTemplate , 关联sqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionTemplate&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--利用构造器注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>增加 Dao 接口的实现类；私有化 sqlSessionTemplate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">//sqlSession不用我们自己创建了，Spring来管理</span></span><br><span class="line">    <span class="keyword">private</span> SqlSessionTemplate sqlSession;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSqlSession</span><span class="params">(SqlSessionTemplate sqlSession)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSession = sqlSession;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注册 bean 实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSession&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSession&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> (UserMapper) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">    List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果成功输出！现在我们的 Mybatis 配置文件的状态！发现都可以被 Spring 整合！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.kuang.pojo&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="整合实现二"><a href="#整合实现二" class="headerlink" title="整合实现二"></a>整合实现二</h2><p>mybatis-spring1.2.3 版以上的才有这个 .</p><p>官方文档截图 :<br><img src="/../image/Spring5Pic/MyBatis-Spring%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%88%AA%E5%9B%BE.png"><br>dao 继承 Support 类 , 直接利用 getSqlSession() 获得 , 然后直接注入 SqlSessionFactory . 比起方式 1 , 不需要管理 SqlSessionTemplate , 而且对事务的支持更加友好 . 可跟踪源码查看</p><p>测试：</p><p>将我们上面写的 UserDaoImpl 修改一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">        <span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 bean 的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.kuang.dao.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> (UserMapper) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">    List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结 : 整合到 spring 中以后可以完全不要 mybatis 的配置文件，除了这些方式可以实现整合之外，我们还可以使用注解来实现，这个等我们后面学习 SpringBoot 的时候还会测试整合！</p><h1 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h1><h2 id="回顾事务"><a href="#回顾事务" class="headerlink" title="回顾事务"></a>回顾事务</h2><ul><li>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎！</li><li>事务管理是企业级应用程序开发中必备技术，用来确保数据的完整性和一致性。</li></ul><p><strong>事务就是把一系列的动作当成一个独立的工作单元，这些动作要么全部完成，要么全部不起作用。</strong></p><h3 id="事务的四个属性-ACID"><a href="#事务的四个属性-ACID" class="headerlink" title="事务的四个属性 ACID"></a>事务的四个属性 ACID</h3><p>原子性（atomicity）</p><ul><li>事务是原子性操作，由一系列动作组成，事务的原子性确保动作要么全部完成，要么完全不起作用</li></ul><p>一致性（consistency）</p><ul><li>一旦所有事务动作完成，事务就要被提交。数据和资源处于一种满足业务规则的一致性状态中</li></ul><p>隔离性（isolation）</p><ul><li>可能多个事务会同时处理相同的数据，因此每个事务都应该与其他事务隔离开来，防止数据损坏</li></ul><p>持久性（durability）</p><ul><li>事务一旦完成，无论系统发生什么错误，结果都不会受到影响。通常情况下，事务的结果被写到持久化存储器中</li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>将上面的代码拷贝到一个新项目中</p><p>在之前的案例中，我们给 userDao 接口新增两个方法，删除和增加用户；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加一个用户</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">addUser</span><span class="params">(User user)</span>;</span><br><span class="line"><span class="comment">//根据id删除用户</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteUser</span><span class="params">(<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><p>mapper 文件，我们故意把 deletes 写错，测试！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;addUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.kuang.pojo.User&quot;</span>&gt;</span></span><br><span class="line"> insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;)</span><br><span class="line"> <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line"> deletes from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写接口的实现类，在实现类中，我们去操作一波</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title class_">SqlSessionDaoSupport</span> <span class="keyword">implements</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    <span class="comment">//增加一些操作</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">selectUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">4</span>,<span class="string">&quot;小明&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">        mapper.addUser(user);</span><br><span class="line">        mapper.deleteUser(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> mapper.selectUser();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新增</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">        <span class="keyword">return</span> mapper.addUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteUser</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> getSqlSession().getMapper(UserMapper.class);</span><br><span class="line">        <span class="keyword">return</span> mapper.deleteUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> (UserMapper) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">    List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>报错：sql 异常，delete 写错了</p><p>结果 ：插入成功！</p><p>没有进行事务的管理；我们想让他们都成功才成功，有一个失败，就都失败，我们就应该需要<strong>事务</strong>！</p><p>以前我们都需要自己手动管理事务，十分麻烦！</p><p>但是 Spring 给我们提供了事务管理，我们只需要配置即可；</p><h2 id="Spring-中的事务管理"><a href="#Spring-中的事务管理" class="headerlink" title="Spring 中的事务管理"></a>Spring 中的事务管理</h2><p>Spring 在不同的事务管理 API 之上定义了一个抽象层，使得开发人员不必了解底层的事务管理 API 就可以使用 Spring 的事务管理机制。Spring 支持编程式事务管理和声明式的事务管理。</p><h3 id="编程式事务管理"><a href="#编程式事务管理" class="headerlink" title="编程式事务管理"></a>编程式事务管理</h3><ul><li>将事务管理代码嵌到业务方法中来控制事务的提交和回滚</li><li>缺点：必须在每个事务操作业务逻辑中包含额外的事务管理代码</li></ul><h3 id="声明式事务管理"><a href="#声明式事务管理" class="headerlink" title="声明式事务管理"></a>声明式事务管理</h3><ul><li>一般情况下比编程式事务好用。</li><li>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</li><li>将事务管理作为横切关注点，通过 aop 方法模块化。Spring 中通过 Spring AOP 框架支持声明式事务管理。</li></ul><h3 id="使用-Spring-管理事务，注意头文件的约束导入-tx"><a href="#使用-Spring-管理事务，注意头文件的约束导入-tx" class="headerlink" title="使用 Spring 管理事务，注意头文件的约束导入 : tx"></a>使用 Spring 管理事务，注意头文件的约束导入 : tx</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">http://www.springframework.org/schema/tx</span><br><span class="line">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h3><ul><li><p>无论使用 Spring 的哪种事务管理策略（编程式或者声明式）事务管理器都是必须的。</p></li><li><p>就是 Spring 的核心事务管理抽象，管理封装了一组独立于技术的方法。</p></li></ul><h3 id="JDBC-事务"><a href="#JDBC-事务" class="headerlink" title="JDBC 事务"></a>JDBC 事务</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置好事务管理器后我们需要去配置事务的通知"><a href="#配置好事务管理器后我们需要去配置事务的通知" class="headerlink" title="配置好事务管理器后我们需要去配置事务的通知"></a>配置好事务管理器后我们需要去配置事务的通知</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置哪些方法使用什么样的事务,配置事务的传播特性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;search*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="spring-事务传播特性："><a href="#spring-事务传播特性：" class="headerlink" title="spring 事务传播特性："></a>spring 事务传播特性：</h3><p>事务传播行为就是多个事务方法相互调用时，事务如何在这些方法间传播。spring 支持 7 种事务传播行为：</p><ul><li>propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中，这是最常见的选择。</li><li>propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。</li><li>propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</li><li>propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。</li><li>propagation_not_supported：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>propagation_never：以非事务方式执行操作，如果当前事务存在则抛出异常。</li><li>propagation_nested：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与 propagation_required 类似的操作</li></ul><p>Spring 默认的事务传播行为是 PROPAGATION_REQUIRED，它适合于绝大多数的情况。</p><p>假设 ServiveX#methodX() 都工作在事务环境下（即都被 Spring 事务增强了），假设程序中存在如下的调用链：Service1#method1()-&gt;Service2#method2()-&gt;Service3#method3()，那么这 3 个服务类的 3 个方法通过 Spring 的事务传播机制都工作在同一个事务中。</p><p>就好比，我们刚才的几个方法存在调用，所以会被放在一组事务当中！</p><h3 id="配置-AOP"><a href="#配置-AOP" class="headerlink" title="配置 AOP"></a>配置 AOP</h3><p>导入 aop 的头文件！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置aop织入事务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.kuang.dao.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h3><p>删掉刚才插入的数据，再次测试！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">    <span class="type">UserMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> (UserMapper) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">    List&lt;User&gt; user = mapper.selectUser();</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考-1"><a href="#思考-1" class="headerlink" title="思考"></a>思考</h2><p>为什么需要配置事务？</p><ul><li><p>如果不配置，就需要我们手动提交控制事务；</p></li><li><p>事务在项目开发过程非常重要，涉及到数据的一致性的问题，不容马虎</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-笔记</title>
      <link href="/2024/04/10/MyBatis/"/>
      <url>/2024/04/10/MyBatis/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis简介"><a href="#Mybatis简介" class="headerlink" title="Mybatis简介"></a>Mybatis简介</h1><h2 id="MyBatis历史"><a href="#MyBatis历史" class="headerlink" title="MyBatis历史"></a>MyBatis历史</h2><ul><li>MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github</li><li>iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）</li></ul><h2 id="MyBatis特性"><a href="#MyBatis特性" class="headerlink" title="MyBatis特性"></a>MyBatis特性</h2><ol><li>MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集</li><li>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</li><li>MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架</li></ol><h2 id="MyBatis下载"><a href="#MyBatis下载" class="headerlink" title="MyBatis下载"></a>MyBatis下载</h2><ul><li><a href="https://github.com/mybatis/mybatis-3">MyBatis下载地址</a></li><li><img src="/../image/MyBatisPic/MyBatis%E4%B8%8B%E8%BD%BD.png"></li></ul><h2 id="和其它持久化层技术对比"><a href="#和其它持久化层技术对比" class="headerlink" title="和其它持久化层技术对比"></a>和其它持久化层技术对比</h2><ul><li>JDBC  <ul><li>SQL 夹杂在Java代码中耦合度高，导致硬编码内伤  </li><li>维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见  </li><li>代码冗长，开发效率低</li></ul></li><li>Hibernate 和 JPA<ul><li>操作简便，开发效率高  </li><li>程序中的长难复杂 SQL 需要绕过框架  </li><li>内部自动生产的 SQL，不容易做特殊优化  </li><li>基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。  </li><li>反射操作太多，导致数据库性能下降</li></ul></li><li>MyBatis<ul><li>轻量级，性能出色  </li><li>SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据  </li><li>开发效率稍逊于HIbernate，但是完全能够接受</li></ul></li></ul><h1 id="搭建MyBatis"><a href="#搭建MyBatis" class="headerlink" title="搭建MyBatis"></a>搭建MyBatis</h1><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li>IDE：idea 2019.2  </li><li>构建工具：maven 3.5.4  </li><li>MySQL版本：MySQL 5.7  </li><li>MyBatis版本：MyBatis 3.5.7</li></ul><h2 id="创建maven工程"><a href="#创建maven工程" class="headerlink" title="创建maven工程"></a>创建maven工程</h2><ul><li>打包方式：jar</li><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">```xml</span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="创建MyBatis的核心配置文件"><a href="#创建MyBatis的核心配置文件" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h2><blockquote><p>习惯上命名为<code>mybatis-config.xml</code>，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。<br>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息<br>核心配置文件存放的位置是src&#x2F;main&#x2F;resources目录下</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span>  </span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--设置连接数据库的环境--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/MyBatis&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--引入映射文件--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="创建mapper接口"><a href="#创建mapper接口" class="headerlink" title="创建mapper接口"></a>创建mapper接口</h2><blockquote><p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.mybatis.mapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 添加用户信息  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建MyBatis的映射文件"><a href="#创建MyBatis的映射文件" class="headerlink" title="创建MyBatis的映射文件"></a>创建MyBatis的映射文件</h2><ul><li>相关概念：ORM（Object Relationship Mapping）对象关系映射。  <ul><li>对象：Java的实体类对象  </li><li>关系：关系型数据库  </li><li>映射：二者之间的对应关系</li></ul></li></ul><table><thead><tr><th>Java概念</th><th>数据库概念</th></tr></thead><tbody><tr><td>类</td><td>表</td></tr><tr><td>属性</td><td>字段&#x2F;列</td></tr><tr><td>对象</td><td>记录&#x2F;行</td></tr></tbody></table><ul><li>映射文件的命名规则<ul><li>表所对应的实体类的类名+Mapper.xml</li><li>例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml </li><li>因此一个映射文件对应一个实体类，对应一张表的操作</li><li>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</li><li>MyBatis映射文件存放的位置是src&#x2F;main&#x2F;resources&#x2F;mappers目录下</li></ul></li><li>MyBatis中可以面向接口操作数据，要保证两个一致<ul><li>mapper接口的全类名和映射文件的命名空间（namespace）保持一致</li><li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span>  </span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.UserMapper&quot;</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span>  </span><br><span class="line">insert into t_user values(null,&#x27;张三&#x27;,&#x27;123&#x27;,23,&#x27;女&#x27;)  </span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="通过junit测试功能"><a href="#通过junit测试功能" class="headerlink" title="通过junit测试功能"></a>通过junit测试功能</h2><ul><li>SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）</li><li>SqlSessionFactory：是“生产”SqlSession的“工厂”</li><li>工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserMapperTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertUser</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//读取MyBatis的核心配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//获取SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">//通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line">        <span class="comment">//获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务</span></span><br><span class="line">        <span class="comment">//SqlSession sqlSession = sqlSessionFactory.openSession();</span></span><br><span class="line">    <span class="comment">//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交  </span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//通过代理模式创建UserMapper接口的代理实现类对象</span></span><br><span class="line">        <span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">//调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> userMapper.insertUser();</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        <span class="comment">//sqlSession.commit();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;result:&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用<code>SqlSession sqlSession = sqlSessionFactory.openSession(true);</code>，传入一个Boolean类型的参数，值为true，这样就可以自动提交</li></ul><h2 id="加入log4j日志功能"><a href="#加入log4j日志功能" class="headerlink" title="加入log4j日志功能"></a>加入log4j日志功能</h2><ol><li>加入依赖 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>加入log4j的配置文件<ul><li>log4j的配置文件名为log4j.xml，存放的位置是src&#x2F;main&#x2F;resources目录下</li><li>日志的级别：FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试) 从左到右打印的内容越来越详细 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">log4j</span>:configuration <span class="keyword">SYSTEM</span> <span class="string">&quot;log4j.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">&quot;http://jakarta.apache.org/log4j/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;Encoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.log4j.PatternLayout&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;ConversionPattern&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125; %m (%F:%L) \n&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;debug&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h1 id="核心配置文件详解"><a href="#核心配置文件详解" class="headerlink" title="核心配置文件详解"></a>核心配置文件详解</h1><blockquote><p>核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)：<br>properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        typeAlias：设置某个具体的类型的别名</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">        type：需要设置别名的类型的全类名</span></span><br><span class="line"><span class="comment">        alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot;&gt;&lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;typeAlias type=&quot;com.atguigu.mybatis.bean.User&quot; alias=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="comment">        &lt;/typeAlias&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.bean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    environments：设置多个连接数据库的环境</span></span><br><span class="line"><span class="comment">    属性：</span></span><br><span class="line"><span class="comment">    default：设置默认使用的环境的id</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        environment：设置具体的连接数据库的环境信息</span></span><br><span class="line"><span class="comment">        属性：</span></span><br><span class="line"><span class="comment">        id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            transactionManager：设置事务管理方式</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">            type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span></span><br><span class="line"><span class="comment">            type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span></span><br><span class="line"><span class="comment">            type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            dataSource：设置数据源</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">            type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span></span><br><span class="line"><span class="comment">            type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span></span><br><span class="line"><span class="comment">            type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建</span></span><br><span class="line"><span class="comment">            type=&quot;JNDI&quot;：调用上下文中的数据源</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置驱动类的全类名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的连接地址--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的用户名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的密码--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        以包为单位，将包下所有的映射文件引入核心配置文件</span></span><br><span class="line"><span class="comment">        注意：</span></span><br><span class="line"><span class="comment">1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span></span><br><span class="line"><span class="comment">2. mapper接口要和mapper映射文件的名字一致</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><img src="/../image/MyBatisPic/mapper%E6%8E%A5%E5%8F%A3%E5%92%8Cmapper%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%9C%A8%E5%90%8C%E4%B8%80%E5%8C%85%E4%B8%8B.png"></li></ul><h1 id="默认的类型别名"><a href="#默认的类型别名" class="headerlink" title="默认的类型别名"></a>默认的类型别名</h1><p><img src="/../image/MyBatisPic/%E9%BB%98%E8%AE%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D1.png"><br><img src="/../image/MyBatisPic/%E9%BB%98%E8%AE%A4%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D2.png"></p><h1 id="MyBatis的增删改查"><a href="#MyBatis的增删改查" class="headerlink" title="MyBatis的增删改查"></a>MyBatis的增删改查</h1><ol><li>添加 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,&#x27;admin&#x27;,&#x27;123456&#x27;,23,&#x27;男&#x27;,&#x27;12345@qq.com&#x27;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>删除 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteUser();--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteUser&quot;</span>&gt;</span></span><br><span class="line">       delete from t_user where id = 6</span><br><span class="line">   <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>修改 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int updateUser();--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span>&gt;</span></span><br><span class="line">       update t_user set username = &#x27;张三&#x27; where id = 5</span><br><span class="line">   <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>查询一个实体类对象 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">&lt;!--User getUserById();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where id = 2  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>查询集合 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.atguigu.mybatis.bean.User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><p>注意：</p><ol><li>查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系  <ul><li>resultType：自动映射，用于属性名和表中字段名一致的情况  </li><li>resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况</li></ul></li><li>当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值</li></ol></li></ul><h1 id="MyBatis获取参数值的两种方式（重点）"><a href="#MyBatis获取参数值的两种方式（重点）" class="headerlink" title="MyBatis获取参数值的两种方式（重点）"></a>MyBatis获取参数值的两种方式（重点）</h1><ul><li>MyBatis获取参数值的两种方式：${}和#{}  </li><li>${}的本质就是字符串拼接，#{}的本质就是占位符赋值  </li><li>${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号</li></ul><h2 id="单个字面量类型的参数"><a href="#单个字面量类型的参数" class="headerlink" title="单个字面量类型的参数"></a>单个字面量类型的参数</h2><ul><li>若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意）获取参数的值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = #&#123;username&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserByUsername(String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByUsername&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where username = &#x27;$&#123;username&#125;&#x27;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="多个字面量类型的参数"><a href="#多个字面量类型的参数" class="headerlink" title="多个字面量类型的参数"></a>多个字面量类型的参数</h2><ul><li><p>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中</p><ol><li>以arg0,arg1…为键，以参数为值；</li><li>以param1,param2…为键，以参数为值；</li></ol></li><li><p>因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。</p></li><li><p>使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLogin(String username,String password);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLogin&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = &#x27;$&#123;param1&#125;&#x27; and password = &#x27;$&#123;param2&#125;&#x27;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="map集合类型的参数"><a href="#map集合类型的参数" class="headerlink" title="map集合类型的参数"></a>map集合类型的参数</h2><ul><li>若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User checkLoginByMap(Map&lt;String,Object&gt; map);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;checkLoginByMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLoginByMap</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">map.put(<span class="string">&quot;usermane&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> mapper.checkLoginByMap(map);</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="实体类类型的参数"><a href="#实体类类型的参数" class="headerlink" title="实体类类型的参数"></a>实体类类型的参数</h2><ul><li>若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values(null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>,<span class="string">&quot;Tom&quot;</span>,<span class="string">&quot;123456&quot;</span>,<span class="number">12</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>);</span><br><span class="line">mapper.insertUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用-Param标识参数"><a href="#使用-Param标识参数" class="headerlink" title="使用@Param标识参数"></a>使用@Param标识参数</h2><ul><li><p>可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中 </p><ol><li>以@Param注解的value属性值为键，以参数为值；</li><li>以param1,param2…为键，以参数为值；</li></ol></li><li><p>只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User CheckLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;CheckLoginByParam&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">        select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLoginByParam</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">ParameterMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(ParameterMapper.class);</span><br><span class="line">mapper.CheckLoginByParam(<span class="string">&quot;admin&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>建议分成两种情况进行处理</p><ol><li>实体类类型的参数</li><li>使用@Param标识参数</li></ol></li></ul><h1 id="MyBatis的各种查询功能"><a href="#MyBatis的各种查询功能" class="headerlink" title="MyBatis的各种查询功能"></a>MyBatis的各种查询功能</h1><ol><li>如果查询出的数据只有一条，可以通过<ol><li>实体类对象接收</li><li>List集合接收</li><li>Map集合接收，结果<code>&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;</code></li></ol></li><li>如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过<ol><li>实体类类型的LIst集合接收</li><li>Map类型的LIst集合接收</li><li>在mapper接口的方法上添加@MapKey注解</li></ol></li></ol><h2 id="查询一个实体类对象"><a href="#查询一个实体类对象" class="headerlink" title="查询一个实体类对象"></a>查询一个实体类对象</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户id查询用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--User getUserById(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="查询一个List集合"><a href="#查询一个List集合" class="headerlink" title="查询一个List集合"></a>查询一个List集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserList</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserList();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="查询单个数据"><a href="#查询单个数据" class="headerlink" title="查询单个数据"></a>查询单个数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 查询用户的总记录数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> * 在MyBatis中，对于Java中常用的类型都设置了类型别名  </span></span><br><span class="line"><span class="comment"> * 例如：java.lang.Integer--&gt;int|integer  </span></span><br><span class="line"><span class="comment"> * 例如：int--&gt;_int|_integer  </span></span><br><span class="line"><span class="comment"> * 例如：Map--&gt;map,List--&gt;list  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int getCount();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getCount&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;_integer&quot;</span>&gt;</span></span><br><span class="line">select count(id) from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="查询一条数据为map集合"><a href="#查询一条数据为map集合" class="headerlink" title="查询一条数据为map集合"></a>查询一条数据为map集合</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 根据用户id查询用户信息为map集合  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getUserToMap</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getUserToMap(@Param(&quot;id&quot;) int id);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select * from t_user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--结果：&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="查询多条数据为map集合"><a href="#查询多条数据为map集合" class="headerlink" title="查询多条数据为map集合"></a>查询多条数据为map集合</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 查询所有用户信息为map集合  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  </span></span><br><span class="line"><span class="comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span>  </span><br><span class="line">select * from t_user  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">[&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;]</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询所有用户信息为map集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过<span class="doctag">@MapKey</span>注解设置map集合的键，值是每条数据所对应的map集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MapKey(&quot;id&quot;)</span></span><br><span class="line">Map&lt;String, Object&gt; <span class="title function_">getAllUserToMap</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Map&lt;String, Object&gt; getAllUserToMap();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllUserToMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">select * from t_user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">1=&#123;password=123456, sex=男, id=1, age=23, username=admin&#125;,</span></span><br><span class="line"><span class="comment">2=&#123;password=123456, sex=男, id=2, age=23, username=张三&#125;,</span></span><br><span class="line"><span class="comment">3=&#123;password=123456, sex=男, id=3, age=23, username=张三&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><h1 id="特殊SQL的执行"><a href="#特殊SQL的执行" class="headerlink" title="特殊SQL的执行"></a>特殊SQL的执行</h1><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户名进行模糊查询</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/26 21:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserByLike</span><span class="params">(<span class="meta">@Param(&quot;username&quot;)</span> String username)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByLike&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like &#x27;%$&#123;mohu&#125;%&#x27;--&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--select * from t_user where username like concat(&#x27;%&#x27;,#&#123;mohu&#125;,&#x27;%&#x27;)--&gt;</span>  </span><br><span class="line">select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>其中<code>select * from t_user where username like &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</code>是最常用的</li></ul><h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2><ul><li>只能使用${}，如果使用#{}，则解析后的sql语句为<code>delete from t_user where id in (&#39;1,2,3&#39;)</code>，这样是将<code>1,2,3</code>看做是一个整体，只有id为<code>1,2,3</code>的数据会被删除。正确的语句应该是<code>delete from t_user where id in (1,2,3)</code>，或者<code>delete from t_user where id in (&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据id批量删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ids </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/26 22:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deleteMore</span><span class="params">(<span class="meta">@Param(&quot;ids&quot;)</span> String ids)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMore&quot;</span>&gt;</span></span><br><span class="line">delete from t_user where id in ($&#123;ids&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMore</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">SQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SQLMapper.class);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.deleteMore(<span class="string">&quot;1,2,3,8&quot;</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="动态设置表名"><a href="#动态设置表名" class="headerlink" title="动态设置表名"></a>动态设置表名</h2><ul><li>只能使用${}，因为表名不能加单引号<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询指定表中的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tableName </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.User&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 14:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUserByTable</span><span class="params">(<span class="meta">@Param(&quot;tableName&quot;)</span> String tableName)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;User&gt; getUserByTable(@Param(&quot;tableName&quot;) String tableName);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserByTable&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">select * from $&#123;tableName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="添加功能获取自增的主键"><a href="#添加功能获取自增的主键" class="headerlink" title="添加功能获取自增的主键"></a>添加功能获取自增的主键</h2><ul><li>使用场景<ul><li>t_clazz(clazz_id,clazz_name)  </li><li>t_student(student_id,student_name,clazz_id)</li></ul><ol><li>添加班级信息  </li><li>获取新添加的班级的id  </li><li>为班级分配学生，即将某学的班级id修改为新添加的班级的id</li></ol></li><li>在mapper.xml中设置两个属性<ul><li>useGeneratedKeys：设置使用自增的主键</li></ul><ul><li>keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加用户信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 15:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--void insertUser(User user);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">insert into t_user values (null,#&#123;username&#125;,#&#123;password&#125;,#&#123;age&#125;,#&#123;sex&#125;,#&#123;email&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">SQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(SQLMapper.class);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="literal">null</span>, <span class="string">&quot;ton&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;123@321.com&quot;</span>);</span><br><span class="line">mapper.insertUser(user);</span><br><span class="line">System.out.println(user);</span><br><span class="line"><span class="comment">//输出：user&#123;id=10, username=&#x27;ton&#x27;, password=&#x27;123&#x27;, age=23, sex=&#x27;男&#x27;, email=&#x27;123@321.com&#x27;&#125;，自增主键存放到了user的id属性中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="自定义映射resultMap"><a href="#自定义映射resultMap" class="headerlink" title="自定义映射resultMap"></a>自定义映射resultMap</h1><h2 id="resultMap处理字段和属性的映射关系"><a href="#resultMap处理字段和属性的映射关系" class="headerlink" title="resultMap处理字段和属性的映射关系"></a>resultMap处理字段和属性的映射关系</h2><ul><li><p>resultMap：设置自定义映射  </p><ul><li>属性：  <ul><li>id：表示自定义映射的唯一标识，不能重复</li><li>type：查询的数据要映射的实体类的类型</li></ul></li><li>子标签：  <ul><li>id：设置主键的映射关系  </li><li>result：设置普通字段的映射关系  </li><li>子标签属性：  <ul><li>property：设置映射关系中实体类中的属性名  </li><li>column：设置映射关系中表中的字段名</li></ul></li></ul></li></ul></li><li><p>若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系  </p><ol><li>可以通过为字段起别名的方式，保证和实体类中的属性名保持一致   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getAllEmp();--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select eid,emp_name empName,age,sex,email from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>可以在MyBatis的核心配置文件中的<code>setting</code>标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。<a href="#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">核心配置文件详解</a> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="多对一映射处理"><a href="#多对一映射处理" class="headerlink" title="多对一映射处理"></a>多对一映射处理</h2><blockquote><p>查询员工信息以及员工所对应的部门信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emp</span> &#123;  </span><br><span class="line"><span class="keyword">private</span> Integer eid;  </span><br><span class="line"><span class="keyword">private</span> String empName;  </span><br><span class="line"><span class="keyword">private</span> Integer age;  </span><br><span class="line"><span class="keyword">private</span> String sex;  </span><br><span class="line"><span class="keyword">private</span> String email;  </span><br><span class="line"><span class="keyword">private</span> Dept dept;</span><br><span class="line"><span class="comment">//...构造器、get、set方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="级联方式处理映射关系"><a href="#级联方式处理映射关系" class="headerlink" title="级联方式处理映射关系"></a>级联方式处理映射关系</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;dept.deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapOne&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用association处理映射关系"><a href="#使用association处理映射关系" class="headerlink" title="使用association处理映射关系"></a>使用association处理映射关系</h3><ul><li>association：处理多对一的映射关系</li><li>property：需要处理多对的映射关系的属性名</li><li>javaType：该属性的类型<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDept(@Param(&quot;eid&quot;)Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDept&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptResultMapTwo&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="分步查询"><a href="#分步查询" class="headerlink" title="分步查询"></a>分步查询</h3><h4 id="1-查询员工信息"><a href="#1-查询员工信息" class="headerlink" title="1. 查询员工信息"></a>1. 查询员工信息</h4><ul><li>select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名）</li><li>column：设置分步查询的条件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//EmpMapper里的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，员工及所对应的部门信息</span></span><br><span class="line"><span class="comment"> * 分步查询第一步：查询员工信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Emp <span class="title function_">getEmpAndDeptByStepOne</span><span class="params">(<span class="meta">@Param(&quot;eid&quot;)</span> Integer eid)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Emp getEmpAndDeptByStepOne(@Param(&quot;eid&quot;) Integer eid);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where eid = #&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-查询部门信息"><a href="#2-查询部门信息" class="headerlink" title="2. 查询部门信息"></a>2. 查询部门信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DeptMapper里的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，员工及所对应的部门信息</span></span><br><span class="line"><span class="comment"> * 分步查询第二步：通过did查询员工对应的部门信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Emp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 20:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Dept <span class="title function_">getEmpAndDeptByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处的resultMap仅是处理字段和属性的映射关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getEmpAndDeptByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpAndDeptByStepTwo&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;EmpAndDeptByStepTwoResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="一对多映射处理"><a href="#一对多映射处理" class="headerlink" title="一对多映射处理"></a>一对多映射处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dept</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer did;</span><br><span class="line">    <span class="keyword">private</span> String deptName;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Emp&gt; emps;</span><br><span class="line"><span class="comment">//...构造器、get、set方法等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><ul><li>collection：用来处理一对多的映射关系</li><li>ofType：表示该属性对饮的集合中存储的数据的类型<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptAndEmp(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="分步查询-1"><a href="#分步查询-1" class="headerlink" title="分步查询"></a>分步查询</h3><h4 id="1-查询部门信息"><a href="#1-查询部门信息" class="headerlink" title="1. 查询部门信息"></a>1. 查询部门信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，查询部门及对应的所有员工信息</span></span><br><span class="line"><span class="comment"> * 分步查询第一步：查询部门信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> did </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> com.atguigu.mybatis.pojo.Dept</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 22:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Dept <span class="title function_">getDeptAndEmpByStepOne</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Dept&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;did&quot;</span> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;deptName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;dept_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;emps&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">column</span>=<span class="string">&quot;did&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Dept getDeptAndEmpByStepOne(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepOne&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;DeptAndEmpByStepOneResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_dept where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-根据部门id查询部门中的所有员工"><a href="#2-根据部门id查询部门中的所有员工" class="headerlink" title="2. 根据部门id查询部门中的所有员工"></a>2. 根据部门id查询部门中的所有员工</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过分步查询，查询部门及对应的所有员工信息</span></span><br><span class="line"><span class="comment"> * 分步查询第二步：根据部门id查询部门中的所有员工</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> did</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> java.util.List&lt;com.atguigu.mybatis.pojo.Emp&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/2/27 22:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;Emp&gt; <span class="title function_">getDeptAndEmpByStepTwo</span><span class="params">(<span class="meta">@Param(&quot;did&quot;)</span> Integer did)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getDeptAndEmpByStepTwo(@Param(&quot;did&quot;) Integer did);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getDeptAndEmpByStepTwo&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where did = #&#123;did&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><ul><li>分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息：<ul><li>lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载  </li><li>aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载</li></ul></li><li>此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmpAndDeptByStepOne</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.getEmpAndDeptByStepOne(<span class="number">1</span>);</span><br><span class="line">System.out.println(emp.getEmpName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>关闭延迟加载，两条SQL语句都运行了<img src="/../image/MyBatisPic/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%951.png"></p></li><li><p>开启延迟加载，只运行获取emp的SQL语句<br><img src="/../image/MyBatisPic/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%952.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmpAndDeptByStepOne</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp</span> <span class="operator">=</span> mapper.getEmpAndDeptByStepOne(<span class="number">1</span>);</span><br><span class="line">System.out.println(emp.getEmpName());</span><br><span class="line">System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">System.out.println(emp.getDept());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启后，需要用到查询dept的时候才会调用相应的SQL语句<img src="/../image/MyBatisPic/%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E6%B5%8B%E8%AF%953.png"></p></li><li><p>fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType&#x3D;”lazy(延迟加载)|eager(立即加载)”</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empAndDeptByStepResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;empName&quot;</span> <span class="attr">column</span>=<span class="string">&quot;emp_name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;dept&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">select</span>=<span class="string">&quot;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">column</span>=<span class="string">&quot;did&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><ul><li>Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题</li></ul><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><ul><li>if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行</li><li>在where后面添加一个恒成立条件<code>1=1</code><ul><li>这个恒成立条件并不会影响查询的结果</li><li>这个<code>1=1</code>可以用来拼接<code>and</code>语句，例如：当empName为null时<ul><li>如果不加上恒成立条件，则SQL语句为<code>select * from t_emp where and age = ? and sex = ? and email = ?</code>，此时<code>where</code>会与<code>and</code>连用，SQL语句会报错</li><li>如果加上一个恒成立条件，则SQL语句为<code>select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?</code>，此时不报错</li></ul></li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp where 1=1</span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="where"><a href="#where" class="headerlink" title="where"></a>where</h2><ul><li><p>where和if一般结合使用：</p><ul><li>若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字  </li><li>若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and&#x2F;or去掉  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">and email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意：where标签不能去掉条件后多余的and&#x2F;or</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><ul><li>trim用于去掉或添加标签中的内容  </li><li>常用属性<ul><li>prefix：在trim标签中的内容的前面添加某些内容  </li><li>suffix：在trim标签中的内容的后面添加某些内容 </li><li>prefixOverrides：在trim标签中的内容的前面去掉某些内容  </li><li>suffixOverrides：在trim标签中的内容的后面去掉某些内容</li></ul></li><li>若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下<code>select * from t_emp</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">&quot;where&quot;</span> <span class="attr">suffixOverrides</span>=<span class="string">&quot;and|or&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125; and</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125; or</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email !=&#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmpByCondition</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">List&lt;Emp&gt; emps= mapper.getEmpByCondition(<span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;张三&quot;</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>));</span><br><span class="line">System.out.println(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/../image/MyBatisPic/trim%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></li></ul><h2 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h2><ul><li><code>choose、when、otherwise</code>相当于<code>if...else if..else</code></li><li>when至少要有一个，otherwise至多只有一个<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByChoose&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;empName != null and empName != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">emp_name = #&#123;empName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;age != null and age != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">age = #&#123;age&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;sex != null and sex != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">sex = #&#123;sex&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;email != null and email != &#x27;&#x27;&quot;</span>&gt;</span></span><br><span class="line">email = #&#123;email&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">did = 1</span><br><span class="line"><span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getEmpByChoose</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line">List&lt;Emp&gt; emps = mapper.getEmpByChoose(<span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">23</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;123@qq.com&quot;</span>, <span class="literal">null</span>));</span><br><span class="line">System.out.println(emps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/../image/MyBatisPic/choose%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></li><li>相当于<code>if a else if b else if c else d</code>，只会执行其中一个</li></ul><h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><ul><li><p>属性：  </p><ul><li>collection：设置要循环的数组或集合  </li><li>item：表示集合或数组中的每一个数据  </li><li>separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如<code>,</code></li><li>open：设置foreach标签中的内容的开始符  </li><li>close：设置foreach标签中的内容的结束符</li></ul></li><li><p>批量删除</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int deleteMoreByArray(Integer[] eids);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteMoreByArray&quot;</span>&gt;</span></span><br><span class="line">delete from t_emp where eid in</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;eids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;eid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">#&#123;eid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteMoreByArray</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.deleteMoreByArray(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/../image/MyBatisPic/foreach%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png"></p></li><li><p>批量添加</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--int insertMoreByList(@Param(&quot;emps&quot;) List&lt;Emp&gt; emps);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertMoreByList&quot;</span>&gt;</span></span><br><span class="line">insert into t_emp values</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;emps&quot;</span> <span class="attr">item</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">(null,#&#123;emp.empName&#125;,#&#123;emp.age&#125;,#&#123;emp.sex&#125;,#&#123;emp.email&#125;,null)</span><br><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertMoreByList</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> SqlSessionUtils.getSqlSession();</span><br><span class="line"><span class="type">DynamicSQLMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(DynamicSQLMapper.class);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>,<span class="string">&quot;a&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>,<span class="string">&quot;b&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="type">Emp</span> <span class="variable">emp3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Emp</span>(<span class="literal">null</span>,<span class="string">&quot;c&quot;</span>,<span class="number">1</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;123@321.com&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">List&lt;Emp&gt; emps = Arrays.asList(emp1, emp2, emp3);</span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> mapper.insertMoreByList(emps);</span><br><span class="line">System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <img src="/../image/MyBatisPic/foreach%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png"></p></li></ul><h2 id="SQL片段"><a href="#SQL片段" class="headerlink" title="SQL片段"></a>SQL片段</h2><ul><li>sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入</li><li>声明sql片段：<code>&lt;sql&gt;</code>标签<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span>eid,emp_name,age,sex,email<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>引用sql片段：<code>&lt;include&gt;</code>标签<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--List&lt;Emp&gt; getEmpByCondition(Emp emp);--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpByCondition&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;empColumns&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span> from t_emp</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="MyBatis的缓存"><a href="#MyBatis的缓存" class="headerlink" title="MyBatis的缓存"></a>MyBatis的缓存</h1><h2 id="MyBatis的一级缓存"><a href="#MyBatis的一级缓存" class="headerlink" title="MyBatis的一级缓存"></a>MyBatis的一级缓存</h2><ul><li><p>一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问  </p></li><li><p>使一级缓存失效的四种情况：  </p><ol><li>不同的SqlSession对应不同的一级缓存  </li><li>同一个SqlSession但是查询条件不同</li><li>同一个SqlSession两次查询期间执行了任何一次增删改操作</li><li>同一个SqlSession两次查询期间手动清空了缓存</li></ol></li></ul><h2 id="MyBatis的二级缓存"><a href="#MyBatis的二级缓存" class="headerlink" title="MyBatis的二级缓存"></a>MyBatis的二级缓存</h2><ul><li><p>二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取  </p></li><li><p>二级缓存开启的条件</p><ol><li>在核心配置文件中，设置全局配置属性cacheEnabled&#x3D;”true”，默认为true，不需要设置</li><li>在映射文件中设置标签<cache /></li><li>二级缓存必须在SqlSession关闭或提交之后有效</li><li>查询的数据所转换的实体类类型必须实现序列化的接口</li></ol></li><li><p>使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效</p></li></ul><h2 id="二级缓存的相关配置"><a href="#二级缓存的相关配置" class="headerlink" title="二级缓存的相关配置"></a>二级缓存的相关配置</h2><ul><li>在mapper配置文件中添加的cache标签可以设置一些属性</li><li>eviction属性：缓存回收策略  <ul><li>LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。  </li><li>FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。  </li><li>SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。  </li><li>WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li><li>默认的是 LRU</li></ul></li><li>flushInterval属性：刷新间隔，单位毫秒<ul><li>默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新</li></ul></li><li>size属性：引用数目，正整数<ul><li>代表缓存最多可以存储多少个对象，太大容易导致内存溢出</li></ul></li><li>readOnly属性：只读，true&#x2F;false<ul><li>true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。  </li><li>false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false</li></ul></li></ul><h2 id="MyBatis缓存查询的顺序"><a href="#MyBatis缓存查询的顺序" class="headerlink" title="MyBatis缓存查询的顺序"></a>MyBatis缓存查询的顺序</h2><ul><li>先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用  </li><li>如果二级缓存没有命中，再查询一级缓存  </li><li>如果一级缓存也没有命中，则查询数据库  </li><li>SqlSession关闭之后，一级缓存中的数据会写入二级缓存</li></ul><h2 id="整合第三方缓存EHCache（了解）"><a href="#整合第三方缓存EHCache（了解）" class="headerlink" title="整合第三方缓存EHCache（了解）"></a>整合第三方缓存EHCache（了解）</h2><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Mybatis EHCache整合包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- slf4j日志门面的一个具体实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="各个jar包的功能"><a href="#各个jar包的功能" class="headerlink" title="各个jar包的功能"></a>各个jar包的功能</h3><table><thead><tr><th>jar包名称</th><th>作用</th></tr></thead><tbody><tr><td>mybatis-ehcache</td><td>Mybatis和EHCache的整合包</td></tr><tr><td>ehcache</td><td>EHCache核心包</td></tr><tr><td>slf4j-api</td><td>SLF4J日志门面包</td></tr><tr><td>logback-classic</td><td>支持SLF4J门面接口的一个具体实现</td></tr></tbody></table><h3 id="创建EHCache的配置文件ehcache-xml"><a href="#创建EHCache的配置文件ehcache-xml" class="headerlink" title="创建EHCache的配置文件ehcache.xml"></a>创建EHCache的配置文件ehcache.xml</h3><ul><li>名字必须叫<code>ehcache.xml</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">&quot;../config/ehcache.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 磁盘保存路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;D:\atguigu\ehcache&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">maxElementsOnDisk</span>=<span class="string">&quot;10000000&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">&quot;LRU&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="设置二级缓存的类型"><a href="#设置二级缓存的类型" class="headerlink" title="设置二级缓存的类型"></a>设置二级缓存的类型</h3><ul><li>在xxxMapper.xml文件中设置二级缓存类型<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="加入logback日志"><a href="#加入logback日志" class="headerlink" title="加入logback日志"></a>加入logback日志</h3><ul><li>存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件<code>logback.xml</code>，名字固定，不可改变<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定日志输出的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;STDOUT&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志输出的格式 --&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 根据特殊需求指定局部日志级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.atguigu.crowd.mapper&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="EHCache配置文件说明"><a href="#EHCache配置文件说明" class="headerlink" title="EHCache配置文件说明"></a>EHCache配置文件说明</h3><table><thead><tr><th>属性名</th><th>是否必须</th><th>作用</th></tr></thead><tbody><tr><td>maxElementsInMemory</td><td>是</td><td>在内存中缓存的element的最大数目</td></tr><tr><td>maxElementsOnDisk</td><td>是</td><td>在磁盘上缓存的element的最大数目，若是0表示无穷大</td></tr><tr><td>eternal</td><td>是</td><td>设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断</td></tr><tr><td>overflowToDisk</td><td>是</td><td>设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上</td></tr><tr><td>timeToIdleSeconds</td><td>否</td><td>当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大</td></tr><tr><td>timeToLiveSeconds</td><td>否</td><td>缓存element的有效生命期，默认是0.,也就是element存活时间无穷大</td></tr><tr><td>diskSpoolBufferSizeMB</td><td>否</td><td>DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区</td></tr><tr><td>diskPersistent</td><td>否</td><td>在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false</td></tr><tr><td>diskExpiryThreadIntervalSeconds</td><td>否</td><td>磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作</td></tr><tr><td>memoryStoreEvictionPolicy</td><td>否</td><td>当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出</td></tr></tbody></table><h1 id="MyBatis的逆向工程"><a href="#MyBatis的逆向工程" class="headerlink" title="MyBatis的逆向工程"></a>MyBatis的逆向工程</h1><ul><li>正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的</li><li>逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：  <ul><li>Java实体类  </li><li>Mapper接口  </li><li>Mapper映射文件</li></ul></li></ul><h2 id="创建逆向工程的步骤"><a href="#创建逆向工程的步骤" class="headerlink" title="创建逆向工程的步骤"></a>创建逆向工程的步骤</h2><h3 id="添加依赖和插件"><a href="#添加依赖和插件" class="headerlink" title="添加依赖和插件"></a>添加依赖和插件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MyBatis核心依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- junit测试 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- log4j日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 控制Maven在构建过程中相关配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 构建过程中用到的插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 插件的依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 逆向工程的核心依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.27<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建MyBatis的核心配置文件-1"><a href="#创建MyBatis的核心配置文件-1" class="headerlink" title="创建MyBatis的核心配置文件"></a>创建MyBatis的核心配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建逆向工程的配置文件"><a href="#创建逆向工程的配置文件" class="headerlink" title="创建逆向工程的配置文件"></a>创建逆向工程的配置文件</h3><ul><li>文件名必须是：<code>generatorConfig.xml</code><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    targetRuntime: 执行生成的逆向工程的版本</span></span><br><span class="line"><span class="comment">    MyBatis3Simple: 生成基本的CRUD（清新简洁版）</span></span><br><span class="line"><span class="comment">    MyBatis3: 生成带条件的CRUD（奢华尊享版）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">&quot;DB2Tables&quot;</span> <span class="attr">targetRuntime</span>=<span class="string">&quot;MyBatis3Simple&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 数据库的连接信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- javaBean的生成策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.pojo&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;trimStrings&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- SQL映射文件的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\resources&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Mapper接口的生成策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">&quot;XMLMAPPER&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetPackage</span>=<span class="string">&quot;com.atguigu.mybatis.mapper&quot;</span> <span class="attr">targetProject</span>=<span class="string">&quot;.\src\main\java&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;enableSubPackages&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 逆向分析的表 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_emp&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Emp&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">&quot;t_dept&quot;</span> <span class="attr">domainObjectName</span>=<span class="string">&quot;Dept&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="执行MBG插件的generate目标"><a href="#执行MBG插件的generate目标" class="headerlink" title="执行MBG插件的generate目标"></a>执行MBG插件的generate目标</h3><ul><li><img src="/../image/MyBatisPic/%E6%89%A7%E8%A1%8CMBG%E6%8F%92%E4%BB%B6%E7%9A%84generate%E7%9B%AE%E6%A0%87.png"></li><li>如果出现报错：<code>Exception getting JDBC Driver</code>，可能是pom.xml中，数据库驱动配置错误<ul><li>dependency中的驱动<img src="/../image/MyBatisPic/dependency%E4%B8%AD%E7%9A%84%E9%A9%B1%E5%8A%A8.png"></li><li>mybatis-generator-maven-plugin插件中的驱动<img src="/../image/MyBatisPic/%E6%8F%92%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%A9%B1%E5%8A%A8.png"></li><li>两者的驱动版本应该相同</li></ul></li><li>执行结果<img src="/../image/MyBatisPic/%E9%80%86%E5%90%91%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></li></ul><h2 id="QBC"><a href="#QBC" class="headerlink" title="QBC"></a>QBC</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ul><li><code>selectByExample</code>：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据</li><li><code>example.createCriteria().xxx</code>：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系</li><li><code>example.or().xxx</code>：将之前添加的条件通过or拼接其他条件<br><img src="/../image/MyBatisPic/example%E7%9A%84%E6%96%B9%E6%B3%95.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMBG</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="type">EmpExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmpExample</span>();</span><br><span class="line"><span class="comment">//名字为张三，且年龄大于等于20</span></span><br><span class="line">example.createCriteria().andEmpNameEqualTo(<span class="string">&quot;张三&quot;</span>).andAgeGreaterThanOrEqualTo(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//或者did不为空</span></span><br><span class="line">example.or().andDidIsNotNull();</span><br><span class="line">List&lt;Emp&gt; emps = mapper.selectByExample(example);</span><br><span class="line">emps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/../image/MyBatisPic/example%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></li></ul><h3 id="增改"><a href="#增改" class="headerlink" title="增改"></a>增改</h3><ul><li><code>updateByPrimaryKey</code>：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null<ul><li><code>mapper.updateByPrimaryKey(new Emp(1,&quot;admin&quot;,22,null,&quot;456@qq.com&quot;,3));</code></li><li><img src="/../image/MyBatisPic/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C1.png"></li></ul></li><li><code>updateByPrimaryKeySelective()</code>：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段<ul><li><code>mapper.updateByPrimaryKeySelective(new Emp(2,&quot;admin2&quot;,22,null,&quot;456@qq.com&quot;,3));</code></li><li><img src="/../image/MyBatisPic/%E5%A2%9E%E5%88%A0%E6%94%B9%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C2.png"></li></ul></li></ul><h1 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h1><h2 id="分页插件使用步骤"><a href="#分页插件使用步骤" class="headerlink" title="分页插件使用步骤"></a>分页插件使用步骤</h2><h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置分页插件"><a href="#配置分页插件" class="headerlink" title="配置分页插件"></a>配置分页插件</h3><ul><li>在MyBatis的核心配置文件（mybatis-config.xml）中配置插件</li><li><img src="/../image/MyBatisPic/%E9%85%8D%E7%BD%AE%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6.png"><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置分页插件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="分页插件的使用"><a href="#分页插件的使用" class="headerlink" title="分页插件的使用"></a>分页插件的使用</h2><h3 id="开启分页功能"><a href="#开启分页功能" class="headerlink" title="开启分页功能"></a>开启分页功能</h3><ul><li>在查询功能之前使用<code>PageHelper.startPage(int pageNum, int pageSize)</code>开启分页功能<ul><li>pageNum：当前页的页码  </li><li>pageSize：每页显示的条数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="comment">//访问第一页，每页四条数据</span></span><br><span class="line">PageHelper.startPage(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">List&lt;Emp&gt; emps = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line">emps.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="/../image/MyBatisPic/%E5%88%86%E9%A1%B5%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.png"></p><h3 id="分页相关数据"><a href="#分页相关数据" class="headerlink" title="分页相关数据"></a>分页相关数据</h3><h4 id="方法一：直接输出"><a href="#方法一：直接输出" class="headerlink" title="方法一：直接输出"></a>方法一：直接输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line"><span class="comment">//访问第一页，每页四条数据</span></span><br><span class="line">Page&lt;Object&gt; page = PageHelper.startPage(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Emp&gt; emps = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//在查询到List集合后，打印分页数据</span></span><br><span class="line">System.out.println(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>分页相关数据：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#x27;admin&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=2, empName=&#x27;admin2&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=3, empName=&#x27;王五&#x27;, age=12, sex=&#x27;女&#x27;, email=&#x27;123@qq.com&#x27;, did=3&#125;, Emp&#123;eid=4, empName=&#x27;赵六&#x27;, age=32, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;, did=1&#125;]</span><br></pre></td></tr></table></figure></li></ul><h4 id="方法二使用PageInfo"><a href="#方法二使用PageInfo" class="headerlink" title="方法二使用PageInfo"></a>方法二使用PageInfo</h4><ul><li><p>在查询获取list集合之后，使用<code>PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, intnavigatePages)</code>获取分页相关数据</p><ul><li>list：分页之后的数据  </li><li>navigatePages：导航分页的页码数<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageHelper</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line"><span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(is);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">EmpMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> sqlSession.getMapper(EmpMapper.class);</span><br><span class="line">PageHelper.startPage(<span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line">List&lt;Emp&gt; emps = mapper.selectByExample(<span class="literal">null</span>);</span><br><span class="line">PageInfo&lt;Emp&gt; page = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt;(emps,<span class="number">5</span>);</span><br><span class="line">System.out.println(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>分页相关数据：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PageInfo&#123;</span><br><span class="line">pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=8, pages=2, </span><br><span class="line">list=Page&#123;count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false&#125;[Emp&#123;eid=1, empName=&#x27;admin&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=2, empName=&#x27;admin2&#x27;, age=22, sex=&#x27;男&#x27;, email=&#x27;456@qq.com&#x27;, did=3&#125;, Emp&#123;eid=3, empName=&#x27;王五&#x27;, age=12, sex=&#x27;女&#x27;, email=&#x27;123@qq.com&#x27;, did=3&#125;, Emp&#123;eid=4, empName=&#x27;赵六&#x27;, age=32, sex=&#x27;男&#x27;, email=&#x27;123@qq.com&#x27;, did=1&#125;], </span><br><span class="line">prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]&#125;</span><br></pre></td></tr></table></figure></li><li><p>其中list中的数据等同于方法一中直接输出的page数据</p></li></ul><h4 id="常用数据："><a href="#常用数据：" class="headerlink" title="常用数据："></a>常用数据：</h4><ul><li>pageNum：当前页的页码  </li><li>pageSize：每页显示的条数  </li><li>size：当前页显示的真实条数  </li><li>total：总记录数  </li><li>pages：总页数  </li><li>prePage：上一页的页码  </li><li>nextPage：下一页的页码</li><li>isFirstPage&#x2F;isLastPage：是否为第一页&#x2F;最后一页  </li><li>hasPreviousPage&#x2F;hasNextPage：是否存在上一页&#x2F;下一页  </li><li>navigatePages：导航分页的页码数  </li><li>navigatepageNums：导航分页的页码，[1,2,3,4,5]</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-笔记</title>
      <link href="/2024/04/09/MySQL/"/>
      <url>/2024/04/09/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="SQL-的通用语法"><a href="#SQL-的通用语法" class="headerlink" title="SQL 的通用语法"></a>SQL 的通用语法</h3><p>1.单行或多行书写，分号结尾 2.使用空格或缩进增强语句的可读性<br>3.MySQL 数据库不区分大小写，关键字建议大写 4.注释：<br><code>单行注释：--注释内容或#注释内容（MySQL）特有</code><br><code>多行注释：/*注释内容*/</code></p><h3 id="SQL-的分类"><a href="#SQL-的分类" class="headerlink" title="SQL 的分类"></a>SQL 的分类</h3><ul><li>DDL(Data Dedinition Language)<br><code>数据定义语言，用来定义数据库对象(数据库，表，字段)</code></li><li>DML(Data Manipulation Language)<br><code>数据操作语言，用来对数据库中的数据进行增删改</code></li><li>DQL(Data Quary Language)<br><code>数据查询语言，用来查询数据库中表的记录</code></li><li>DCL(Data Contril Language)<br><code>数据控制语言，用来创建数据库用户、控制数据库的访问权限</code></li></ul><h4 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL 数据定义语言"></a>DDL 数据定义语言</h4><h5 id="DDL-数据库的操作"><a href="#DDL-数据库的操作" class="headerlink" title="DDL-数据库的操作"></a>DDL-数据库的操作</h5><ul><li>查询<br>查询所有数据库<br><code>SHOW DATABASES;</code><br>查询当前数据库<br><code>SELECT DATABASE();</code></li><li>创建<br><code>CREATE DATABASE [IF NOT EXISTE] 数据库名[DEFAULT CHARTSET字符集][COLLATE排序规则];</code></li><li>删除<br><code>DROP DATABASE[IF EXISTS]数据库名;</code></li><li>使用<br><code>USE 数据库名;</code><br>注意事项<br><code>·UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集</code></li></ul><h5 id="DDL-表操作-查询"><a href="#DDL-表操作-查询" class="headerlink" title="DDL-表操作-查询"></a>DDL-表操作-查询</h5><ul><li>查询当前数据库所有表<br><code>SHOW TABLES;</code></li><li>查询表结构<br><code>DESC 表名;</code></li><li>查询指定表的建表语句<br><code>SHOW CREATE TABLE 表名;</code></li></ul><h5 id="DDL-表操作-创建"><a href="#DDL-表操作-创建" class="headerlink" title="DDL-表操作-创建"></a>DDL-表操作-创建</h5><figure class="highlight plaintext"><figcaption><span>TABLE 表名(</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字段1 字段1类型 [COMMENT 字段1注释],</span><br><span class="line">字段2 字段2类型 [COMMENT 字段2注释],</span><br><span class="line">字段3 字段3类型 [COMMENT 字段3注释],</span><br><span class="line">...</span><br><span class="line">字段n 字段n类型 [COMMENT 字段n注释]</span><br><span class="line">)[ COMMENT 表注释 ];</span><br><span class="line"># 最后一个字段后面没有逗号</span><br></pre></td></tr></table></figure><h5 id="DDL-添加字段"><a href="#DDL-添加字段" class="headerlink" title="DDL-添加字段"></a>DDL-添加字段</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> 字段名 类型(长度)[COMMENT注释][约束]</span><br><span class="line">exp：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp <span class="keyword">ADD</span> nickname <span class="type">varchar</span>(<span class="number">20</span>) COMMENT <span class="string">&#x27;昵称&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="DDL-修改数据类型"><a href="#DDL-修改数据类型" class="headerlink" title="DDL-修改数据类型"></a>DDL-修改数据类型</h5><p><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code></p><h5 id="DDL-修改字段名和字段类型"><a href="#DDL-修改字段名和字段类型" class="headerlink" title="DDL-修改字段名和字段类型"></a>DDL-修改字段名和字段类型</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 CHANGE 旧字段名 新字段名 类型(长度)[COMMENT 注释][约束]</span><br><span class="line">exp：将emp表的nickname字段修改为username，类型为<span class="type">varchar</span>(<span class="number">30</span>)</span><br><span class="line"><span class="keyword">ALTER</span> emp CHANGE nickname username <span class="type">varchar</span>(<span class="number">30</span>) COMMENT <span class="string">&#x27;昵称&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="DDL-删除字段"><a href="#DDL-删除字段" class="headerlink" title="DDL-删除字段"></a>DDL-删除字段</h5><p><code>ALTER TABLE 表名 DROP 字段名</code></p><h5 id="DDL-修改表名"><a href="#DDL-修改表名" class="headerlink" title="DDL-修改表名"></a>DDL-修改表名</h5><p><code>ALTER TABLE 表名 RENAME TO 新表名</code></p><h5 id="DDL-删除表"><a href="#DDL-删除表" class="headerlink" title="DDL-删除表"></a>DDL-删除表</h5><p><code>DROP TABLE [IF EXISTS] 表名</code></p><h5 id="DDL-删除并重新创建该表"><a href="#DDL-删除并重新创建该表" class="headerlink" title="DDL-删除并重新创建该表"></a>DDL-删除并重新创建该表</h5><p><code>TRUNCATE TABLE 表名</code></p><h4 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML 数据操作语言"></a>DML 数据操作语言</h4><h5 id="DML-添加数据"><a href="#DML-添加数据" class="headerlink" title="DML-添加数据"></a>DML-添加数据</h5><ul><li>指定字段：<br><code>INSERT INTO 表名(字段名1，字段名2，...) VALUES (值1，值2，...);</code></li><li>全部字段：<br><code>INSERT INTO 表名 VALUES (值1，值2，...);</code></li><li>批量添加数据：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code><br><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></li></ul><h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><p><code>字符串和日期类型数据应该包含在引号中</code><br><code>插入的数据大小应该在字段的规定范围内</code></p><h5 id="DML-更新和删除数据"><a href="#DML-更新和删除数据" class="headerlink" title="DML-更新和删除数据"></a>DML-更新和删除数据</h5><ul><li>修改数据<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 字段名<span class="number">1</span> <span class="operator">=</span> 值<span class="number">1</span>，字段名<span class="number">2</span> <span class="operator">=</span> 值<span class="number">2</span>，...[<span class="keyword">WHERE</span> 条件]；</span><br><span class="line">exp：</span><br><span class="line"><span class="keyword">UPDATE</span> emp <span class="keyword">SET</span> name <span class="operator">=</span> <span class="string">&#x27;Jack&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li>删除数据<br><code>DELETE FROM 表名 [WHERE 条件];</code></li></ul><h4 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL 数据查询语言"></a>DQL 数据查询语言</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">字段列表</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">表名字段</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">条件列表</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">分组字段列表</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line">分组后的条件列表</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">排序字段列表</span><br><span class="line">LIMIT</span><br><span class="line">分页参数</span><br></pre></td></tr></table></figure><h5 id="DQL-基础查询"><a href="#DQL-基础查询" class="headerlink" title="DQL-基础查询"></a>DQL-基础查询</h5><ul><li>查询多个字段<br><code>SELECT 字段1，字段2，字段3，...，FROM 表名;</code><br><code>SELECT * FROM 表名;</code></li><li>设置别名<br><code>SELECT 字段1 [AS 别名1], 字段2[AS 别名2], 字段3[AS 别名3],...FROM 表名;</code><br><code>SELECT 字段1 别名1, 字段2 别名2, 字段3 别名3,...FROM DUAL;</code></li><li>去重<br><code>SELECT DISTINCT 字段列表 FROM 表名;</code></li><li>转义<br><code>SELECT * FROM DUAL WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;;</code><br><code>/之后的_不作为通配符</code></li></ul><h5 id="DQL-条件查询"><a href="#DQL-条件查询" class="headerlink" title="DQL-条件查询"></a>DQL-条件查询</h5><ul><li>语法：<br>SELECT 字段列表 FROM 表名 WHERE 条件列表;</li><li>条件：</li></ul><table><thead><tr><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>&#x3D;</td><td>等于</td></tr><tr><td>&lt;&gt;或!&#x3D;</td><td>不等于</td></tr><tr><td>BETWEEN…AND…</td><td>在某个范围内（含最小最大值）</td></tr><tr><td>IN(…)</td><td>在 in 之后列表中的值，多选一</td></tr><tr><td>LIKE 占位符</td><td>模糊匹配(_匹配单个字符,%匹配任意个字符)</td></tr><tr><td>IS NULL</td><td>是 NULL</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr><td>AND 或&amp;&amp;</td><td>并且（多个条件同时正确才正确）</td></tr><tr><td>OR 或</td><td>或者（多个条件一个正确就正确）</td></tr><tr><td>NOT 或！</td><td>非，不是</td></tr></tbody></table><ul><li>exp</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 年龄等于30</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"><span class="comment">-- 年龄小于30</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">30</span>;</span><br><span class="line"><span class="comment">-- 小于等于</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="operator">&lt;=</span> <span class="number">30</span>;</span><br><span class="line"><span class="comment">-- 没有身份证</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> idcard <span class="keyword">is</span> <span class="keyword">null</span> <span class="keyword">or</span> idcard <span class="operator">=</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="comment">-- 有身份证</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> idcard;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> idcard <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">-- 不等于</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="operator">!=</span> <span class="number">30</span>;</span><br><span class="line"><span class="comment">-- 年龄在20到30之间</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="keyword">between</span> <span class="number">20</span> <span class="keyword">and</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">20</span> <span class="keyword">and</span> age <span class="operator">&lt;=</span> <span class="number">30</span>;</span><br><span class="line"><span class="comment">-- 下面语句不报错，但查不到任何信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="keyword">between</span> <span class="number">30</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"><span class="comment">-- 性别为女且年龄小于30</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">30</span> <span class="keyword">and</span> gender <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span>;</span><br><span class="line"><span class="comment">-- 年龄等于25或30或35</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">25</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">30</span> <span class="keyword">or</span> age <span class="operator">=</span> <span class="number">35</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="keyword">in</span> (<span class="number">25</span>, <span class="number">30</span>, <span class="number">35</span>);</span><br><span class="line"><span class="comment">-- 姓名为两个字</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;__&#x27;</span>;</span><br><span class="line"><span class="comment">-- 身份证最后为X</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> idcard <span class="keyword">like</span> <span class="string">&#x27;%X&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="DQL-聚合查询-聚合函数"><a href="#DQL-聚合查询-聚合函数" class="headerlink" title="DQL-聚合查询(聚合函数)"></a>DQL-聚合查询(聚合函数)</h5><ul><li>常见聚合函数：</li></ul><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>count</td><td>统计数量</td></tr><tr><td>max</td><td>最大值</td></tr><tr><td>min</td><td>最小值</td></tr><tr><td>avg</td><td>平均值</td></tr><tr><td>sum</td><td>求和</td></tr></tbody></table><ul><li>语法：<br><code>SELECT 聚合函数(字段列表) FROM 表名;</code></li><li>exp：<br><code>SELECT count(id) from emploee where workaddress = &quot;广东省&quot;;</code></li></ul><h5 id="DQL-分组查询"><a href="#DQL-分组查询" class="headerlink" title="DQL-分组查询"></a>DQL-分组查询</h5><ul><li>语法：<br><code>SELECT 字段列表 FROM 表名[WHERE 条件] GROUP BY 分组字段名[HANVING 分组后的过滤条件];</code></li><li>where 和 having 的区别</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后</span></span><br><span class="line">  对结果进行过滤</span><br><span class="line"><span class="comment">-- 判断条件不同：where不能对聚合函数进行判断，而having可以</span></span><br></pre></td></tr></table></figure><ul><li>exp：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> employee <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="comment">-- 根据性别分组，统计男性和女性数量</span></span><br><span class="line"><span class="keyword">select</span> gender, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> employee <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="comment">-- 根据性别分组，统计男性和女性的平均年龄</span></span><br><span class="line"><span class="keyword">select</span> gender, <span class="built_in">avg</span>(age) <span class="keyword">from</span> employee <span class="keyword">group</span> <span class="keyword">by</span> gender;</span><br><span class="line"><span class="comment">-- 年龄小于45，并根据工作地址分组</span></span><br><span class="line"><span class="keyword">select</span> workaddress, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">45</span> <span class="keyword">group</span> <span class="keyword">by</span> workaddress;</span><br><span class="line"><span class="comment">-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址</span></span><br><span class="line"><span class="keyword">select</span> workaddress, <span class="built_in">count</span>(<span class="operator">*</span>) address_count <span class="keyword">from</span> employee <span class="keyword">where</span> age <span class="operator">&lt;</span> <span class="number">45</span> <span class="keyword">group</span> <span class="keyword">by</span> workaddress <span class="keyword">having</span> address_count <span class="operator">&gt;=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h6 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h6><ul><li>执行顺序：where&gt;聚合函数&gt;having</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h5 id="DQL-排序查询"><a href="#DQL-排序查询" class="headerlink" title="DQL-排序查询"></a>DQL-排序查询</h5><ul><li>ASC：升序（默认）</li><li>DESC：降序</li><li>exp：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据年龄升序排序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> age;</span><br><span class="line"><span class="comment">-- 两字段排序，根据年龄升序排序，入职时间降序排序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>, entrydate <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><h6 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h6><p>如果是多字段排序，当地一个字段值相同时，才会根据第二个字段进行排序</p><h5 id="DQL-分页查询"><a href="#DQL-分页查询" class="headerlink" title="DQL-分页查询"></a>DQL-分页查询</h5><ul><li>语法：<br><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code></li><li>exp：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询第一页数据，展示10条</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee LIMIT <span class="number">0</span>, <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 查询第二页</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee LIMIT <span class="number">10</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h6 id="注意事项-3"><a href="#注意事项-3" class="headerlink" title="注意事项"></a>注意事项</h6><ul><li>起始索引从 0 开始，其实索引&#x3D;(查询页码-1) * 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL 是 LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul><h5 id="DQL-执行顺序"><a href="#DQL-执行顺序" class="headerlink" title="DQL 执行顺序"></a>DQL 执行顺序</h5><h6 id="FROM-WHERE-GROUP-BY-SELECT-ORDER-BY-LIMIT"><a href="#FROM-WHERE-GROUP-BY-SELECT-ORDER-BY-LIMIT" class="headerlink" title="FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT"></a><strong>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</strong></h6><h4 id="DCL-数据控制语言"><a href="#DCL-数据控制语言" class="headerlink" title="DCL 数据控制语言"></a>DCL 数据控制语言</h4><h5 id="DCL-管理用户"><a href="#DCL-管理用户" class="headerlink" title="DCL-管理用户"></a>DCL-管理用户</h5><ul><li>查询用户<br><code>USE mysql;</code><br><code>SELECT * FROM user;</code></li><li>创建用户<br><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></li><li>修改用户密码<br><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</code></li><li>删除用户<br><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></li><li>exp：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建用户test，只能在当前主机localhost访问</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="comment">-- 创建用户test，能在任意主机访问</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;test&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="comment">-- 修改密码</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span> identified <span class="keyword">with</span> mysql_native_password <span class="keyword">by</span> <span class="string">&#x27;1234&#x27;</span>;</span><br><span class="line"><span class="comment">-- 删除用户</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;test&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="注意事项-4"><a href="#注意事项-4" class="headerlink" title="注意事项"></a>注意事项</h6><p><code>想要任意主机访问，主机名可以使用通配符%</code></p><h5 id="DCL-权限控制"><a href="#DCL-权限控制" class="headerlink" title="DCL-权限控制"></a>DCL-权限控制</h5><ul><li>常用权限：</li></ul><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>ALL,ALLPRIVILEGES</td><td>所有权限</td></tr><tr><td>SELECT</td><td>查询权限</td></tr><tr><td>INSERT</td><td>插入权限</td></tr><tr><td>UPDATE</td><td>修改权限</td></tr><tr><td>DELETE</td><td>删除权限</td></tr><tr><td>ALTER</td><td>修改表</td></tr><tr><td>DROP</td><td>删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td>CREATE</td><td>创建数据库&#x2F;表</td></tr></tbody></table><ul><li>查询权限<br>SHOW GRANT FOR ‘用户名‘@’主机名’;</li><li>授予权限<br>GRANT 权限列表 ON 数据库名&#x2F;表名 TO ‘用户名‘@’主机名’;</li><li>撤销权限<br>REVOKE 权限列表 ON 数据库名&#x2F;表名 FROM ‘用户名‘@’主机名’;</li></ul><h6 id="注意事项-5"><a href="#注意事项-5" class="headerlink" title="注意事项"></a>注意事项</h6><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用*进行通配，代表所有</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><h3 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CONCAT(s1,s2,…sn)</td><td>字符串拼接，将 s1，s2，…，sn 拼接成一个字符串</td></tr><tr><td>LOWER(str)</td><td>将字符串全部转为小写</td></tr><tr><td>UPPER(str)</td><td>将字符串全部转为大写</td></tr><tr><td>LPAD(str,n,pad)</td><td>左填充，用字符串 pad 对 str 的左边进行填充，达到 n 个字符串长度</td></tr><tr><td>RPAD(str,n,pad)</td><td>右填充，用字符串 pad 对 str 的右边进行填充，达到 n 个字符串长度</td></tr><tr><td>TRIM(str)</td><td>去掉字符串头部和尾部的空格</td></tr><tr><td>SUBSTRING(str,start,len)</td><td>返回从字符串 str 从 start 位置起的 len 个长度的字符串</td></tr><tr><td>REPLACE(column,source,replace)</td><td>替换字符串</td></tr></tbody></table><p>使用示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> 拼接</span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;World&#x27;</span>);</span><br><span class="line"><span class="comment">-- 小写</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOWER</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="comment">-- 大写</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">UPPER</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"><span class="comment">-- 左填充</span></span><br><span class="line"><span class="keyword">SELECT</span> LPAD(<span class="string">&#x27;01&#x27;</span>, <span class="number">5</span>, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="comment">-- 右填充</span></span><br><span class="line"><span class="keyword">SELECT</span> RPAD(<span class="string">&#x27;01&#x27;</span>, <span class="number">5</span>, <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line"><span class="comment">-- 去除空格</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">TRIM</span>(<span class="string">&#x27; Hello World &#x27;</span>);</span><br><span class="line"><span class="comment">-- 切片（起始索引为1）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUBSTRING</span>(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CEIL(x)</td><td>向上取整</td></tr><tr><td>FLOOR(x)</td><td>向下取整</td></tr><tr><td>MOD(x,y)</td><td>返回 x&#x2F;y 的模</td></tr><tr><td>RAND()</td><td>返回 0~1 内的随机数</td></tr><tr><td>ROUND(x,y)</td><td>湫参数 x 的四舍五入值，保留 y 个小数位</td></tr></tbody></table><h3 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>CURDATE()</td><td>返回当前日期</td></tr><tr><td>CURTIME()</td><td>返回当前时间</td></tr><tr><td>NOW()</td><td>返回当前日期和时间</td></tr><tr><td>YEAR(date)</td><td>获取指定 date 的年份</td></tr><tr><td>MONTH(date)</td><td>获取指定 date 的月份</td></tr><tr><td>DAY(date)</td><td>获取指定 date 的日期</td></tr><tr><td>DATE_ADD(date,INTERVAL expr type)</td><td>返回一个日期&#x2F;时间值加上一个时间间隔 expr 后的时间值</td></tr><tr><td>DATEDIFF(date1,date2)</td><td>返回起始时间 date1 和结束时间 date2 之间的天数</td></tr></tbody></table><p>exp：<br><code>-- DATE_ADD</code><br><code>SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);</code></p><h3 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h3><p>常用函数：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>IF(value,t,f)</td><td>如果 value 为 true，则返回 t，否则返回 f</td></tr><tr><td>IFNULL(value1,value2)</td><td>如果 value1 不为空，返回 value1，否则返回 value2</td></tr><tr><td>CASE WHEN [val1] THEN [res1] …ELSE [default] END</td><td>如果 val1 为 true，返回 res1，…否则返回 default 默认值</td></tr><tr><td>CASE expr WHEN [val1] THEN [res1] …ELSE [default] END</td><td>如果 expr 的值等于 val1，返回 res1，…否则返回 default 默认值</td></tr></tbody></table><p>exp：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,(<span class="keyword">case</span> <span class="keyword">when</span> age <span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">then</span> <span class="string">&#x27;中年&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;青年&#x27;</span> <span class="keyword">end</span>）</span><br><span class="line"><span class="keyword">FROM</span> employee;</span><br><span class="line"><span class="keyword">SELECT</span> name,(<span class="keyword">case</span> workaddress <span class="keyword">when</span> <span class="string">&#x27;北京市&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">when</span> <span class="string">&#x27;上海市&#x27;</span> <span class="keyword">then</span> <span class="string">&#x27;一线城市&#x27;</span> <span class="keyword">else</span></span><br><span class="line"><span class="string">&#x27;二线城市&#x27;</span> <span class="keyword">end</span>) <span class="keyword">as</span> <span class="string">&#x27;工作地址&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> employee;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>分类：</p><table><thead><tr><th>约束</th><th>描述</th><th>关键字</th></tr></thead><tbody><tr><td>非空约束</td><td>限制该字段的数据不能为 null</td><td>NOT NULL</td></tr><tr><td>唯一约束</td><td>保证该字段的所有数据都是唯一、不重复的</td><td>UNION</td></tr><tr><td>主键约束</td><td>主键是一行数据的唯一标识，要求非空且唯一</td><td>PRIMARY KEY</td></tr><tr><td>默认约束</td><td>保存数据时，如果未指定该字段的值，则采用默认值</td><td>DEFAULT</td></tr><tr><td>检查约束(8.0.1 后)</td><td>保证字段满足某一条件</td><td>CHECK</td></tr><tr><td>外键约束</td><td>用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td>FOREIGE KEY</td></tr></tbody></table><p><code>约束是作用于表中字段的，可以在创建/修改表时添加约束</code></p><h3 id="常用约束"><a href="#常用约束" class="headerlink" title="常用约束"></a>常用约束</h3><table><thead><tr><th>约束条件</th><th>关键字</th></tr></thead><tbody><tr><td>主键</td><td>PRIMARY KEY</td></tr><tr><td>自动增长</td><td>AUTO_INCREMENT</td></tr><tr><td>不为空</td><td>NOT NULL</td></tr><tr><td>唯一</td><td>UNION</td></tr><tr><td>逻辑条件</td><td>CHECK</td></tr><tr><td>默认值</td><td>DEFAULT</td></tr></tbody></table><p>EXP:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">unique</span>,</span><br><span class="line">age <span class="type">int</span> <span class="keyword">check</span>(age <span class="operator">&gt;</span> <span class="number">0</span> <span class="keyword">and</span> age <span class="operator">&lt;</span> <span class="number">120</span>),</span><br><span class="line">status <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">gender <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>添加外键：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">字段名 字段类型,</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">CONSTRAINT</span>] [外键名称] <span class="keyword">FOREIGN</span> KEY(外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> 外键名称 <span class="keyword">FOREIGN</span> KEY (外键字段名) <span class="keyword">REFERENCES</span> 主表(主表列名);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例子</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp <span class="keyword">add</span> <span class="keyword">constraint</span> fk_emp_dept_id <span class="keyword">foreign</span> key(dept_id) <span class="keyword">references</span> dept(id);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除外键：<br><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></p><h3 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除&#x2F;更新行为"></a>删除&#x2F;更新行为</h3><table><thead><tr><th>行为</th><th>说明</th></tr></thead><tbody><tr><td>NO ACTION</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新(与 RESTRICT 一致)</td></tr><tr><td>RESTRICT</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新(与 NO ACTION 一致)</td></tr><tr><td>CASCADE</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录</td></tr><tr><td>SET NULL</td><td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为 null(要求该外键允许为 null)</td></tr><tr><td>SET DEFAULT</td><td>父表有变更时，子表将外键设为一个默认值(InnoDB 不支持)</td></tr></tbody></table><p>更改删除&#x2F;更新行为：<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h3><ul><li>一对多(多对一)</li><li>多对多</li><li>一对一</li></ul><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在多的一方建立外键，指向一的一方的主键</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>案例：学生与可能<br>关系：一个学生可以选择多门课程，一门可能也可以供多个学生选择<br>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>案例：用户与用户详情<br>关系：一对一关系，用于多表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，一提升操作效率<br>实现：在任意一方加入外键，关联另一方的主键，并且设置外键为唯一的(UNIQUE)</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>合并查询（笛卡尔积，会展示所有的组合结果）：<br><code>select * from employee dept;</code><br>消除无效笛卡尔积：<br><code>select * from employee ，dept where employee.dept = dept.id</code></p><h4 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h4><p>内连接查询的是两张表的交集部分</p><ul><li>隐式内连接<br>SELECT 字段列表 FROM 表 1，表 2 WHERE 条件 …;</li><li>显示内连接<br>SELECT 字段列表 FROM 表 1 [INNER] JOIN 表 2 ON 连接条件 …;</li><li>EXP：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工姓名，及关联的部门的名称</span></span><br><span class="line"><span class="comment">-- 隐式</span></span><br><span class="line"><span class="keyword">select</span> e.name, d.name <span class="keyword">from</span> employee <span class="keyword">as</span> e, dept <span class="keyword">as</span> d <span class="keyword">where</span> e.dept <span class="operator">=</span> d.id;</span><br><span class="line"><span class="comment">-- 显式</span></span><br><span class="line"><span class="keyword">select</span> e.name, d.name <span class="keyword">from</span> employee <span class="keyword">as</span> e <span class="keyword">inner</span> <span class="keyword">join</span> dept <span class="keyword">as</span> d <span class="keyword">on</span> e.dept <span class="operator">=</span> d.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h4><ul><li>左外连接：<br>查询左表所有数据，以及两张表交集部门数据<br>SELECT 字段列表 FROM 表 1 LEFT [INNER] JOIN 表 2 ON 条件 …;</li><li>右外连接：<br>查询右表所有数据，以及两张表交集部门数据<br>SELECT 字段列表 FROM 表 1 RIGHT [INNER] JOIN 表 2 ON 条件 …;</li><li>EXP：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 左</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>, d.name <span class="keyword">from</span> employee <span class="keyword">as</span> e <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept <span class="keyword">as</span> d <span class="keyword">on</span> e.dept <span class="operator">=</span> d.id;</span><br><span class="line"><span class="keyword">select</span> d.name, e.<span class="operator">*</span> <span class="keyword">from</span> dept d <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> emp e <span class="keyword">on</span> e.dept <span class="operator">=</span> d.id;  <span class="comment">-- 这条语句与下面的语句效果一样</span></span><br><span class="line"><span class="comment">-- 右</span></span><br><span class="line"><span class="keyword">select</span> d.name, e.<span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">as</span> e <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> dept <span class="keyword">as</span> d <span class="keyword">on</span> e.dept <span class="operator">=</span> d.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>左连接可以查询到没有 dept 的 employee， 右连接可以查询到没有 employee 的 dept</p><h4 id="自连接查询"><a href="#自连接查询" class="headerlink" title="自连接查询"></a>自连接查询</h4><p>当前表与自身连接查询，子链接必须使用表别名<br>语法：<br><code>SELECT 字段列表 FORM 表A 别名A JOIN 表A 别名B ON 条件;</code><br>自连接查询，可以是内连接查询，也可以是外连接查询<br>EXP：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工及其所属领导的名字</span></span><br><span class="line"><span class="keyword">select</span> a.name, b.name <span class="keyword">from</span> employee a, employee b <span class="keyword">where</span> a.manager <span class="operator">=</span> b.id;</span><br><span class="line"><span class="comment">-- 没有领导的也查询出来</span></span><br><span class="line"><span class="keyword">select</span> a.name, b.name <span class="keyword">from</span> employee a <span class="keyword">left</span> <span class="keyword">join</span> employee b <span class="keyword">on</span> a.manager <span class="operator">=</span> b.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="联合查询-union，union-all"><a href="#联合查询-union，union-all" class="headerlink" title="联合查询 union，union all"></a>联合查询 union，union all</h4><p>把多次查询的结果合并，形成一个新的查询集<br>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A ...</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="注意事项-6"><a href="#注意事项-6" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>UNION ALL 会有重复结果，UNION 已经去重</li><li>联合查询比使用 or 效率高，不会使索引失败</li></ul><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>SQL 语句中嵌套 SEKECT，称为嵌套查询，又称子查询<br><code>SELECT \* FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code><br><strong>子查询外部的语句可以是 INSERT&#x2F;UPDATE&#x2F;DELETE&#x2F;SELECT 的任何一个</strong></p><p>根据子查询的结果可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询的位置可以分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h5 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h5><p>子查询返回结果为单个值（数字、字符串、日期等）<br>常用操作符： - &lt; &gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;<br>EXP:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询销售部所有员工</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>;</span><br><span class="line"><span class="comment">-- 根据销售部部门ID，查询员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 合并（子查询）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询xxx入职之后的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> (<span class="keyword">select</span> entrydate <span class="keyword">from</span> employee <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h5><p>返回的结果是一列（可以是多行）<br>常用操作符：</p><table><thead><tr><th>操作符</th><th>描述</th></tr></thead><tbody><tr><td>IN</td><td>在指定的合集范围内，多选一</td></tr><tr><td>NOT IN</td><td>不在指定的集合范围内</td></tr><tr><td>ANY</td><td>子查询返回列表中，有任意一个满足即可</td></tr><tr><td>SOME</td><td>与 ANY 相同，使用 SOME 的地方都可以使用 ANY</td></tr><tr><td>ALL</td><td>子查询返回列表的所有值必须满足</td></tr></tbody></table><p>EXP：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询销售部和市场部的所有员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;市场部&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询比财务部所有人工资都高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> salary <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;财务部&#x27;</span>));</span><br><span class="line"><span class="comment">-- 查询比研发部任意一人工资高的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> salary <span class="operator">&gt;</span> <span class="keyword">any</span> (<span class="keyword">select</span> salary <span class="keyword">from</span> employee <span class="keyword">where</span> dept <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h5><p>返回的结果是一行（可以是多列）<br>常用操作符： &#x3D;,&lt;,&gt;,IN,NOT IN<br>EXP:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与xxx的薪资及直属领导相同的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> (salary, manager) <span class="operator">=</span> (<span class="number">12500</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> (salary, manager) <span class="operator">=</span> (<span class="keyword">select</span> salary, manager <span class="keyword">from</span> employee <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h5><p>返回的结果是多行多列<br>常用操作符：IN<br>EXP：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与xxx1，xxx2的职位和薪资相同的员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> (job, salary) <span class="keyword">in</span> (<span class="keyword">select</span> job, salary <span class="keyword">from</span> employee <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;xxx1&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;xxx2&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询入职日期是2006-01-01之后的员工，及其部门信息</span></span><br><span class="line"><span class="keyword">select</span> e.<span class="operator">*</span>, d.<span class="operator">*</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employee <span class="keyword">where</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>) <span class="keyword">as</span> e <span class="keyword">left</span> <span class="keyword">join</span> dept <span class="keyword">as</span> d <span class="keyword">on</span> e.dept <span class="operator">=</span> d.id;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是一组操作的集合，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败</p><h3 id="基本操作："><a href="#基本操作：" class="headerlink" title="基本操作："></a>基本操作：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 查询张三账户余额</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="comment">-- 2. 将张三账户余额-1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="comment">-- 此语句出错后张三钱减少但是李四钱没有增加</span></span><br><span class="line">模拟<span class="keyword">sql</span>语句错误</span><br><span class="line"><span class="comment">-- 3. 将李四账户余额+1000</span></span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看事务提交方式</span></span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@AUTOCOMMIT</span>;</span><br><span class="line"><span class="comment">-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@AUTOCOMMIT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">-- 提交事务</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"><span class="comment">-- 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置手动提交后上面代码改为：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="操作方式二："><a href="#操作方式二：" class="headerlink" title="操作方式二："></a>操作方式二：</h3><p>开启事务：<br><code>START TRANSACTION 或 BEGIN TRANSACTION;</code><br>提交事务：<br><code>COMMIT;</code><br>回滚事务：<br><code>ROLLBACK;</code><br>操作实例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">start</span> transaction;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> account <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">-</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span>;</span><br><span class="line"><span class="keyword">update</span> account <span class="keyword">set</span> money <span class="operator">=</span> money <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;李四&#x27;</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四大特性-ACID"><a href="#四大特性-ACID" class="headerlink" title="四大特性 ACID"></a>四大特性 ACID</h3><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有事务保持一致状态</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h3 id="并发事务"><a href="#并发事务" class="headerlink" title="并发事务"></a>并发事务</h3><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另一个事务还没提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务先后读取同一条记录，但两次读到的数据不同</td></tr><tr><td>幻读</td><td>一个事务按照条件查询数据时，没有对应的数据行，但再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><h4 id="并发事务隔离级别："><a href="#并发事务隔离级别：" class="headerlink" title="并发事务隔离级别："></a>并发事务隔离级别：</h4><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>√</td><td>√</td><td>√</td></tr><tr><td>Read committed</td><td>×</td><td>√</td><td>√</td></tr><tr><td>Repeatable Read（默认）</td><td>×</td><td>×</td><td>√</td></tr><tr><td>Serializable</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><ul><li>√ 表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><p>查看事务隔离级别:<br><code>SELECT @@TRANSACTION_ISLATION</code><br>设置事务隔离级别:<br><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code><br>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL 体系结构：<br><img src="/../image/MySQLPic/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png"><br><img src="/../image/MySQLPic/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%B1%82%E7%BA%A7%E5%90%AB%E4%B9%89.png"></p><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。<br>MySQL 默认存储引擎是 InnoDB</p><p>相关操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询建表语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> account;</span><br><span class="line"><span class="comment">-- 建表时指定存储引擎</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">...</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB;</span><br><span class="line"><span class="comment">-- 查看当前数据库支持的存储引擎</span></span><br><span class="line"><span class="keyword">show</span> engines;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL5.5 之后，InnoDB 都是默认的搜索引擎</p><ul><li>特点<ul><li>DML 操作遵循 ACID 模型，支持事务</li><li>行级锁，提高并发访问性能</li><li>支持外键约束，保证数据的完整性和正确性</li></ul></li><li>文件<ul><li>xxx.ibd:xxx 代表表名，InnoDB 引擎的每张表都对应这样一个表空间文件，存储该表的表结构(frm、sdi)、数据和索引</li></ul></li><li>参数<br>innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</li></ul><p>查看 MySQL 变量：<br><code>show variables like &#39;innodb_file_per_table&#39;;</code><br>从 odb 文件提取表结构数据（cmd）：<br><code>idb2sdi xxx.idb</code><br>InnoDB 逻辑存储结构：<br><img src="/../image/MySQLPic/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎</p><ul><li>特点：<ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul></li><li>文件：</li><li>xxx.sdi:存储表结构信息</li><li>xxx.MYD:存储数据</li><li>xxx.MYI:存储索引</li></ul><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用</p><ul><li>特点：<ul><li>存放在内存中，速度快</li><li>hash 索引（默认）</li></ul></li><li>文件：<ul><li>xxx.sdi：存储表结构信息</li></ul></li></ul><h3 id="存储引擎的特点："><a href="#存储引擎的特点：" class="headerlink" title="存储引擎的特点："></a>存储引擎的特点：</h3><p>dasd</p><h3 id="存储引擎的选择："><a href="#存储引擎的选择：" class="headerlink" title="存储引擎的选择："></a>存储引擎的选择：</h3><p><code>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</code></p><ul><li>InnoDB：如果应对事物的完整性有比较高的要求，在并发条件下要求 数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适</li><li>Memory：将所有数据保存在内存中，访问速度快，通常用于临时表以及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p><strong>电商中的足迹和评论适合使用 MyISAM，缓存适合使用 Memory 引擎</strong></p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="查看执行频次"><a href="#查看执行频次" class="headerlink" title="查看执行频次"></a>查看执行频次</h3><p>查看当前数据库的 INSERT、UPDATE、DELETE、SELECT 访问频次：<br><code>SHOW GLOBAL STATUS LIKE &#39;Com___&#39;;</code><br><code>SHOW SESSION STATUS LIKE &#39;Com___&#39;;</code></p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认 10 秒）的所有 SQL 语句的日志<br>MySQL 的慢查询日志默认没有开启，需要 MySQL 的配置文件(&#x2F;etc&#x2F;my.cnf)中配置如下信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启慢查询日志开关</span><br><span class="line">slow_query_log<span class="operator">=</span><span class="number">1</span></span><br><span class="line"># 设置慢查询日志的时间为<span class="number">2</span>秒，<span class="keyword">SQL</span>语句执行时间超过<span class="number">2</span>秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time<span class="operator">=</span><span class="number">2</span></span><br><span class="line">更改后记得重启MySQL服务，日志文件位置：<span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>localhost<span class="operator">-</span>slow.log</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看慢查询日志开关状态：<br><code>show variable like &#39;slow_query_log&#39;;</code></p><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>show profile 能在做 SQL 优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<br><code>SELECT @@have_profiling;</code><br>profiling 默认关闭，可以通过 set 语句在 session&#x2F;global 级别开启 profiling：<br><code>SET profiling = 1;</code><br>查看所有语句的耗时：<br><code>show profiles;</code><br>查看指定 query_id 的 SQL 语句各个阶段的耗时：<br><code>show profile for query query_id;</code><br>查看指定 query_id 的 SQL 语句 CPU 的使用情况<br><code>show profile cpu for query query_id;</code></p><h3 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 直接在<span class="keyword">select</span>语句之前加上关键字 explain <span class="operator">/</span> <span class="keyword">desc</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 HWERE 条件;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>EXPLAIN 各字段的含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id 相同，执行顺序从上到下；id 不同，值越大越先执行）</li><li>select_type:表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适于表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE 之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>Rows：MySQL 认为必须要执行的行数，在 InnoDB 引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered 的值越大越好</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p>优点：</p><ul><li>提高数据检索效率，降低数据库的 IO 成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗<br>缺点：</li><li>索引列也是要占用空间的</li><li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li></ul><h3 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h3><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持 B+树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td>R-Tree(空间索引)</td><td>空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>ull-Text(全文索引)</td><td>是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>emory</th></tr></thead><tbody><tr><td>B+Tree 索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash 索引</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-Tree 索引</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6 版本后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>结构图：<br><img src="/../image/MySQLPic/%E4%BA%8C%E5%8F%89%E6%A0%91.png"></p><p>二叉树的缺点可以用红黑树来解决：<br><img src="/../image/MySQLPic/%E7%BA%A2%E9%BB%91%E6%A0%91.png"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为 5（5 阶）的 b-tree 为例（每个节点最多存储 4 个 key，5 个指针）</p><p><img src="/../image/MySQLPic/B-Tree%E7%BB%93%E6%9E%84.png"></p><p><a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">演示地址</a></p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>结构图：<br><img src="/../image/MySQLPic/B+Tree%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p><p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">演示地址</a></p><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。<br><img src="/../image/MySQLPic/B+Tree%E4%BC%98%E5%8C%96.png"></p><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>哈希索引就是采用一定的 hash 算法，将键值换算成新的 hash 值，映射到对应的槽位上，然后存储在 hash 表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了 hash 冲突（也称为 hash 碰撞），可以通过链表来解决。</p><p><img src="/../image/MySQLPic/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE.png"></p><p>特点：</p><ul><li>Hash 索引只能用于对等比较（&#x3D;、in），不支持范围查询（between、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应 hash 功能，hash 索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</p><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，只能有一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引(Clustered Index)</td><td>将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td>必须有，而且只有一个</td></tr><tr><td>二级索引(Secondary Index)</td><td>将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>演示：<br><img src="/../image/MySQLPic/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB-1.png"></p><p><img src="/../image/MySQLPic/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB-2.png"></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><h4 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h4><ol><li>以下 SQL 语句，哪个执行效率高？为什么？</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Arm&#x27;</span>;</span><br><span class="line"><span class="comment">-- 备注：id为主键，name字段创建的有索引</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><ol start="2"><li>InnoDB 主键索引的 B+Tree 高度为多少？</li></ol><p>答：假设一行数据大小为 1k，一页中可以存储 16 行这样的数据。InnoDB 的指针占用 6 个字节的空间，主键假设为 bigint，占用字节数为 8.<br>可得公式：n _ 8 + (n + 1) _ 6 &#x3D; 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的 key 的数量，(n + 1) 表示指针数量（比 key 多一个）。算出 n 约为 1170。</p><p>如果树的高度为 2，那么他能存储的数据量大概为：1171 _ 16 &#x3D; 18736；<br>如果树的高度为 3，那么他能存储的数据量大概为：1171 _ 1171 * 16 &#x3D; 21939856。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>删除索引：<br><code>DROP INDEX index_name ON table_name;</code><br>案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_name <span class="keyword">on</span> tb_user(name);</span><br><span class="line"><span class="comment">-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index idx_user_phone <span class="keyword">on</span> tb_user (phone);</span><br><span class="line"><span class="comment">-- 为profession, age, status创建联合索引</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_pro_age_stat <span class="keyword">on</span> tb_user(profession, age, status);</span><br><span class="line"><span class="comment">-- 为email建立合适的索引来提升查询效率</span></span><br><span class="line"><span class="keyword">create</span> index idx_user_email <span class="keyword">on</span> tb_user(email);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">drop</span> index idx_user_email <span class="keyword">on</span> tb_user;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><h4 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。</p><h4 id="索引失效情况"><a href="#索引失效情况" class="headerlink" title="索引失效情况"></a>索引失效情况</h4><p>1.在索引列上进行运算操作，索引将失效。如：explain select _ from tb_user where substring(phone, 10, 2) &#x3D; ‘15’;</p><p>2.字符串类型字段使用时，不加引号，索引将失效。如：explain select _ from tb_user where phone &#x3D; 17799990015;，此处 phone 的值没有加引号</p><p>3.模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like ‘%工程’;，前后都有 % 也会失效。</p><p>4.用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</p><p>5.如果 MySQL 评估使用索引比全表更慢，则不使用索引。</p><h4 id="SQL-提示"><a href="#SQL-提示" class="headerlink" title="SQL 提示"></a>SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在 SQL 语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force 就是无论如何都强制使用该索引。</p><h4 id="覆盖索引-回表查询"><a href="#覆盖索引-回表查询" class="headerlink" title="覆盖索引&amp;回表查询"></a>覆盖索引&amp;回表查询</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p><p>explain 中 extra 字段含义：<br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是 select *；如果在辅助索引中找聚集索引，如<code>select id, name from xxx where name=&#39;xxx&#39;;</code>，也只需要通过辅助索引(name)查找到对应的 id，返回 name 和 name 索引对应的 id 即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name=&#39;xxx&#39;;</code></p><p>所以尽量不要用 select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><h4 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h4><p>一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下 SQL 语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username=&#39;itcast&#39;;</code><br>解：给 username 和 password 字段建立联合索引，则不需要回表查询，直接覆盖索引</p><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>当字段类型为字符串（varchar, text 等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> email) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> <span class="built_in">substring</span>(email, <span class="number">1</span>, <span class="number">5</span>)) <span class="operator">/</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> tb_user;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>show index 里面的 sub_part 可以看到接取的长度</p><h4 id="单列索引-联合索引"><a href="#单列索引-联合索引" class="headerlink" title="单列索引&amp;联合索引"></a>单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：<br><code>explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;</code><br>这句只会用到 phone 索引字段</p><p><strong>注意事项</strong></p><ul><li>多条件联合查询时，MySQL 优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储 NULL 值，请在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h2 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>普通插入：</p><ul><li>采用批量插入（一次插入的数据不建议超过 1000 条）</li><li>手动提交事务</li><li>主键顺序插入</li></ul><p>大批量插入：<br>如果有一次性需要插入大批量数据，使用 insert 语句插入性能较低，此时可以使用 MySQL 数据库提供的 load 指令插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 客户端连接服务端时，加上参数 <span class="comment">--local-infile（这一行在bash/cmd界面输入）</span></span><br><span class="line">mysql <span class="comment">--local-infile -u root -p</span></span><br><span class="line"># 设置全局参数local_infile为<span class="number">1</span>，开启从本地加载文件导入数据的开关</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@local_infile</span>;</span><br><span class="line"># 执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">&#x27;tb_user&#x27;</span> fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h3><p>数据组织方式：在 InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>页分裂：页可以为空，也可以填充一般，也可以填充 100%，每个页包含了 2-N 行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的 50%），InnoDB 会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者其他的自然主键，比如身份证号</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h3><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol><p>如果 order by 字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain 的 extra 信息显示的是 Using index, Using filesort，如果要优化掉 Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用 <code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免出现 filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认 256k）</li></ul><h3 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h3><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也满足最左前缀法则</li></ul><p>如索引为 idx_user_pro_age_stat，则句式可以是 select … where profession order by age，这样也符合最左前缀法则</p><h3 id="limit-优化"><a href="#limit-优化" class="headerlink" title="limit 优化"></a>limit 优化</h3><p>常见的问题如 limit 2000000, 10，此时需要 MySQL 排序前 2000000 条记录，但仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> 此语句耗时很长</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku limit <span class="number">9000000</span>, <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">9000000</span>, <span class="number">10</span>;</span><br><span class="line"><span class="comment">-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit</span></span><br><span class="line"><span class="comment">-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);</span></span><br><span class="line"><span class="comment">-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_sku <span class="keyword">as</span> s, (<span class="keyword">select</span> id <span class="keyword">from</span> tb_sku <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">9000000</span>, <span class="number">10</span>) <span class="keyword">as</span> a <span class="keyword">where</span> s.id <span class="operator">=</span> a.id</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="count-优化"><a href="#count-优化" class="headerlink" title="count 优化"></a>count 优化</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(<em>) 的时候会直接返回这个数，效率很高（前提是不适用 where）；<br>InnoDB 在执行 count(</em>) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建 key-value 表存储在内存或硬盘，或者是用 redis</p><p>count 的几种用法：</p><ul><li>如果 count 函数的参数（count 里面写的那个字段）不是 NULL（字段值不为 NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟 count(<em>)一样，因为主键不能为空；count(字段)只计算字段值不为 NULL 的行；count(1)引擎会为每行添加一个 1，然后就 count 这个 1，返回结果也跟 count(</em>)一样；count(null)返回 0</li></ul><p>各种用法的性能：</p><ul><li>count(主键)：InnoDB 引擎会遍历整张表，把每行的主键 id 值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：没有 not null 约束的话，InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为 null，不为 null，计数累加；有 not null 约束的话，InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li><li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(<em>)，所以尽量使用 count(</em>)</p><h3 id="update-优化（避免行锁升级为表锁）"><a href="#update-优化（避免行锁升级为表锁）" class="headerlink" title="update 优化（避免行锁升级为表锁）"></a>update 优化（避免行锁升级为表锁）</h3><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句：<br><code>update student set no = &#39;123&#39; where id = 1;</code>，这句由于 id 有主键索引，所以只会锁这一行；<br><code>update student set no = &#39;123&#39; where name = &#39;test&#39;;</code>，这句由于 name 没有索引，所以会把整张表都锁住进行数据更新，解决方法是给 name 字段添加索引</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 增 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> tb_stu_view <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_student;</span><br><span class="line"><span class="comment">/* 删 */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> tb_stu_view;</span><br><span class="line"><span class="comment">/* 改 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> tb_stu_view <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_student;</span><br><span class="line"><span class="comment">/* 查 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_stu_view;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>view：记录了某条代表一些表的 sql 语句，并不真正存储表，方便进行操作</p><h3 id="检查选项"><a href="#检查选项" class="headerlink" title="检查选项"></a>检查选项</h3><p><code>with check cascaded/local option ：</code>检查选项，当对视图进行添加&#x2F;修改数据时，是否检查视图定义中 where 的条件以及父视图的 where 条件</p><p>cascade：检查时必须检查父类</p><p>local：检查时递归地检查父类，如果父类有 with check option，就也检查，否则不坚持</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li>简单，简化用户的一些常用操作</li><li>安全，控制用户的访问</li><li>数据独立，屏蔽基表的变化对用户的影响</li></ul><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><ul><li><p>存储过程是事先经过编译并存储在数据库中的一系列 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多操作，减少数据在数据库和应用服务器之间的传输。</p></li><li><p>可以接收参数，也可以返回数据</p></li></ul><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1 ()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">from</span> student;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"><span class="comment">/* 使用 */</span></span><br><span class="line"><span class="keyword">call</span> p1();</span><br><span class="line"><span class="comment">/* 查看 */</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> p1;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.ROUTINES <span class="keyword">where</span> ROUTINE_SCHEMA <span class="operator">=</span> &quot;itcast&quot;;</span><br><span class="line"><span class="comment">/* 删除 */</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> if <span class="keyword">exists</span> p1;</span><br><span class="line"><span class="comment">/* 指定sql语句的结束符（控制台）（代替;） */</span></span><br><span class="line">delimiter $$;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h5><ul><li>session 会话变量，一个控制台是一个会话</li><li>global 全局变量</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 展示系统变量 */</span></span><br><span class="line"><span class="keyword">show</span> session<span class="operator">/</span><span class="keyword">global</span> varibles;</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@session</span><span class="operator">/</span>global.autocommit;</span><br><span class="line"><span class="comment">/* 更改系统变量 */</span></span><br><span class="line"><span class="keyword">set</span> sesion<span class="operator">/</span><span class="keyword">global</span> autocommit <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义 */</span></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@my_varible</span> :<span class="operator">=</span> &quot;cuixiu&quot;;</span><br><span class="line"><span class="comment">/* 把select的结果赋值给变量 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">into</span> <span class="variable">@count</span> <span class="keyword">from</span> tb_user;</span><br><span class="line"><span class="comment">/* 使用 */</span></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@my_varible</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>存储过程 begin-end 之间的变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1 ()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> stu_count <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="if"><a href="#if" class="headerlink" title="if"></a>if</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1 ()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> score <span class="type">int</span> <span class="keyword">default</span> <span class="number">58</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">if score<span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> &quot;优秀&quot;</span><br><span class="line">elseif score <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> &quot;及格&quot;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> &quot;不及格&quot;</span><br><span class="line">endif;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="参数（输入输出）"><a href="#参数（输入输出）" class="headerlink" title="参数（输入输出）"></a>参数（输入输出）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* in out */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1 (<span class="keyword">in</span> score <span class="type">int</span>,<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">if score<span class="operator">&gt;=</span><span class="number">85</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> &quot;优秀&quot;</span><br><span class="line">elseif score <span class="operator">&gt;=</span><span class="number">60</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> &quot;及格&quot;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> &quot;不及格&quot;</span><br><span class="line">endif;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p1(<span class="number">68</span>,<span class="variable">@result</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@result</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* inout */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p2 (<span class="keyword">inout</span> score <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">set</span> score :<span class="operator">=</span> score<span class="operator">/</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@score</span><span class="operator">=</span><span class="number">99</span>;</span><br><span class="line"><span class="keyword">call</span> p2(<span class="variable">@score</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@score</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="case-语句"><a href="#case-语句" class="headerlink" title="case 语句"></a>case 语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1 (<span class="keyword">in</span> <span class="keyword">month</span> <span class="type">int</span>,<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">case</span></span><br><span class="line"><span class="keyword">when</span> <span class="keyword">month</span><span class="operator">&gt;=</span><span class="number">1</span> <span class="keyword">and</span> <span class="keyword">month</span><span class="operator">&lt;=</span><span class="number">3</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> &quot;spring&quot;;</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">month</span><span class="operator">&gt;=</span><span class="number">4</span> <span class="keyword">and</span> <span class="keyword">month</span><span class="operator">&lt;=</span><span class="number">6</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> &quot;summer&quot;;</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">month</span><span class="operator">&gt;=</span><span class="number">7</span> <span class="keyword">and</span> <span class="keyword">month</span><span class="operator">&lt;=</span><span class="number">9</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> &quot;automn&quot;;</span><br><span class="line"><span class="keyword">when</span> <span class="keyword">month</span><span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> <span class="keyword">month</span><span class="operator">&lt;=</span><span class="number">12</span> <span class="keyword">then</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> &quot;winter&quot;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> &quot;非法输入&quot;;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p1(<span class="number">5</span>,<span class="variable">@result</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@result</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1 (<span class="keyword">in</span> n <span class="type">int</span>,<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">while n<span class="operator">&gt;</span><span class="number">0</span> do</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="keyword">result</span><span class="operator">+</span>n;</span><br><span class="line"><span class="keyword">set</span> n:<span class="operator">=</span>n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@result</span><span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">call</span> p1(<span class="number">5</span>,<span class="variable">@result</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@result</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="repeat-语句"><a href="#repeat-语句" class="headerlink" title="repeat 语句"></a>repeat 语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1 (<span class="keyword">in</span> n <span class="type">int</span>,<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">repeat</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="keyword">result</span><span class="operator">+</span>n;</span><br><span class="line"><span class="keyword">set</span> n:<span class="operator">=</span>n<span class="number">-1</span>;</span><br><span class="line">until n<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">end</span> repeat;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@result</span><span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">call</span> p1(<span class="number">5</span>,<span class="variable">@result</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@result</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="loop-语句"><a href="#loop-语句" class="headerlink" title="loop 语句"></a>loop 语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1 (<span class="keyword">in</span> n <span class="type">int</span>,<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">repeat</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="keyword">result</span><span class="operator">+</span>n;</span><br><span class="line"><span class="keyword">set</span> n:<span class="operator">=</span>n<span class="number">-1</span>;</span><br><span class="line">until n<span class="operator">=</span><span class="number">0</span></span><br><span class="line"><span class="keyword">end</span> repeat;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="variable">@result</span><span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">call</span> p1(<span class="number">5</span>,<span class="variable">@result</span>);</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@result</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="游标-cursor"><a href="#游标-cursor" class="headerlink" title="游标 cursor"></a>游标 cursor</h5><p>游标是存储查询结果集的数据类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p1 ()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> uname <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">declare</span> uage <span class="type">int</span>;</span><br><span class="line"><span class="keyword">declare</span> mycursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,age <span class="keyword">from</span> student;</span><br><span class="line">    <span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> user_na&#123;</span><br><span class="line">    age <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    name <span class="type">int</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">open</span> mycursor;</span><br><span class="line">    while <span class="literal">true</span> do</span><br><span class="line">    <span class="keyword">fetch</span> mycursor <span class="keyword">into</span> uname,uage;</span><br><span class="line">    <span class="keyword">insert</span> <span class="keyword">into</span> user_na(name,age) <span class="keyword">values</span>(uname,uage);</span><br><span class="line">    <span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="调价处理程序"><a href="#调价处理程序" class="headerlink" title="调价处理程序"></a>调价处理程序</h5><p>当存储过程发生警告&#x2F;错误时的处理办法 —— 继续执行 continue&#x2F;中止 exit</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> continue<span class="operator">/</span>exit handle <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> mycursor; <span class="comment">/* close mycursor是指exit之前还要做什么事 */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>有返回值的存储过程。参数只能是 in 类型。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> f1(n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">deterministic</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">result</span> <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">while n<span class="operator">&gt;</span><span class="number">0</span> do</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="keyword">result</span><span class="operator">+</span>n;</span><br><span class="line"><span class="keyword">set</span> n:<span class="operator">=</span>n<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">result</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> f1(<span class="number">50</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是指在 insert，update，delete 之前或之后，触发并执行触发器中定义的 SQL 语句的集合</p><ul><li>确保数据的完整性</li><li>日志记录</li><li>数据校验</li></ul><h4 id="insert-触发器"><a href="#insert-触发器" class="headerlink" title="insert 触发器"></a>insert 触发器</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入后更新日志表 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> insert_trigger</span><br><span class="line">after <span class="keyword">insert</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">/* new代表新插入的行 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> logs(id,table_id,info) <span class="keyword">values</span>(<span class="keyword">null</span>,new.id,concat(&quot;插入的数据是&quot;,new.id,new.name));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看触发器 */</span></span><br><span class="line"><span class="keyword">show</span> triggers;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="update-触发器"><a href="#update-触发器" class="headerlink" title="update 触发器"></a>update 触发器</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入后更新日志表 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> update_trigger</span><br><span class="line">after <span class="keyword">update</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">/* new代表更新之后的行 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> logs(id,table_id,info) <span class="keyword">values</span>(<span class="keyword">null</span>,new.id,</span><br><span class="line">                                              concat(&quot;更新之前的数据是&quot;,old.id,old.name,&quot;更新之后的数据是&quot;,new.id,new.name));</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="delete-触发器"><a href="#delete-触发器" class="headerlink" title="delete 触发器"></a>delete 触发器</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入后更新日志表 */</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> delete_trigger</span><br><span class="line">after <span class="keyword">delete</span> <span class="keyword">on</span> tb_user <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="comment">/* old代表删除之前的行 */</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> logs(id,table_id,info) <span class="keyword">values</span>(<span class="keyword">null</span>,new.id,</span><br><span class="line">                                              concat(&quot;删除之前的数据是&quot;,old.id,old.name);</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>对整个数据库加锁，加锁后整个实例处于只读状态，DDL\DML 语句都将阻塞</p><p>典型场景：对数据库进行备份，对所有的表进行锁定，保证数据的完整性</p><p>mysqldump 代表备份</p><p>缺点：业务停摆。在 innodb 引擎中，可以通过在 mysqldump 命令中加入 –single-transaction 来完成备份</p><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><ul><li>读锁：只能读不能写（都能读）</li><li>写锁：只能自己进行读写</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 读锁 */</span></span><br><span class="line">lock tables tablename read;</span><br><span class="line">unlock tables;</span><br><span class="line"><span class="comment">/* 写锁 */</span></span><br><span class="line">lock tables tablename write;</span><br><span class="line">unlock tables;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="元数据锁-MDL（自动）"><a href="#元数据锁-MDL（自动）" class="headerlink" title="元数据锁 MDL（自动）"></a>元数据锁 MDL（自动）</h5><p>增删改查的时候，加 mdl 读锁（共享）；修改表的时候，加 mdl 写锁（排他）</p><p>代表着，一个客户端增删改查，另一个客户端也可以增删改查，但是不能修改表；一个客户端修改表，另一个客户端什么都不能做</p><h5 id="意向锁（自动）"><a href="#意向锁（自动）" class="headerlink" title="意向锁（自动）"></a>意向锁（自动）</h5><p>加行锁时自动加，减少表锁的检查（当 a 加了行锁，b 要加表锁时，由于 a 加行锁后自动加意向锁，所以不必一行一行的检查）</p><ul><li>意向共享锁（IS）：select … lock in share mode 时自动加，和表锁中的读锁兼容</li><li>意向互斥锁（IX）：select … for update、insert、update、delete 时自动加，都不兼容</li></ul><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><h5 id="行锁（自动）"><a href="#行锁（自动）" class="headerlink" title="行锁（自动）"></a>行锁（自动）</h5><p>针对索引上的索引项来加锁，在 RC 和 RR 级别下支持</p><ul><li>共享锁（S）：可以一起读</li><li>排他锁（X）：只能自己读写</li></ul><p>innodb 引擎的行锁是针对索引加的，有索引时才会加行锁，没有索引时就会自动变成表锁</p><h5 id="间隙锁（自动）和-nextkey-临键锁（自动）"><a href="#间隙锁（自动）和-nextkey-临键锁（自动）" class="headerlink" title="间隙锁（自动）和 nextkey 临键锁（自动）"></a>间隙锁（自动）和 nextkey 临键锁（自动）</h5><p>保证间隙不变，（不能在间隙锁的那个间隙中增删改），在 RR 隔离级别下支持，可以防止幻读</p><ul><li>唯一索引，等值查询，给不存在的记录加锁时，自动优化为间隙锁</li><li>普通索引，等值查询，临键锁退化为间隙锁</li><li>唯一索引，范围查询，加临键锁</li></ul><p><strong>一些理解</strong></p><ul><li>展示锁</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> object_schema,object_name,index_name,lock_type,lock_mode,lock_data <span class="keyword">from</span> performance_schema.data_locks;</span><br></pre></td></tr></table></figure><ul><li>插入数据时，自动加行锁和意向锁</li></ul><p>如图，插入数据时创建的锁，IX 为意向锁（TABLE），X,REC 为行锁</p><ul><li>除了全局锁和表锁，剩下的都是在增删改和改变表结构时自动加的</li></ul><h5 id="脏读、幻读、不可重复读"><a href="#脏读、幻读、不可重复读" class="headerlink" title="脏读、幻读、不可重复读"></a>脏读、幻读、不可重复读</h5><ul><li><p>脏读：不提交就能读</p></li><li><p>不可重复读：提交了才能读</p></li><li><p>幻读：幻读就是事务在做范围查询（SELECT)的过程中，有另外一个事务对范围内新增了记录(INSERT)，导致范围查询的结果条数不一致的现象。</p></li></ul><h3 id="InnoDB-引擎"><a href="#InnoDB-引擎" class="headerlink" title="InnoDB 引擎"></a>InnoDB 引擎</h3><p>InnoDB的逻辑存储结构：<br><img src="/../image/MySQLPic/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png"></p><p>1.表空间<br>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p><p>2.段<br>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p><p>3.区<br>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</p><p>4.页<br>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><p>5.行<br>行，InnoDB 存储引擎数据是按行进行存放的。</p><p>在行中，默认有两个隐藏字段：</p><ul><li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左侧为内存结构，右侧为磁盘结构。<br><img src="/../image/MySQLPic/InnoDB%E6%9E%B6%E6%9E%84%E5%9B%BE.webp"></p><h5 id="内存架构"><a href="#内存架构" class="headerlink" title="内存架构"></a>内存架构</h5><p><img src="/../image/MySQLPic/InnoDB%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84.webp"></p><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer。 下来介绍一下这四个部分。</p><p><strong>1.Buffer Pool</strong><br>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I&#x2F;O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I&#x2F;O。</p><p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增 删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频 率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><p>free page：空闲page，未被使用。<br>clean page：被使用page，数据没有被修改过。<br>dirty page：脏页，被使用page，数据被修改过，也中数据与磁盘的数据产生了不一致。<br>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置： show variables like ‘innodb_buffer_pool_size’;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_buffer_pool_size <span class="operator">|</span> <span class="number">134217728</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2.Change Buffer</strong></p><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer中，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>Change Buffer的意义是什么呢?</p><p>先来看一幅图，这个是二级索引的结构图：</p><p><img src="/../image/MySQLPic/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%9B%BE.webp"></p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO。</p><p><strong>3.Adaptive Hash Index</strong></p><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持hash索引，但是给我们提供了一个功能就是这个自适应hash索引。因为前面我们讲到过，hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。</p><p>InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引。</p><p><strong>自适应哈希索引，无需人工干预，是系统根据情况自动完成</strong>。</p><p>参数： <code>adaptive_hash_index</code></p><p><strong>4.Log Buffer</strong></p><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I&#x2F;O。</p><p>参数:</p><p>innodb_log_buffer_size：缓冲区大小</p><p>innodb_flush_log_at_trx_commit：日志刷新到磁盘时机，取值主要包含以下三个：</p><p> <code>1</code>:日志在每次事务提交时写入并刷新到磁盘，默认值。</p><p> <code>0</code>:每秒将日志写入并刷新到磁盘一次。</p><p> <code>2</code>:日志在每次事务提交后写入，并每秒刷新到磁盘一次。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_flush_log_at_trx_commit&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                  <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_flush_log_at_trx_commit <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h5><p>接下来，再来看看InnoDB体系结构的右边部分，也就是磁盘结构：</p><p><img src="/../image/MySQLPic/InnoDB%E7%A3%81%E7%9B%98%E7%BB%93%E6%9E%84.webp"></p><p><strong>1.System Tablespace</strong></p><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)</p><p>参数：innodb_data_file_path</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_data_file_path&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+------------------------+</span></span><br><span class="line"><span class="operator">|</span> innodb_data_file_path <span class="operator">|</span> ibdata1:<span class="number">12</span>M:autoextend <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>系统表空间，默认的文件名叫 ibdata1。</p><p><strong>2.File-Per-Table Tablespaces</strong></p><p>如果开启了innodb_file_per_table开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。</p><p>开关参数：<code>innodb_file_per_table</code>，该参数默认开启。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_file_per_table&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name         <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="operator">|</span> innodb_file_per_table <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那也就是说，我们每创建一个表，都会产生一个表空间文件，如图：</p><p><img src="/../image/MySQLPic/%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%96%87%E4%BB%B6.webp"></p><p><strong>3.General Tablespaces</strong></p><p>通用表空间，需要通过 CREATE TABLESPACE 语法创建通用表空间，在创建表时，可以指定该表空间。</p><p>A. 创建表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE ts_name <span class="keyword">ADD</span> DATAFILE <span class="string">&#x27;file_name&#x27;</span> ENGINE <span class="operator">=</span> engine_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE ts_itheima <span class="keyword">ADD</span> DATAFILE <span class="string">&#x27;myitheima.ibd&#x27;</span> ENGINE <span class="operator">=</span> innodb;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>B. 创建表时指定表空间</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> xxx ... TABLESPACE ts_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> a(id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,name <span class="type">varchar</span>(<span class="number">10</span>)) engine<span class="operator">=</span>innodb tablespace ts_itheima;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>4.Undo Tablespaces</strong></p><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储 undo log日志。</p><p><strong>5.Temporary Tablespaces</strong></p><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><p><strong>6.Doublewrite Buffer Files</strong></p><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p><p><strong>7.Redo Log</strong></p><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。</p><p>以循环方式写入重做日志文件，涉及两个文件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql  50331648 10月  2 22:52 ib_logfile0</span></span><br><span class="line"><span class="operator">-</span>rw<span class="operator">-</span>r<span class="comment">-----. 1 mysql mysql  50331648 10月  2 22:52 ib_logfile1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前面我们介绍了InnoDB的内存结构，以及磁盘结构，那么内存中我们所更新的数据，又是如何到磁盘中的呢？ 此时，就涉及到一组后台线程，接下来，就来介绍一些InnoDB中涉及到的后台线程。</p><p><img src="/../image/MySQLPic/InnoDB%E4%B8%AD%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.webp"></p><h5 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h5><p><img src="/../image/MySQLPic/InnoDB%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B.webp"></p><p>在InnoDB的后台线程中，分为4类，分别是：Master Thread 、IO Thread、Purge Thread、Page Cleaner Thread。</p><p><strong>1.Master Thread</strong></p><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 。</p><p><strong>2.IO Thread</strong></p><p>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IOThread主要负责这些IO请求的回调。</p><table><thead><tr><th><strong>线程类型</strong></th><th>默认个数</th><th><strong>职责</strong></th></tr></thead><tbody><tr><td>Read thread</td><td>4</td><td>负责读操作</td></tr><tr><td>Write thread</td><td>4</td><td>负责写操作</td></tr><tr><td>Log thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>Insert buffer thread</td><td>1</td><td>负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table><p>我们可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show engine innodb status;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../image/MySQLPic/InnoDB%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF.webp"></p><p><strong>3.Purge Thread</strong></p><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p><p><strong>4.Page Cleaner Thread</strong></p><p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p><h4 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h4><h5 id="事务基础"><a href="#事务基础" class="headerlink" title="事务基础"></a>事务基础</h5><p>1.事务</p><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>2.特性</p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul><p>那实际上，我们研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。</p><p><img src="/../image/MySQLPic/InnoDB%E5%9B%9B%E7%89%B9%E6%80%A7.webp"></p><p>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 而持久性是通过数据库的锁，加上MVCC来保证的。</p><p><img src="/../image/MySQLPic/%E5%9B%9B%E7%89%B9%E6%80%A7+MVCC.webp"></p><h5 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h5><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>如果没有redolog，可能会存在什么问题的？ 我们一起来分析一下。</p><p>我们知道，在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却没有持久化下来，这就出现问题了，没有保证事务的持久性。</p><p><img src="/../image/MySQLPic/redolog%E6%8C%81%E4%B9%85%E6%80%A7%E9%97%AE%E9%A2%98.webp"></p><p>那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，接下来我们再来分析一下，通过redolog如何解决这个问题。</p><p><img src="/../image/MySQLPic/redolog%E8%A7%A3%E5%86%B3.webp"></p><p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redo log buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，<strong>发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。</strong> 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的。</p><p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?</p><p>因为在业务操作中，<strong>我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。</strong> 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p><h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h5><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和MVCC(多版本并发控制) 。</p><p>undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><p>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</p><p>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment回滚段中，内部包含1024个undo log segment。</p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>1.当前读</p><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：<code>select ... lock in share mode</code>(共享锁)，<code>select ...for update</code>、<code>update</code>、<code>insert</code>、<code>delete</code>(排他锁)都是一种当前读。</p><p>测试:</p><p><img src="/../image/MySQLPic/MVCC%E6%B5%8B%E8%AF%95-1.webp"></p><p>在测试中我们可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内容，因为在查询语句后面加上了 <code>lock in share mode</code> 共享锁，此时是当前读操作。当然，当我们加排他锁的时候，也是当前读操作。</p><p>2.快照读</p><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li>Read Committed：每次select，都生成一个快照读。</li><li>Repeatable Read：开启事务后第一个select语句才是快照读的地方。</li><li>Serializable：快照读会退化为当前读。</li></ul><p>测试:</p><p><img src="/../image/MySQLPic/MVCC%E6%B5%8B%E8%AF%95-2.webp"></p><p>在测试中,我们看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。</p><p>3.MVCC</p><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><p>接下来，我们再来介绍一下InnoDB引擎的表中涉及到的隐藏字段 、undolog 以及 readview，从而来介绍一下MVCC的原理。</p><h5 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h5><p>介绍：</p><p><img src="/../image/MySQLPic/%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5%E4%BB%8B%E7%BB%8D.webp"></p><p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了这三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p><table><thead><tr><th><strong>隐藏字段</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。</p><p>测试：</p><p>1.查看有主键的表 stu</p><p>进入服务器中的 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;MySQL_Advanced&#x2F; , 查看stu的表结构信息, 通过如下指令:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ibd2sdi stu.ibd</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有额外的两个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR ，因为该表有主键，所以没有DB_ROW_ID隐藏字段。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;DB_TRX_ID&quot;,</span><br><span class="line">    &quot;type&quot;: <span class="number">10</span>,</span><br><span class="line">    &quot;is_nullable&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;is_zerofill&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;is_unsigned&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;is_auto_increment&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;is_virtual&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;hidden&quot;: <span class="number">2</span>,</span><br><span class="line">    &quot;ordinal_position&quot;: <span class="number">4</span>,</span><br><span class="line">    &quot;char_length&quot;: <span class="number">6</span>,</span><br><span class="line">    &quot;numeric_precision&quot;: <span class="number">0</span>,</span><br><span class="line">    &quot;numeric_scale&quot;: <span class="number">0</span>,</span><br><span class="line">    &quot;numeric_scale_null&quot;: <span class="literal">true</span>,</span><br><span class="line">    &quot;datetime_precision&quot;: <span class="number">0</span>,</span><br><span class="line">    &quot;datetime_precision_null&quot;: <span class="number">1</span>,</span><br><span class="line">    &quot;has_no_default&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;default_value_null&quot;: <span class="literal">true</span>,</span><br><span class="line">    &quot;srs_id_null&quot;: <span class="literal">true</span>,</span><br><span class="line">    &quot;srs_id&quot;: <span class="number">0</span>,</span><br><span class="line">    &quot;default_value&quot;: &quot;&quot;,</span><br><span class="line">    &quot;default_value_utf8_null&quot;: <span class="literal">true</span>,</span><br><span class="line">    &quot;default_value_utf8&quot;: &quot;&quot;,</span><br><span class="line">    &quot;default_option&quot;: &quot;&quot;,</span><br><span class="line">    &quot;update_option&quot;: &quot;&quot;,</span><br><span class="line">    &quot;comment&quot;: &quot;&quot;,</span><br><span class="line">    &quot;generation_expression&quot;: &quot;&quot;,</span><br><span class="line">    &quot;generation_expression_utf8&quot;: &quot;&quot;,</span><br><span class="line">    &quot;options&quot;: &quot;&quot;,</span><br><span class="line">    &quot;se_private_data&quot;: &quot;table_id=1074;&quot;,</span><br><span class="line">    &quot;engine_attribute&quot;: &quot;&quot;,</span><br><span class="line">    &quot;secondary_engine_attribute&quot;: &quot;&quot;,</span><br><span class="line">    &quot;column_key&quot;: <span class="number">1</span>,</span><br><span class="line">    &quot;column_type_utf8&quot;: &quot;&quot;,</span><br><span class="line">    &quot;elements&quot;: [],</span><br><span class="line">    &quot;collation_id&quot;: <span class="number">63</span>,</span><br><span class="line">    &quot;is_explicit_collation&quot;: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;DB_ROLL_PTR&quot;,</span><br><span class="line">    &quot;type&quot;: <span class="number">9</span>,</span><br><span class="line">    &quot;is_nullable&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;is_zerofill&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;is_unsigned&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;is_auto_increment&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;is_virtual&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;hidden&quot;: <span class="number">2</span>,</span><br><span class="line">    &quot;ordinal_position&quot;: <span class="number">5</span>,</span><br><span class="line">    &quot;char_length&quot;: <span class="number">7</span>,</span><br><span class="line">    &quot;numeric_precision&quot;: <span class="number">0</span>,</span><br><span class="line">    &quot;numeric_scale&quot;: <span class="number">0</span>,</span><br><span class="line">    &quot;numeric_scale_null&quot;: <span class="literal">true</span>,</span><br><span class="line">    &quot;datetime_precision&quot;: <span class="number">0</span>,</span><br><span class="line">    &quot;datetime_precision_null&quot;: <span class="number">1</span>,</span><br><span class="line">    &quot;has_no_default&quot;: <span class="literal">false</span>,</span><br><span class="line">    &quot;default_value_null&quot;: <span class="literal">true</span>,</span><br><span class="line">    &quot;srs_id_null&quot;: <span class="literal">true</span>,</span><br><span class="line">    &quot;srs_id&quot;: <span class="number">0</span>,</span><br><span class="line">    &quot;default_value&quot;: &quot;&quot;,</span><br><span class="line">    &quot;default_value_utf8_null&quot;: <span class="literal">true</span>,</span><br><span class="line">    &quot;default_value_utf8&quot;: &quot;&quot;,</span><br><span class="line">    &quot;default_option&quot;: &quot;&quot;,</span><br><span class="line">    &quot;update_option&quot;: &quot;&quot;,</span><br><span class="line">    &quot;comment&quot;: &quot;&quot;,</span><br><span class="line">    &quot;generation_expression&quot;: &quot;&quot;,</span><br><span class="line">    &quot;generation_expression_utf8&quot;: &quot;&quot;,</span><br><span class="line">    &quot;options&quot;: &quot;&quot;,</span><br><span class="line">    &quot;se_private_data&quot;: &quot;table_id=1074;&quot;,</span><br><span class="line">    &quot;engine_attribute&quot;: &quot;&quot;,</span><br><span class="line">    &quot;secondary_engine_attribute&quot;: &quot;&quot;,</span><br><span class="line">    &quot;column_key&quot;: <span class="number">1</span>,</span><br><span class="line">    &quot;column_type_utf8&quot;: &quot;&quot;,</span><br><span class="line">    &quot;elements&quot;: [],</span><br><span class="line">    &quot;collation_id&quot;: <span class="number">63</span>,</span><br><span class="line">    &quot;is_explicit_collation&quot;: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.查看没有主键的表 employee</p><p>建表语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee (id <span class="type">int</span> , name <span class="type">varchar</span>(<span class="number">10</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时，我们再通过以下指令来查看表结构及其其中的字段信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ibd2sdi employee.ibd</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有额外的三个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR 、DB_ROW_ID，因为employee表是没有指定主键的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;DB_ROW_ID&quot;,</span><br><span class="line">        &quot;type&quot;: <span class="number">10</span>,</span><br><span class="line">        &quot;is_nullable&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;is_zerofill&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;is_unsigned&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;is_auto_increment&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;is_virtual&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;hidden&quot;: <span class="number">2</span>,</span><br><span class="line">        &quot;ordinal_position&quot;: <span class="number">3</span>,</span><br><span class="line">        &quot;char_length&quot;: <span class="number">6</span>,</span><br><span class="line">        &quot;numeric_precision&quot;: <span class="number">0</span>,</span><br><span class="line">        &quot;numeric_scale&quot;: <span class="number">0</span>,</span><br><span class="line">        &quot;numeric_scale_null&quot;: <span class="literal">true</span>,</span><br><span class="line">        &quot;datetime_precision&quot;: <span class="number">0</span>,</span><br><span class="line">        &quot;datetime_precision_null&quot;: <span class="number">1</span>,</span><br><span class="line">        &quot;has_no_default&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;default_value_null&quot;: <span class="literal">true</span>,</span><br><span class="line">        &quot;srs_id_null&quot;: <span class="literal">true</span>,</span><br><span class="line">        &quot;srs_id&quot;: <span class="number">0</span>,</span><br><span class="line">        &quot;default_value&quot;: &quot;&quot;,</span><br><span class="line">        &quot;default_value_utf8_null&quot;: <span class="literal">true</span>,</span><br><span class="line">        &quot;default_value_utf8&quot;: &quot;&quot;,</span><br><span class="line">        &quot;default_option&quot;: &quot;&quot;,</span><br><span class="line">        &quot;update_option&quot;: &quot;&quot;,</span><br><span class="line">        &quot;comment&quot;: &quot;&quot;,</span><br><span class="line">        &quot;generation_expression&quot;: &quot;&quot;,</span><br><span class="line">        &quot;generation_expression_utf8&quot;: &quot;&quot;,</span><br><span class="line">        &quot;options&quot;: &quot;&quot;,</span><br><span class="line">        &quot;se_private_data&quot;: &quot;table_id=1076;&quot;,</span><br><span class="line">        &quot;engine_attribute&quot;: &quot;&quot;,</span><br><span class="line">        &quot;secondary_engine_attribute&quot;: &quot;&quot;,</span><br><span class="line">        &quot;column_key&quot;: <span class="number">1</span>,</span><br><span class="line">        &quot;column_type_utf8&quot;: &quot;&quot;,</span><br><span class="line">        &quot;elements&quot;: [],</span><br><span class="line">        &quot;collation_id&quot;: <span class="number">63</span>,</span><br><span class="line">        &quot;is_explicit_collation&quot;: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;DB_TRX_ID&quot;,</span><br><span class="line">        &quot;type&quot;: <span class="number">10</span>,</span><br><span class="line">        &quot;is_nullable&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;is_zerofill&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;is_unsigned&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;is_auto_increment&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;is_virtual&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;hidden&quot;: <span class="number">2</span>,</span><br><span class="line">        &quot;ordinal_position&quot;: <span class="number">4</span>,</span><br><span class="line">        &quot;char_length&quot;: <span class="number">6</span>,</span><br><span class="line">        &quot;numeric_precision&quot;: <span class="number">0</span>,</span><br><span class="line">        &quot;numeric_scale&quot;: <span class="number">0</span>,</span><br><span class="line">        &quot;numeric_scale_null&quot;: <span class="literal">true</span>,</span><br><span class="line">        &quot;datetime_precision&quot;: <span class="number">0</span>,</span><br><span class="line">        &quot;datetime_precision_null&quot;: <span class="number">1</span>,</span><br><span class="line">        &quot;has_no_default&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;default_value_null&quot;: <span class="literal">true</span>,</span><br><span class="line">        &quot;srs_id_null&quot;: <span class="literal">true</span>,</span><br><span class="line">        &quot;srs_id&quot;: <span class="number">0</span>,</span><br><span class="line">        &quot;default_value&quot;: &quot;&quot;,</span><br><span class="line">        &quot;default_value_utf8_null&quot;: <span class="literal">true</span>,</span><br><span class="line">        &quot;default_value_utf8&quot;: &quot;&quot;,</span><br><span class="line">        &quot;default_option&quot;: &quot;&quot;,</span><br><span class="line">        &quot;update_option&quot;: &quot;&quot;,</span><br><span class="line">        &quot;comment&quot;: &quot;&quot;,</span><br><span class="line">        &quot;generation_expression&quot;: &quot;&quot;,</span><br><span class="line">        &quot;generation_expression_utf8&quot;: &quot;&quot;,</span><br><span class="line">        &quot;options&quot;: &quot;&quot;,</span><br><span class="line">        &quot;se_private_data&quot;: &quot;table_id=1076;&quot;,</span><br><span class="line">        &quot;engine_attribute&quot;: &quot;&quot;,</span><br><span class="line">        &quot;secondary_engine_attribute&quot;: &quot;&quot;,</span><br><span class="line">        &quot;column_key&quot;: <span class="number">1</span>,</span><br><span class="line">        &quot;column_type_utf8&quot;: &quot;&quot;,</span><br><span class="line">        &quot;elements&quot;: [],</span><br><span class="line">        &quot;collation_id&quot;: <span class="number">63</span>,</span><br><span class="line">        &quot;is_explicit_collation&quot;: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;DB_ROLL_PTR&quot;,</span><br><span class="line">        &quot;type&quot;: <span class="number">9</span>,</span><br><span class="line">        &quot;is_nullable&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;is_zerofill&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;is_unsigned&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;is_auto_increment&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;is_virtual&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;hidden&quot;: <span class="number">2</span>,</span><br><span class="line">        &quot;ordinal_position&quot;: <span class="number">5</span>,</span><br><span class="line">        &quot;char_length&quot;: <span class="number">7</span>,</span><br><span class="line">        &quot;numeric_precision&quot;: <span class="number">0</span>,</span><br><span class="line">        &quot;numeric_scale&quot;: <span class="number">0</span>,</span><br><span class="line">        &quot;numeric_scale_null&quot;: <span class="literal">true</span>,</span><br><span class="line">        &quot;datetime_precision&quot;: <span class="number">0</span>,</span><br><span class="line">        &quot;datetime_precision_null&quot;: <span class="number">1</span>,</span><br><span class="line">        &quot;has_no_default&quot;: <span class="literal">false</span>,</span><br><span class="line">        &quot;default_value_null&quot;: <span class="literal">true</span>,</span><br><span class="line">        &quot;srs_id_null&quot;: <span class="literal">true</span>,</span><br><span class="line">        &quot;srs_id&quot;: <span class="number">0</span>,</span><br><span class="line">        &quot;default_value&quot;: &quot;&quot;,</span><br><span class="line">        &quot;default_value_utf8_null&quot;: <span class="literal">true</span>,</span><br><span class="line">        &quot;default_value_utf8&quot;: &quot;&quot;,</span><br><span class="line">        &quot;default_option&quot;: &quot;&quot;,</span><br><span class="line">        &quot;update_option&quot;: &quot;&quot;,</span><br><span class="line">        &quot;comment&quot;: &quot;&quot;,</span><br><span class="line">        &quot;generation_expression&quot;: &quot;&quot;,</span><br><span class="line">        &quot;generation_expression_utf8&quot;: &quot;&quot;,</span><br><span class="line">        &quot;options&quot;: &quot;&quot;,</span><br><span class="line">        &quot;se_private_data&quot;: &quot;table_id=1076;&quot;,</span><br><span class="line">        &quot;engine_attribute&quot;: &quot;&quot;,</span><br><span class="line">        &quot;secondary_engine_attribute&quot;: &quot;&quot;,</span><br><span class="line">        &quot;column_key&quot;: <span class="number">1</span>,</span><br><span class="line">        &quot;column_type_utf8&quot;: &quot;&quot;,</span><br><span class="line">        &quot;elements&quot;: [],</span><br><span class="line">        &quot;collation_id&quot;: <span class="number">63</span>,</span><br><span class="line">        &quot;is_explicit_collation&quot;: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="undo-log-1"><a href="#undo-log-1" class="headerlink" title="undo log"></a>undo log</h5><p>介绍：</p><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><p>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p><p>版本链：</p><p>有一张表原始数据为：</p><p><img src="/../image/MySQLPic/%E7%89%88%E6%9C%AC%E9%93%BE%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE.webp"></p><blockquote><p><code>DB_TRX_ID</code> : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。</p><p><code>DB_ROLL_PTR</code>： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</p></blockquote><p>然后，有四个并发事务同时在访问这张表。</p><p>A. 第一步</p><p><img src="/../image/MySQLPic/%E7%89%88%E6%9C%AC%E9%93%BE-1-1.webp"></p><p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/../image/MySQLPic/%E7%89%88%E6%9C%AC%E9%93%BE-1-2.webp"></p><p>B.第二步</p><p><img src="/../image/MySQLPic/%E7%89%88%E6%9C%AC%E9%93%BE-2-1.webp"></p><p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/../image/MySQLPic/%E7%89%88%E6%9C%AC%E9%93%BE-2-2.webp"></p><p>C. 第三步</p><p><img src="/../image/MySQLPic/%E7%89%88%E6%9C%AC%E9%93%BE-3-1.webp"></p><p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="/../image/MySQLPic/%E7%89%88%E6%9C%AC%E9%93%BE-3-2.webp"></p><blockquote><p>最终我们发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p></blockquote><h5 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h5><p>ReadView（读视图）是 快照读 SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id。</p><p>ReadView中包含了四个核心字段：</p><table><thead><tr><th><strong>字段</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务ID集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务ID</td></tr><tr><td>max_trx_id</td><td>预分配事务ID，当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView创建者的事务ID</td></tr></tbody></table><p>而在readview中就规定了版本链数据的访问规则：</p><p>trx_id 代表当前undolog版本链对应事务ID。</p><table><thead><tr><th><strong>条件</strong></th><th><strong>是否可以访问</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>trx_id &#x3D;&#x3D; creator_trx_id</td><td>可以访问该版本</td><td>成立，说明数据是当前这个事务更改的</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>可以访问该版本</td><td>成立，说明数据已经提交了</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>不可以访问该版本</td><td>成立，说明该事务是在ReadView生成后才开启</td></tr><tr><td>min_trx_id &lt;&#x3D; trx_id &lt;&#x3D; max_trx_id</td><td>如果trx_id不在m_ids中，是可以访问该版本的</td><td>成立，说明数据已经提交</td></tr></tbody></table><p>不同的隔离级别，生成ReadView的时机不同：</p><ul><li>READ COMMITTED ：在事务中每一次执行快照读时生成ReadView。</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。</li></ul><h5 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h5><h6 id="RC隔离级别"><a href="#RC隔离级别" class="headerlink" title="RC隔离级别"></a>RC隔离级别</h6><p>RC隔离级别下，在事务中<strong>每一次</strong>执行快照读时生成ReadView。</p><p>我们就来分析事务5中，两次快照读读取数据，是如何获取数据的?</p><p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读都会生成一个ReadView，那么两次生成的ReadView如下。</p><p><img src="/../image/MySQLPic/RC-1.webp"></p><p>那么这两次快照读在获取数据时，就需要根据所生成的ReadView以及ReadView的版本链访问规则，到undolog版本链中匹配数据，最终决定此次快照读返回的数据。</p><p>A. 先来看第一次快照读具体的读取过程：</p><p><img src="/../image/MySQLPic/RC-2.webp"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><ul><li><p>先匹配</p><p><img src="/../image/MySQLPic/RC-3.webp"></p><p>这条记录，这条记录对应的trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。</p></li><li><p>再匹配第二条</p><p><img src="/../image/MySQLPic/RC-4.webp"></p><p>这条记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。</p></li><li><p>再匹配第三条</p><p><img src="/../image/MySQLPic/RC-5.webp"></p><p>这条记录对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照读，返回的数据就是版本链中记录的这条数据。</p></li></ul><p>B. 再来看第二次快照读具体的读取过程:</p><p><img src="/../image/MySQLPic/RC-6.webp"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><ul><li><p>先匹配</p><p><img src="/../image/MySQLPic/RC-7.webp"></p><p>这条记录，这条记录对应的trx_id为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。</p></li><li><p>再匹配第二条</p><p><img src="/../image/MySQLPic/RC-8.webp"></p><p>这条记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次快照读，返回的数据就是版本链中记录的这条数据。</p></li></ul><h6 id="RR隔离级别"><a href="#RR隔离级别" class="headerlink" title="RR隔离级别"></a>RR隔离级别</h6><p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p><p>那MySQL是如何做到可重复读的呢? 我们简单分析一下就知道了</p><p><img src="/../image/MySQLPic/RR-1.webp"></p><p>我们看到，在RR隔离级别下，只是在事务中<strong>第一次</strong>快照读时生成ReadView，后续都是复用该ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。</p><p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p><p><img src="/../image/MySQLPic/RR-2.webp"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
