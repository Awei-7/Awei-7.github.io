<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>八股文面试题 | Awei Blog</title><meta name="author" content="Awei"><meta name="copyright" content="Awei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="用于记录和巩固一些面试相关知识点，不定期添加或修改(记载自B站狂神说Java课程）">
<meta property="og:type" content="article">
<meta property="og:title" content="八股文面试题">
<meta property="og:url" content="https://awei-7.github.io/2024/05/16/%E5%85%AB%E8%82%A1%E6%96%87%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Awei Blog">
<meta property="og:description" content="用于记录和巩固一些面试相关知识点，不定期添加或修改(记载自B站狂神说Java课程）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://awei-7.github.io/image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg">
<meta property="article:published_time" content="2024-05-16T04:20:57.179Z">
<meta property="article:modified_time" content="2024-05-27T02:01:15.758Z">
<meta property="article:author" content="Awei">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://awei-7.github.io/image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg"><link rel="shortcut icon" href="/./image/HeadPic/w.jpg"><link rel="canonical" href="https://awei-7.github.io/2024/05/16/%E5%85%AB%E8%82%A1%E6%96%87%E9%9D%A2%E8%AF%95%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '八股文面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-27 10:01:15'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./image/HeadPic/w.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Awei Blog"><span class="site-name">Awei Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">八股文面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-16T04:20:57.179Z" title="发表于 2024-05-16 12:20:57">2024-05-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-27T02:01:15.758Z" title="更新于 2024-05-27 10:01:15">2024-05-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="八股文面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一、MySQL数据库"><a href="#一、MySQL数据库" class="headerlink" title="一、MySQL数据库"></a>一、MySQL数据库</h2><h3 id="1-在MySQL中如何定位慢查询"><a href="#1-在MySQL中如何定位慢查询" class="headerlink" title="1.在MySQL中如何定位慢查询"></a>1.在MySQL中如何定位慢查询</h3><p>做接口测试的时候，可以在系统中部署运维的监控系统Skywalking，在展示的报表中可以看到具体哪一个接口慢，这里可以看到SQL的具体执行时间，所以可以定位到哪一个SQL出的问题</p>
<p>然后MySQL中也提供了慢日志查询的功能，可以在MySQl的系统文件中开启这个功能，两个参数，一个是开启慢日志查询，一个是设置SQL语句执行时间超过多少就会被记录</p>
<h3 id="2-如何分析这个执行的很慢的SQL语句"><a href="#2-如何分析这个执行的很慢的SQL语句" class="headerlink" title="2.如何分析这个执行的很慢的SQL语句"></a>2.如何分析这个执行的很慢的SQL语句</h3><p>可以在SQL语句前面加个EXPLAIN（MySQL的自动执行计划）来查看这条SQL的执行情况</p>
<p>type:扫描类型，效率从底到高为ALL（全表扫描)&gt;index(全索引扫描，我们的需要的数据在索引中可以获取)&gt;range(使用索引进行范围查找)&gt;ref(使用非唯一索引列进行了关联查询)&gt; eq_ref (使用唯一索引进行关联查询)&gt;const(使用唯一索引查询一行数据)&gt;system(表中只有一行数据)</p>
<p>extra（额外的）:mysql如何查询额外信息，常见的有：</p>
<p>filesort:在排序缓冲区中进行排序，需要回表查询数据</p>
<p>index:表示使用覆盖索引</p>
<p>index scan:排序时使用了索引排序，但如果是按照降序排序的话就会使用反向扫描索引</p>
<p>temporary:查询时要建立一个临时表存放数据</p>
<p>rows:找到了多少行数据</p>
<p>key:实际使用到的索引</p>
<p>id:select查询的优先级，id越大优先级越高，子查询的id一般会更大</p>
<p>select_type:查询的类型,是普通查询还是联合查询还是子查询，常见类型有simple（不包含子查询），primary（标记复杂查询中最外层的查询），union(标记primart只后子查询)</p>
<p>table：者一行的数据是数哪张表的</p>
<p>possible_keys（可能的）:当前查询语句可能用到的索引，可能为null(如果用了索引但是为null有可能是表数据太少innodb认为全表扫描更快)</p>
<p>ref（编号）:显示索引的哪一行被使用了</p>
<h3 id="3-什么是索引"><a href="#3-什么是索引" class="headerlink" title="3.什么是索引"></a>3.什么是索引</h3><p>索引是帮助MySQL高效获取数据的数据结构。就是来提高数据检索效率，降低数据库IO成本，也可以通过索引对数据排序，来降低CPU的消耗</p>
<h3 id="4-索引的底层数据结构、"><a href="#4-索引的底层数据结构、" class="headerlink" title="4.索引的底层数据结构、"></a>4.索引的底层数据结构、</h3><p>MySQL底层默认搜索引擎是InnoDB，使用B+树的数据结构来存储索引，选B+树一个是因为阶数多，路径短，一个是只有叶子节点存指针和数据，非叶子节点都只存指针，三一个是叶子节点是双向链表，方便扫库和区间查询</p>
<h3 id="5-B树和B-树的区别"><a href="#5-B树和B-树的区别" class="headerlink" title="5.B树和B+树的区别"></a>5.B树和B+树的区别</h3><ol>
<li><p>B树的节点都存数据，B+树只有叶子节点存</p>
</li>
<li><p>范围查询，B+树效率更高，因为B+树叶子节点是双向链表</p>
</li>
</ol>
<h3 id="6-聚簇索引和非聚簇索引"><a href="#6-聚簇索引和非聚簇索引" class="headerlink" title="6.聚簇索引和非聚簇索引"></a>6.聚簇索引和非聚簇索引</h3><p>聚簇索引有且只有一个，一般使用主键索引作为聚簇索引，数据跟索引放到一起</p>
<p>非聚簇索引也就是二级索引，数据和索引分开放，叶子节点保存的是对应的主键</p>
<h3 id="7-回表查询"><a href="#7-回表查询" class="headerlink" title="7.回表查询"></a>7.回表查询</h3><p>就是查询返回的字段不在索引字段中，需要拿着二级索引查到的主键，到聚簇索引中找到一整行的数据，然会在返回需要的字段</p>
<h3 id="8-覆盖索引"><a href="#8-覆盖索引" class="headerlink" title="8.覆盖索引"></a>8.覆盖索引</h3><p>就是说需要查询返回的字段正好在使用的索引中，比如说直接找主键值，就直接使用聚簇索引，一次把整行数据都返回，效率高</p>
<h3 id="9-MySQL超大分页怎么解决"><a href="#9-MySQL超大分页怎么解决" class="headerlink" title="9.MySQL超大分页怎么解决"></a>9.MySQL超大分页怎么解决</h3><p>超大分页就是说数据量很大的时候，使用了limit分页查询，然后要对数据进行排序，这效率很低，这时候可以用覆盖索引跟子查询解决</p>
<p>就是说先用子查询找到你要查的那一页的id，然后覆盖索引走聚簇索引，直接能把这些id对应的数据都拿到</p>
<h3 id="10-索引的创建原则"><a href="#10-索引的创建原则" class="headerlink" title="10.索引的创建原则"></a>10.索引的创建原则</h3><ul>
<li>数据量很大必须，这个得看业务，十几万几十万？</li>
<li>查询比较频繁的，比如说排序或者分组什么的</li>
<li>尽量创建联合索引，走覆盖索引效率高</li>
<li>要是字段很长可以看着弄个前缀索引</li>
</ul>
<h3 id="11-索引失效的情况"><a href="#11-索引失效的情况" class="headerlink" title="11.索引失效的情况"></a>11.索引失效的情况</h3><ol>
<li>比如说没遵循最左匹配法则</li>
<li>或者模糊查询%在前面，感觉这种也算(1)</li>
<li>在添加索引的字段上运算或者类型转换</li>
<li>复合索引中使用范围查询，右边的条件索引失效</li>
</ol>
<h3 id="12-优化SQL"><a href="#12-优化SQL" class="headerlink" title="12.优化SQL"></a>12.优化SQL</h3><ol>
<li>优化表的设计，字段的类型选用啥的</li>
<li>索引优化，比如说联合索引包含的字段什么的</li>
<li>SQL语句优化，使用SELECT * 容易导致索引失效，二级索引什么的</li>
<li>主从复制、读写分离，不让写入数据影响读的操作</li>
<li>分库分表</li>
</ol>
<h3 id="13-事务的特性"><a href="#13-事务的特性" class="headerlink" title="13.事务的特性"></a>13.事务的特性</h3><p>ACID</p>
<p>A：原子性（Automicity）要么都成功，要么都失败</p>
<p>C：一致性（Consistency）数据一致，比如说发生数据交换的时候，一边减少另一边就一定要增加</p>
<p>I：隔离性（Isolation）事务在发生时，不受其他事务影响、</p>
<p>D：持久性（Durability）事务提交后，数据持久化，就是保存了</p>
<h3 id="14-并发事务带来的问题"><a href="#14-并发事务带来的问题" class="headerlink" title="14.并发事务带来的问题"></a>14.并发事务带来的问题</h3><p>脏读：就是说A事务修改了数据还没提交就被B事务读到了</p>
<p>不可重复读：A事务先读一次数据，B事务修改数据然后提交，A事务又读一次数据，A事务两次读的数据不一样</p>
<p>幻读：就是A事务先读几行数据，B事务添加了几行数据，A事务再查询的时候发现多了几行数据</p>
<h3 id="15-怎么解决并发问题？MySQL的隔离级别"><a href="#15-怎么解决并发问题？MySQL的隔离级别" class="headerlink" title="15.怎么解决并发问题？MySQL的隔离级别"></a>15.怎么解决并发问题？MySQL的隔离级别</h3><p>未提交读（read uncommitted）解决不了任何问题</p>
<p>读已提交（read committed）只解决脏读</p>
<p>可重复读（repeatable read）解决脏读、不可重复读，也是MySQL默认隔离级别</p>
<p>串行化（serializable）：解决所有问题，但性能低</p>
<h3 id="16-undo-log和redo-log的区别"><a href="#16-undo-log和redo-log的区别" class="headerlink" title="16.undo log和redo log的区别"></a>16.undo log和redo log的区别</h3><p>redo log日志记录的时数据页的物理变化，服务宕机的时候用来同步数据，undo log主要记录逻辑日志，事务回滚时使用逆操作来回复原来的数据</p>
<h3 id="17-解决MVCC，怎么保证事务的隔离性"><a href="#17-解决MVCC，怎么保证事务的隔离性" class="headerlink" title="17.解决MVCC，怎么保证事务的隔离性"></a>17.解决MVCC，怎么保证事务的隔离性</h3><p>事务的隔离性由锁和MVCC实现</p>
<p>MVCC是多版本并发控制，就是维护一个数据的多个版本，是读写操作没有冲突</p>
<p>MVCC底层分成三个部分：隐藏字段、undo log日志、readView读视图</p>
<p>隐藏字段有</p>
<ol>
<li>rex_id（事务id），记录每一次事务操作id，自增的</li>
<li>roll_pointer（回滚指针），指向上一个版本的事务版本记录地址</li>
</ol>
<p>undo log 记录回滚日志，存储老版本数据，并形成一个版本链，通过roll_pointer</p>
<p>readView 就是通过一些规则判断出访问哪个版本的数据。rc隔离级别下，每次执行快照读时都生成一次readView；rr隔离级别只有第一次执行快照读时生成readView</p>
<h3 id="18-主从同步原理"><a href="#18-主从同步原理" class="headerlink" title="18.主从同步原理"></a>18.主从同步原理</h3><p>MySQL主从复制核心是二进制日志，其中记录了所有DDL和DML语句。</p>
<p>主从同步具体过程：</p>
<ol>
<li>Master主库提交事务时，把变更数据记录在二进制文件Binlog中</li>
<li>从库读取主库的二进制文件Binlog，写入从库的中继日志Relay Log</li>
<li>slave重做中级日志中的事件，以此改变从库的数据</li>
</ol>
<h3 id="19-分库分表"><a href="#19-分库分表" class="headerlink" title="19.分库分表"></a>19.分库分表</h3><p>水平分库：将一个库的数据拆分到多个库中，解决数据量大和高并发，库都相同</p>
<p>水平分表：解决单表存储和性能问题</p>
<p>垂直分库：根据业务进行拆分，高并发下提高磁盘IO和网络连接数</p>
<p>垂直分表：冷热数据分离，多表互不影响</p>
<h3 id="20-MyIsAm和InnoDB的区别"><a href="#20-MyIsAm和InnoDB的区别" class="headerlink" title="20.MyIsAm和InnoDB的区别"></a>20.MyIsAm和InnoDB的区别</h3><p>InnoDB有三大特性，分别是事务、外键、行级锁，这些都是MyIsAm不支持的，</p>
<p>另外InnoDB是聚簇索引，MyIAm是非聚簇索引，</p>
<p>InnoDB不支持全文索引，MyIAm支持</p>
<p>InnoDB支持自增和MVCC模式的读写，MyIAm不支持</p>
<p>MyIsAM的访问速度一般InnoDB快，差异在于innodb的mvcc、行锁会比较消耗性能，还可能有回表的过程（先去辅助索引中查询数据，找到数据对应的key之后，再通过key回表到聚簇索引树查找数据）</p>
<h3 id="21-事务靠什么保证"><a href="#21-事务靠什么保证" class="headerlink" title="21.事务靠什么保证"></a>21.事务靠什么保证</h3><p>原子性：由undolog日志保证，他记录了需要回滚的日志信息，回滚时撤销已执行的sql</p>
<p>一致性：由其他三大特性共同保证，是事务的目的</p>
<p>隔离性：由MVCC保证</p>
<p>持久性：由redolog日志和内存保证，mysql修改数据时内存和redolog会记录操作，宕机时可恢复</p>
<h3 id="22-什么是快照读和当前读"><a href="#22-什么是快照读和当前读" class="headerlink" title="22.什么是快照读和当前读"></a>22.什么是快照读和当前读</h3><p>*快照读读取的是当前数据的可见版本，可能是会过期数据，不加锁的select就是快照都</p>
<p>*当前读读取的是数据的最新版本，并且当前读返回的记录都会上锁，保证其他事务不会并发修改这条记录。如update、insert、delete、select for undate（排他锁）、select lockin share mode（共享锁） 都是当前读</p>
<h3 id="23-MySQL有哪些索引"><a href="#23-MySQL有哪些索引" class="headerlink" title="23.MySQL有哪些索引"></a>23.MySQL有哪些索引</h3><p>主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值</p>
<p>唯一索引：唯一索引不能有相同值，但允许为空</p>
<p>普通索引：允许出现重复值</p>
<p>组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则</p>
<p>全文索引：myisam引擎支持，通过建立倒排索引提升检索效率，广泛用于搜索引擎</p>
<h3 id="24-为什么要用内连接而不用外连接"><a href="#24-为什么要用内连接而不用外连接" class="headerlink" title="24.为什么要用内连接而不用外连接"></a>24.为什么要用内连接而不用外连接</h3><p>用外连接的话连接顺序是固定死的，比如left join，他必须先对左表进行全表扫描，然后一条条到右表去匹配；而内连接的话mysql会自己根据查询优化器去判断用哪个表做驱动。</p>
<p>子查询的话同样也会对驱动表进行全表扫描，所以尽量用小表做驱动表。</p>
<h3 id="25-MySQL整个查询的过程"><a href="#25-MySQL整个查询的过程" class="headerlink" title="25.MySQL整个查询的过程"></a>25.MySQL整个查询的过程</h3><p>（1）客户端向 MySQL 服务器发送一条查询请求</p>
<p>（2）服务器首先检查查询缓存，如果命中缓存，则返回存储在缓存中的结果。否则进入下一阶段</p>
<p>（3）服务器进行 SQL 解析、预处理、再由优化器生成对应的执行计划</p>
<p>（4）MySQL 根据执行计划，调用存储引擎的 API 来执行查询</p>
<p>（5）将结果返回给客户端，同时缓存查询结果</p>
<p>注意：只有在8.0之前才有查询缓存，8.0之后查询缓存被去掉了</p>
<h3 id="26-MySQL有哪些锁"><a href="#26-MySQL有哪些锁" class="headerlink" title="26.MySQL有哪些锁"></a>26.MySQL有哪些锁</h3><p>基于粒度：</p>
<p>*表级锁：对整张表加锁，粒度大并发小</p>
<p>*行级锁：对行加锁，粒度小并发大</p>
<p>*间隙锁：间隙锁，锁住表的一个区间，间隙锁之间不会冲突只在可重复读下才生效，解决了幻读</p>
<p>基于属性：</p>
<p>*共享锁：又称读锁，一个事务为表加了读锁，其它事务只能加读锁，不能加写锁</p>
<p>*排他锁：又称写锁，一个事务加写锁之后，其他事务不能再加任何锁，避免脏读问题</p>
<h3 id="27-Mysql内连接、左连接、右连接的区别"><a href="#27-Mysql内连接、左连接、右连接的区别" class="headerlink" title="27.Mysql内连接、左连接、右连接的区别"></a>27.Mysql内连接、左连接、右连接的区别</h3><p>内连接取量表交集部分，左连接取左表全部右表匹部分，右连接取右表全部坐表匹部分</p>
<h3 id="28-where和having的区别"><a href="#28-where和having的区别" class="headerlink" title="28.where和having的区别"></a>28.where和having的区别</h3><p>where是约束声明，having是过滤声明，where早于having执行，并且where不可以使用聚合函数，having可以</p>
<h3 id="29-三大范式"><a href="#29-三大范式" class="headerlink" title="29.三大范式"></a>29.三大范式</h3><p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<h3 id="30-char和varchar的区别"><a href="#30-char和varchar的区别" class="headerlink" title="30.char和varchar的区别"></a>30.char和varchar的区别</h3><p>char是不可变的，最大长度为255，varchar是可变的字符串，最大长度为2^16</p>
<h3 id="31-MySQL-删除自增-id，随后重启-MySQL-服务，再插入数据，自增-id-会从几开始"><a href="#31-MySQL-删除自增-id，随后重启-MySQL-服务，再插入数据，自增-id-会从几开始" class="headerlink" title="31.MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始"></a>31.MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始</h3><p>innodb 引擎：</p>
<p>MySQL8.0前，下次自增会取表中最大 id + 1。原理是最大id会记录在内存中，重启之后会重新读取表中最大的id</p>
<p>MySQL8.0后，仍从删除数据 id 后算起。原理是它将最大id记录在redolog里了</p>
<p>myisam：</p>
<p>自增的 id 都从删除数据 id 后算起。原理是它将最大id记录到数据文件里了</p>
<h2 id="二、Spring框架"><a href="#二、Spring框架" class="headerlink" title="二、Spring框架"></a>二、Spring框架</h2><h3 id="1-Spring框架中的单例bean时线程安全的吗"><a href="#1-Spring框架中的单例bean时线程安全的吗" class="headerlink" title="1.Spring框架中的单例bean时线程安全的吗"></a>1.Spring框架中的单例bean时线程安全的吗</h3><p>不是线程安全的</p>
<p>多用户同时请求一个服务时，Spring容器会给每一个请求分配一个线程，多个线程会并发执行这个请求对应的业务逻辑，而Spring框架并没有对单例bean进行任何多线程的封装处理</p>
<h3 id="2-什么是AOP"><a href="#2-什么是AOP" class="headerlink" title="2.什么是AOP"></a>2.什么是AOP</h3><p>AOP是面向切面编程，可以将那些与业务不相关但是很多业务都要调用的代码抽取出来，思想就是不侵入原有代码的情况下对功能进行增强。</p>
<p>SpringAOP是基于动态代理实现的，动态代理是有两种，一种是jdk动态代理，一种是cglib动态代理;</p>
<p>jdk动态代理是原理是利用反射来实现的，需要调用反射包下的Proxy类的newProxyInstance方法来返回代理对象，这个方法中有三个参数，分别是用于加载代理类的类加载器，被代理类实现的接口的class数组和一个用于增强方法的InvocaHandler实现类。</p>
<p>cglib动态代理原理是利用asm开源包来实现的，是把被代理类的class文件加载进来，通过修改它的字节码生成子类来处理</p>
<p>jdk动态代理要求被代理类必须有实现的接口，生成的动态代理类会和代理类实现同样的接口，cglib则，生成的动态代理类会继承被代理类。Spring默认使用jdk动态代理，当被代理的类没有接口时就使用cglib动态代理</p>
<h3 id="3-Spring中的事务怎么实现"><a href="#3-Spring中的事务怎么实现" class="headerlink" title="3.Spring中的事务怎么实现"></a>3.Spring中的事务怎么实现</h3><p>本质是通过AOP对一个方法前后进行拦截，在执行方法前开启事务，之后根据执行情况提交或者回滚事务</p>
<h3 id="4-Spring中事务失效的情况"><a href="#4-Spring中事务失效的情况" class="headerlink" title="4.Spring中事务失效的情况"></a>4.Spring中事务失效的情况</h3><ol>
<li>异常捕获处理：就是自己处理了异常没有抛出，比如try catch，这种时候手动抛出就行</li>
<li>抛出检查异常，配置roll back for属性为Exception，其实就是默认检查抛出某一类异常，而新的异常不在这类里，就扩大范围</li>
<li>非public方法导致的异常，将方法改成public</li>
</ol>
<h3 id="5-Spring中bean的生命周期"><a href="#5-Spring中bean的生命周期" class="headerlink" title="5.Spring中bean的生命周期"></a>5.Spring中bean的生命周期</h3><ol>
<li>通过BeanDefinition获取bean的定义信息</li>
<li>调用构造函数实例化bean</li>
<li>bean的依赖注入</li>
<li>处理Aware接口（BeanNameAware、BeanFactoryAware、ApplicationContextAware）</li>
<li>Bean的后置处理器BeanPoatProcessor-前置</li>
<li>初始化方法（InitializingBean、init-method）</li>
<li>Bean的后置处理器BeanPostProcessor-后置</li>
<li>销毁bean</li>
</ol>
<h3 id="6-构造方法出现循环依赖怎么解决"><a href="#6-构造方法出现循环依赖怎么解决" class="headerlink" title="6.构造方法出现循环依赖怎么解决"></a>6.构造方法出现循环依赖怎么解决</h3><p>A依赖于B，B依赖于A，构造函数注入</p>
<p>因为bean声明周期中构造函数是第一个执行的，所以spring框架并不能解决问题</p>
<p>使用@lazy懒加载，什么时候需要对象在进行bean对象的创建</p>
<h3 id="7-SpringMVC的执行流程"><a href="#7-SpringMVC的执行流程" class="headerlink" title="7.SpringMVC的执行流程"></a>7.SpringMVC的执行流程</h3><ol>
<li>用户发送请求到前端控制器DisPatcherServlet</li>
<li>DisPatcherSerclet收到请求调用HandlerMapping（处理映射器）</li>
<li>HandlerMapping找到具体的处理器，生成处理器对象以及处理器拦截器（如果有），在一起返回给DisPatcherServlet</li>
<li>dispatcherServlet调用handlerAdapter（处理器适配器）</li>
<li>HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）</li>
<li>方法上添加了@ResponseBody</li>
<li>通过HttpMessageConverter来返回结果转换为JSON并相应</li>
</ol>
<h3 id="8-Spring框架的常见注解"><a href="#8-Spring框架的常见注解" class="headerlink" title="8.Spring框架的常见注解"></a>8.Spring框架的常见注解</h3><p>@component、@Controller、@Service、@Repository</p>
<p>@Autowired、@Import</p>
<h3 id="9-Springboot的自动装配"><a href="#9-Springboot的自动装配" class="headerlink" title="9.Springboot的自动装配"></a>9.Springboot的自动装配</h3><ol>
<li>springboot项目中的引导类上有个注解@SpringBootApplication，他对三个注解进行封装:@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan</li>
<li>其中@EnableAutoConfiguration是实现自动化配置的核心注解，就是通过@import注解导入对应的配置选择器。内部读取了相关jar包的classpath路径下META-INF&#x2F;spring.factories文件中配置的全类名，在这些配置类中定义的bean对根据条件注解所指定的条件来决定是否需要将其导入Spring容器中</li>
<li>条件判断会有像@ConditionalOnClass这样的注解，判断是否有对象的class文件，有就加载这个类，把这个配置的所有Bean放入spring容器中使用</li>
</ol>
<h2 id="三、MyBatis"><a href="#三、MyBatis" class="headerlink" title="三、MyBatis"></a>三、MyBatis</h2><h3 id="1-MyBatis的执行流程"><a href="#1-MyBatis的执行流程" class="headerlink" title="1.MyBatis的执行流程"></a>1.MyBatis的执行流程</h3><ol>
<li>读取MyBatis的配置文件：mybatis-config.xml加载运行环境和映射文件</li>
<li>构建会话工厂SqlSessionFactory</li>
<li>会话工厂创建SqlSession对象（包含了执行SQL语句的所有方法）</li>
<li>操作数据库的接口，Executor执行器，同时负责查询缓存的维护</li>
<li>Executor接口的执行方法中有一个MappedStatement类型的参数，封装了映射信息</li>
<li>输入参数映射</li>
<li>输出参数映射</li>
</ol>
<h3 id="2-Mybatis是否支持延迟加载"><a href="#2-Mybatis是否支持延迟加载" class="headerlink" title="2.Mybatis是否支持延迟加载"></a>2.Mybatis是否支持延迟加载</h3><ul>
<li>延迟加载的意思是：就是在需要用到数据时才进行加载，不需要时就不加载</li>
<li>Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载</li>
<li>在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false，默认关闭</li>
</ul>
<h3 id="3-延迟加载的底层原理"><a href="#3-延迟加载的底层原理" class="headerlink" title="3.延迟加载的底层原理"></a>3.延迟加载的底层原理</h3><ol>
<li>使用CGLIB创建目标对象的代理对象</li>
<li>当调用目标方法时，进入拦截器invoke方法，发现目标方法时null值，执行sql查询</li>
<li>获取数据以后，调用set方法设置属性值，在继续查询目标方法，就有值了</li>
</ol>
<h3 id="4-Mybatis的一级、二级缓存"><a href="#4-Mybatis的一级、二级缓存" class="headerlink" title="4.Mybatis的一级、二级缓存"></a>4.Mybatis的一级、二级缓存</h3><ul>
<li>一级缓存：基于PerpetualCache的HashMap本地缓存，存储作用域时Session，当会话进行flush或close之后，改Session中的所有Cache清空，默认打开一级缓存</li>
<li>二级缓存：基于namespace和mapper的作用域起作用的，不依赖于SQL session，默认使用PerpetualCache，HashMap存储。要单独开启，一个是核心配置，一个是mapper映射文件</li>
</ul>
<h3 id="5-Mybatis的二级缓存什么时候会清理缓存中的数据"><a href="#5-Mybatis的二级缓存什么时候会清理缓存中的数据" class="headerlink" title="5.Mybatis的二级缓存什么时候会清理缓存中的数据"></a>5.Mybatis的二级缓存什么时候会清理缓存中的数据</h3><p>当某一个作用域（一级缓存Session&#x2F;二级缓存Namespaces）进行了新增、修改、删除操作后，默认该作用域下所有select中的缓存将被clear</p>
<h2 id="四、Java基础"><a href="#四、Java基础" class="headerlink" title="四、Java基础"></a>四、Java基础</h2><h3 id="1-接口和抽象类的区别"><a href="#1-接口和抽象类的区别" class="headerlink" title="1.接口和抽象类的区别"></a>1.接口和抽象类的区别</h3><p>相同点：</p>
<ul>
<li>继承抽象类或者实现接口的子类都必须重写或者说实现其中的抽象方法</li>
<li>他俩都不能被实例化</li>
</ul>
<p>不同点：</p>
<ul>
<li>抽象类中可以有普通方法和代码块，而接口中只能有抽象方法、静态方法和默认方法</li>
<li>抽象类中的成员变量可以是多种类型的，而接口中只能是public static final类型，还必须赋值</li>
<li>抽象类中可以有构造方法，接口没有</li>
</ul>
<h3 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.重载和重写的区别"></a>2.重载和重写的区别</h3><p>重载发生在同一个类中，就是方法名相同，参数列表、返回值类型、权限修饰符都可以不同</p>
<p>重写发生在具有继承关系的子类中，方法名、参数列表、返回值类型、权限修饰符都相同，重写方法的权限修饰符要大于父类，声明异常的范围要小于父类，然后private和final的方法不能重写</p>
<h3 id="3-和equals的区别"><a href="#3-和equals的区别" class="headerlink" title="3.&#x3D;&#x3D;和equals的区别"></a>3.&#x3D;&#x3D;和equals的区别</h3><ul>
<li>当&#x3D;&#x3D;作用于基本数据类型时，比较的是值，作用于引用数据类型时，比较的是内存地址</li>
<li>equals方法在Object类中，Object是所有类的直接或者间接父类，没有重写过的equals方法比较的是两者之前的内存地址，经过String类重写过的，比较的是字符值，重写equals后也要重写hashcode方法</li>
</ul>
<h3 id="4-异常处理机制"><a href="#4-异常处理机制" class="headerlink" title="4.异常处理机制"></a>4.异常处理机制</h3><ol>
<li>try catch finally ：捕获异常，finally中的代码一定会在最后执行，捕获异常以后程序也继续执行</li>
<li>throws：抛出异常，一般用在方法的声明处，就是throws + 异常类型，会把异常抛给方法的调用者，出现异常后，程序终止</li>
<li>throw：手动抛出异常，一般在代码里，后面跟着new 异常类型</li>
</ol>
<h3 id="5-HashMap的实现原理"><a href="#5-HashMap的实现原理" class="headerlink" title="5.HashMap的实现原理"></a>5.HashMap的实现原理</h3><ol>
<li>在jdk1.8以后，hashmap的底层使用数组+链表+红黑树的机制，hashmap的特点是线程不安全，key不重复，key和value都可以为null</li>
<li>扩容机制：hashmap的数组容量为16，负载因子为0.75，当hashmap中的元素个数超过容量*负载因子时，就会进行扩容，就是创建一个容量是原来两倍的数组，然后把原数组的值都复制过来。当数组长度大于64或者链表长度大于8时，链表变成红黑树，小于6变回来</li>
<li>存取原理：计算key的hash值，进行二次hash，得到key在数组中的位置。如果这个位置有值，就通过equals进行比较，结果为true，就覆盖这个值，结果为false，就尾插法插入这个位置挂的链表，头插法在并发扩容的情况下会发生数据循环</li>
</ol>
<h3 id="6-怎么使用线程安全的hashmap"><a href="#6-怎么使用线程安全的hashmap" class="headerlink" title="6.怎么使用线程安全的hashmap"></a>6.怎么使用线程安全的hashmap</h3><ol>
<li>使用hashtable</li>
<li>使用ConcurrentHashMap</li>
<li>使用Collections.synchronizedHashMap方法</li>
</ol>
<h3 id="7-ConCurrentHashMap怎么保证线程安全"><a href="#7-ConCurrentHashMap怎么保证线程安全" class="headerlink" title="7.ConCurrentHashMap怎么保证线程安全"></a>7.ConCurrentHashMap怎么保证线程安全</h3><ul>
<li>1.7中采用分段锁，就是将一个map分成16个段，每一个段都是一个hashmap，每次操作都对其中的一个段加锁</li>
<li>1.8采用CAS+synchronized，每次插入数据的时候看数组下标是不是第一次插入，是的话就用CAS方式插入，判断数组是不是在进行扩容，是的话就线程参与扩容。删除元素用synchronized修饰，保证并发下移除元素的线程安全</li>
</ul>
<h3 id="8-HashMap和HashTable的区别"><a href="#8-HashMap和HashTable的区别" class="headerlink" title="8.HashMap和HashTable的区别"></a>8.HashMap和HashTable的区别</h3><ol>
<li>hashtable中每个方法都有synchronized修饰，因此线程安全，效率低</li>
<li>hashtable中key不允许为null</li>
<li>hashtable中key只进行一次hash，hashmap两次</li>
<li>hashtable底层是链表+数组，hashmap底层链表+数组+红黑树</li>
</ol>
<h3 id="9-ArrayList和LinkedList区别"><a href="#9-ArrayList和LinkedList区别" class="headerlink" title="9.ArrayList和LinkedList区别"></a>9.ArrayList和LinkedList区别</h3><ul>
<li>arraylist底层是动态数组，默认容量为10，元素个数达到上限开始扩容为原来的1.5倍，在内存中连续的，查找快，插入慢</li>
<li>linkedlist底层是链表，没有扩容机制，在内存中是离散的，查找慢，插入快</li>
</ul>
<h3 id="10-怎么保证ArrayList的线程安全"><a href="#10-怎么保证ArrayList的线程安全" class="headerlink" title="10.怎么保证ArrayList的线程安全"></a>10.怎么保证ArrayList的线程安全</h3><ol>
<li>Collections.synchronizedlist方法</li>
<li>使用Vector，底层都是动态数组，每个方法都加了synchronized</li>
</ol>
<h3 id="11-String、StringBuilder、StringBuffer的区别"><a href="#11-String、StringBuilder、StringBuffer的区别" class="headerlink" title="11.String、StringBuilder、StringBuffer的区别"></a>11.String、StringBuilder、StringBuffer的区别</h3><ul>
<li>String是char[]数组，线程安全的，使用fianl修饰，每次改变string都会生成一个新的string，在把指针指向新string</li>
<li>StringBuffer是线程安全的，也是synchronized，可对字符串进行操作</li>
<li>StringBuilder是线程不安全的，可对字符串进行操作</li>
<li>少数据量用String，单线程大数据量用String Builder，多线程大数据量用StringBuffer</li>
</ul>
<h3 id="12-hashcode和equals"><a href="#12-hashcode和equals" class="headerlink" title="12.hashcode和equals"></a>12.hashcode和equals</h3><p>hashcode和equals都是Object类中的方法，hashcode通过地址计算hash吗，被重写以后可以通过内容计算hash码；equals通过地址比较两个对象，被重写以后通过内容比较对象</p>
<p>两个对象相等，他们的hashcode和equals一定相等，但hashcode相等的两个对象未必相等</p>
<p>如果重写equals就必须重写hashcode，比如说两个equals相等的string，因为string地址值不相等，所以未重写的hashcode会得到两个值，map中会出现两个相同的key</p>
<h3 id="13-面向对象和面向过程的区别"><a href="#13-面向对象和面向过程的区别" class="headerlink" title="13.面向对象和面向过程的区别"></a>13.面向对象和面向过程的区别</h3><p>面向对象有封装、继承、多态三种特性，比面向过程容易维护和拓展，但面向对象调用类时需要实例化，所以开销大，效率低</p>
<h3 id="14-深拷贝和浅拷贝"><a href="#14-深拷贝和浅拷贝" class="headerlink" title="14.深拷贝和浅拷贝"></a>14.深拷贝和浅拷贝</h3><p>浅拷贝：只复制对象的引用，共享同一片内存</p>
<p>深拷贝：创建一个完全相同的对象，修改新对象不会对原对象造成修改，不共享内存</p>
<h3 id="15-多态的作用"><a href="#15-多态的作用" class="headerlink" title="15.多态的作用"></a>15.多态的作用</h3><p>多态的实现要有继承和重写，即父类的引用指向子类的对象，降低不同类型之间的耦合度，增加类的可扩充性和灵活性</p>
<h3 id="16-什么是反射"><a href="#16-什么是反射" class="headerlink" title="16.什么是反射"></a>16.什么是反射</h3><p>反射就是获取类的class对象，然后动态的获取类的内部结构、方法和属性</p>
<p>场景：操作权限不够的类属性和方法时、实现自定义注解、动态加载第三方jar包时</p>
<p>获取class对象的方式：class.forName（类路径），类.class，对象.getClass()</p>
<h3 id="17-创建对象的五种方式"><a href="#17-创建对象的五种方式" class="headerlink" title="17.创建对象的五种方式"></a>17.创建对象的五种方式</h3><ul>
<li>new 关键字</li>
<li>Class.newInstance</li>
<li>Constructor.newInstance</li>
<li>Clone方法</li>
<li>反序列化</li>
</ul>
<h2 id="五、Java多线程"><a href="#五、Java多线程" class="headerlink" title="五、Java多线程"></a>五、Java多线程</h2><h3 id="1-进程和线程的区别，进程间如何通信"><a href="#1-进程和线程的区别，进程间如何通信" class="headerlink" title="1.进程和线程的区别，进程间如何通信"></a>1.进程和线程的区别，进程间如何通信</h3><p>进程：系统运行的最小单位，进程在运行中都是相互独立的，线程之间可以相互影响</p>
<p>线程：独立运行的最小单位，一个进程包含多个线程，他们共享同一进程的系统资源</p>
<p>进程间通过管道、共享内存、信号量机制、消息队列进行通信</p>
<h3 id="2-什么是线程上下文切换"><a href="#2-什么是线程上下文切换" class="headerlink" title="2.什么是线程上下文切换"></a>2.什么是线程上下文切换</h3><p>当线程被剥夺cpu使用权时，切换到下一线程</p>
<h3 id="3-什么是死锁"><a href="#3-什么是死锁" class="headerlink" title="3.什么是死锁"></a>3.什么是死锁</h3><p>死锁是线程之间执行过程中，争夺系统资源时相互僵持的状态</p>
<p>比如线程1需要执行B方法才能释放A方法，而线程B只有执行A方法才能释放B方法</p>
<h3 id="4-死锁的必要条件"><a href="#4-死锁的必要条件" class="headerlink" title="4.死锁的必要条件"></a>4.死锁的必要条件</h3><ul>
<li>互斥条件：同一资源只能由一个线程读取</li>
<li>不可抢占条件：不能强行剥夺线程占有的资源</li>
<li>请求和保持条件：请求其他资源的同时，对自己手中的资源保持不放</li>
<li>循环等待条件：在等待资源时，形成一个闭环</li>
</ul>
<p>预防死锁破坏其中一个条件就好，比如定时锁，或者让线程尽量用相同的顺序加载资源</p>
<h3 id="5-synchronized和lock的区别"><a href="#5-synchronized和lock的区别" class="headerlink" title="5.synchronized和lock的区别"></a>5.synchronized和lock的区别</h3><ol>
<li>synchronized是关键字，lock是个类</li>
<li>发生异常时，synchronized自动释放锁，lock手动</li>
<li>synchronized是jvm通过监视器实现的，lock通过AQS实现</li>
<li>synchronized是可重入锁、非公平锁、不可中断锁，lock的ReentrantLock是可重入锁，可中断锁，可以是公平锁也可以是非公平锁</li>
</ol>
<h3 id="6-什么是AQS锁"><a href="#6-什么是AQS锁" class="headerlink" title="6.什么是AQS锁"></a>6.什么是AQS锁</h3><p>AQS是一个抽象类，可以用来构造锁和同步类，如ReentrantLock，Semaphore，CountDownLatch，CyclicBarrier。</p>
<p>AQS的原理是，AQS内部有三个核心组件，一个是state代表加锁状态初始值为0，一个是获取到锁的线程，还有一个阻塞队列。当有线程想获取锁时，会以CAS的形式将state变为1，CAS成功后便将加锁线程设为自己。当其他线程来竞争锁时会判断state是不是0，不是0再判断加锁线程是不是自己，不是的话就把自己放入阻塞队列。这个阻塞队列是用双向链表实现的</p>
<p>可重入锁的原理就是每次加锁时判断一下加锁线程是不是自己，是的话state+1，释放锁的时候就将state-1。当state减到0的时候就去唤醒阻塞队列的第一个线程。</p>
<h3 id="7-为什么AQS使用双向链表"><a href="#7-为什么AQS使用双向链表" class="headerlink" title="7.为什么AQS使用双向链表"></a>7.为什么AQS使用双向链表</h3><p>因为一些线程发生中断时，要从同步阻塞队列中删除，双向链表效率高</p>
<h3 id="8-有哪些常见的AQS锁"><a href="#8-有哪些常见的AQS锁" class="headerlink" title="8.有哪些常见的AQS锁"></a>8.有哪些常见的AQS锁</h3><p>AQS分为独占锁和共享锁</p>
<p>ReentrantLock（独占锁）：可重入，可中断，可以是公平锁也可以是非公平锁，非公平锁就是会通过两次CAS去抢占锁，公平锁会按队列顺序排队</p>
<p>Semaphore（信号量）:设定一个信号量，当调用acquire()时判断是否还有信号，有就获取一个信号量，没有就阻塞等待其他线程释放信号量，当调用release()时释放一个信号量，唤醒阻塞线程。</p>
<p>应用场景：允许多个线程访问某个临界资源时，如上下车，买卖票</p>
<p>CountDownLatch（倒计数器）:给计数器设置一个初始值，当调用CountDown()时计数器减一，当调用await() 时判断计数器是否归0，不为0就阻塞，直到计数器为0。</p>
<p>应用场景：启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行</p>
<p>CyclicBarrier（循环栅栏）:给计数器设置一个目标值,当调用await() 时会计数+1并判断计数器是否达到目标值，未达到就阻塞，直到计数器达到目标值</p>
<p>应用场景：多线程计算数据，最后合并计算结果的应用场景</p>
<h3 id="9-sleep和wait的区别"><a href="#9-sleep和wait的区别" class="headerlink" title="9.sleep和wait的区别"></a>9.sleep和wait的区别</h3><ol>
<li>wait是Object中方法，sleep是Thread</li>
<li>wait会释放锁，sleep不会</li>
<li>wait只能写在同步方法或同步代码块中，sleep随意</li>
<li>wait需要notify或notifyAll唤醒，sleep到时间自动</li>
</ol>
<h3 id="10-yield和join的区别"><a href="#10-yield和join的区别" class="headerlink" title="10.yield和join的区别"></a>10.yield和join的区别</h3><p>yield调用后，线程进入就绪状态</p>
<p>A线程调用B线程的join后，在B执行完之前，A进入阻塞状态</p>
<h3 id="11-线程池的参数"><a href="#11-线程池的参数" class="headerlink" title="11.线程池的参数"></a>11.线程池的参数</h3><p>核心线程数：线程池中的基本线程数量</p>
<p>最大线程数：当阻塞队列满了之后，逐一启动</p>
<p>最大线程的存活时间：当阻塞队列的任务执行完后，最大线长的回收时间</p>
<p>最大线程的存活时间单位</p>
<p>阻塞队列：当核心线程满后，后面来的任务都进入阻塞队列</p>
<p>线程工厂：用于生产线程</p>
<p>任务拒绝策略：阻塞队列满后，拒绝任务，有四种策略（1）抛异常（2）丢弃任务不抛异常（3）打回任务（4）尝试与最老的线程竞争</p>
<h3 id="12-Java的内存模型"><a href="#12-Java的内存模型" class="headerlink" title="12.Java的内存模型"></a>12.Java的内存模型</h3><p>JMM（Java内存模型 ）屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各平台下都能达到一致的内存访问效果，它定义了JVM如何将程序中的变量在主存中读取</p>
<p>具体定义为：所有变量都存在主存中，主存是线程共享区域；每个线程都有自己独有的工作内存，线程想要操作变量必须从主从中copy变量到自己的工作区，每个线程的工作内存是相互隔离的</p>
<p>由于主存与工作内存之间有读写延迟，且读写不是原子性操作，所以会有线程安全问题</p>
<h3 id="13-保证并发安全的三大特性"><a href="#13-保证并发安全的三大特性" class="headerlink" title="13.保证并发安全的三大特性"></a>13.保证并发安全的三大特性</h3><p>原子性：一次或多次操作在执行期间不被其他线程影响</p>
<p>可见性：当一个线程在工作内存修改了变量，其他线程能立刻知道</p>
<p>有序性：JVM对指令的优化会让指令执行顺序改变，有序性是禁止指令重排</p>
<h3 id="14-Volatile"><a href="#14-Volatile" class="headerlink" title="14.Volatile"></a>14.Volatile</h3><p>保证变量的可见性和有序性，不保证原子性。使用了 volatile 修饰变量后，在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。</p>
<p>单例模式双重校验锁变量为什么使用 volatile 修饰？ 禁止 JVM 指令重排序，new Object()分为三个步骤：为实例对象分配内存，用构造器初始化成员变量，将实例对象引用指向分配的内存；实例对象在分配内存后实才不为null。如果分配内存后还未初始化就先将实例对象指向了内存，那么此时最外层的if会判断实例对象已经不等于null就直接将实例对象返回。而此时初始化还没有完成。</p>
<h3 id="15-线程使用方法"><a href="#15-线程使用方法" class="headerlink" title="15.线程使用方法"></a>15.线程使用方法</h3><p>(1)继承 Tread 类</p>
<p>(2)实现 Runnable 接口</p>
<p>(3)实现 Callable 接口：带有返回值</p>
<p>(4)线程池创建线程</p>
<h3 id="16-ThreadLocal原理"><a href="#16-ThreadLocal原理" class="headerlink" title="16.ThreadLocal原理"></a>16.ThreadLocal原理</h3><p>原理是为每个线程创建变量副本，不同线程之间不可见，保证线程安全。每个线程内部都维护了一个Map，key为threadLocal实例，value为要保存的副本。</p>
<p>但是使用ThreadLocal会存在内存泄露问题，因为key为弱引用，而value为强引用，每次gc时key都会回收，而value不会被回收。所以为了解决内存泄漏问题，可以在每次使用完后删除value或者使用static修饰ThreadLocal，可以随时获取value</p>
<h3 id="17-什么是CAS锁"><a href="#17-什么是CAS锁" class="headerlink" title="17.什么是CAS锁"></a>17.什么是CAS锁</h3><p>CAS锁可以保证原子性，思想是更新内存时会判断内存值是否被别人修改过，如果没有就直接更新。如果被修改，就重新获取值，直到更新完成为止。这样的缺点是</p>
<p>（1）只能支持一个变量的原子操作，不能保证整个代码块的原子操作</p>
<p>（2）CAS频繁失败导致CPU开销大</p>
<p>（3）ABS问题:线程1和线程2同时去修改一个变量，将值从A改为B，但线程1突然阻塞，此时线程2将A改为B,然后线程3又将B改成A,此时线程1将A又改为B,这个过程线程2是不知道的，这就是ABA问题，可以通过版本号或时间戳解决</p>
<h3 id="18-synchronized锁原理和优化"><a href="#18-synchronized锁原理和优化" class="headerlink" title="18.synchronized锁原理和优化"></a>18.synchronized锁原理和优化</h3><p>Synchronize是通过对象头的markwordk来表明监视器的，监视器本质是依赖操作系统的互斥锁实现的。操作系统实现线程切换要从用户态切换为核心态，成本很高，此时这种锁叫重量级锁，在JDK1.6以后引入了偏向锁、轻量级锁、重量级锁</p>
<p>偏向锁：当一段代码没有别的线程访问，此时线程去访问会直接获取偏向锁</p>
<p>轻量级锁：当锁是偏向锁时，有另外一个线程来访问，会升级为轻量级锁。线程会通过CAS方式获取锁，不会阻塞，提高性能，</p>
<p>重量级锁：轻量级锁自旋一段时间后线程还没有获取到锁，会升级为重量级锁，重量级锁时，来竞争锁的所有线程都会阻塞，性能降低</p>
<p>注意，锁只能升级不能降级</p>
<h3 id="19-如何根据CPU核心数设计线程池线程数量"><a href="#19-如何根据CPU核心数设计线程池线程数量" class="headerlink" title="19.如何根据CPU核心数设计线程池线程数量"></a>19.如何根据CPU核心数设计线程池线程数量</h3><p>io密集型：线程中十分消耗IO的线程数 * 2 </p>
<p>CPU密集型：cpu线程数量</p>
<h3 id="20-AtomicInteger的使用场景"><a href="#20-AtomicInteger的使用场景" class="headerlink" title="20.AtomicInteger的使用场景"></a>20.AtomicInteger的使用场景</h3><p>AtomicInteger是一个提供原子操作的Integer类，使用CAS+volatile实来现线程安全的数值操作。</p>
<p>因为volatile禁止了jvm的排序优化,所以它不适合在并发量小的时候使用，只适合在一些高并发程序中使用</p>
<h2 id="六、JVM篇"><a href="#六、JVM篇" class="headerlink" title="六、JVM篇"></a>六、JVM篇</h2><h3 id="1-jvm运行时数据区（内存结构）"><a href="#1-jvm运行时数据区（内存结构）" class="headerlink" title="1.jvm运行时数据区（内存结构）"></a>1.jvm运行时数据区（内存结构）</h3><p>线程私有区：</p>
<p>（1）虚拟机栈：每次调用方法都会在虚拟机栈中产生一个栈帧，每个栈帧中都有方法的参数、局部变量、方法出口等信息，方法执行完毕后释放栈帧</p>
<p>（2）本地方法栈：为native修饰的本地方法提供的空间，在HotSpot中与虚拟机合二为一</p>
<p>（3）程序计数器：保存指令执行的地址，方便线程切回后能继续执行代码</p>
<p>线程共享区：</p>
<p>（4）堆内存：Jvm进行垃圾回收的主要区域，存放对象信息，分为新生代和老年代，内存比例为1：2，新生代的Eden区内存不够时时发生MinorGC,老年代内存不够时发生FullGC</p>
<p>（5）方法区：存放类信息、静态变量、常量、运行时常量池等信息。JDK1.8之前用持久代实现，JDK1.8后用元空间实现，元空间使用的是本地内存，而非在JVM内存结构中</p>
<h3 id="2-什么情况下会内存溢出"><a href="#2-什么情况下会内存溢出" class="headerlink" title="2.什么情况下会内存溢出"></a>2.什么情况下会内存溢出</h3><p>堆内存溢出：（1）当对象一直创建而不被回收时（2）加载的类越来越多时（3)虚拟机栈的线程越来越多时</p>
<p>栈溢出：方法调用次数过多，一般是递归不当造成</p>
<h3 id="3-JVM有哪些垃圾回收算法"><a href="#3-JVM有哪些垃圾回收算法" class="headerlink" title="3.JVM有哪些垃圾回收算法"></a>3.JVM有哪些垃圾回收算法</h3><p>（1）标记清除算法： 标记不需要回收的对象，然后清除没有标记的对象，会造成许多内存碎片。</p>
<p>（2）复制算法： 将内存分为两块，只使用一块，进行垃圾回收时，先将存活的对象复制到另一块区域，然后清空之前的区域。用在新生代</p>
<p>（3）标记整理算法： 与标记清除算法类似，但是在标记之后，将存活对象向一端移动，然后清除边界外的垃圾对象。用在老年代</p>
<h3 id="4-GC如何判断对象可以被回收"><a href="#4-GC如何判断对象可以被回收" class="headerlink" title="4.GC如何判断对象可以被回收"></a>4.GC如何判断对象可以被回收</h3><p>（1）引用计数法：已淘汰，为每个对象添加引用计数器，引用为0时判定可以回收，会有两个对象相互引用无法回收的问题</p>
<p>（2）可达性分析法：从GCRoot开始往下搜索，搜索过的路径称为引用链，若一个对象GCRoot没有任何的引用链，则判定可以回收</p>
<p>GCRoot有：虚拟机栈中引用的对象，方法区中静态变量引用的对象，本地方法栈中引用的对象</p>
<h3 id="5-典型垃圾回收器"><a href="#5-典型垃圾回收器" class="headerlink" title="5.典型垃圾回收器"></a>5.典型垃圾回收器</h3><p>CMS:以最小的停顿时间为目标、只运行在老年代的垃圾回收器，使用标记-清除算法，可以并发收集。</p>
<p>G1 ：JDK1.9以后的默认垃圾回收器，注重响应速度，支持并发，采用标记整理+复制算法回收内存，使用可达性分析法来判断对象是否可以被回收。</p>
<h3 id="6-类加载器和双亲委派机制"><a href="#6-类加载器和双亲委派机制" class="headerlink" title="6.类加载器和双亲委派机制"></a>6.类加载器和双亲委派机制</h3><p>从父类加载器到子类加载器分别为：</p>
<p>BootStrapClassLoader 加载路径为：JAVA_HOME&#x2F;jre&#x2F;lib</p>
<p>ExtensionClassLoader 加载路径为：JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</p>
<p>ApplicationClassLoader 加载路径为：classpath</p>
<p>还有一个自定义类加载器</p>
<p>当一个类加载器收到类加载请求时，会先把这个请求交给父类加载器处理，若父类加载器找不到该类，再由自己去寻找。该机制可以避免类被重复加载，还可以避免系统级别的类被篡改</p>
<h3 id="7-JVM中有哪些引用"><a href="#7-JVM中有哪些引用" class="headerlink" title="7.JVM中有哪些引用"></a>7.JVM中有哪些引用</h3><p>强引用：new的对象。哪怕内存溢出也不会回收</p>
<p>软引用：只有内存不足时才会回收</p>
<p>弱引用：每次垃圾回收都会回收</p>
<p>虚引用：必须配合引用队列使用，一般用于追踪垃圾回收动作</p>
<h3 id="8-类加载过程"><a href="#8-类加载过程" class="headerlink" title="8.类加载过程"></a>8.类加载过程</h3><p>（1）加载 ：把字节码通过二进制的方式转化到方法区中的运行数据区</p>
<p>（2）连接：</p>
<p>验证：验证字节码文件的正确性。</p>
<p>准备：正式为类变量在方法区中分配内存，并设置初始值，final类型的变量在编译时已经赋值了</p>
<p>解析：将常量池中的符号引用（如类的全限定名）解析为直接引用（类在实际内存中的地址）</p>
<p>（3）初始化 ：执行类构造器（不是常规的构造方法），为静态变量赋初值并初始化静态代码块。</p>
<h3 id="9-JVM类初始化顺序"><a href="#9-JVM类初始化顺序" class="headerlink" title="9.JVM类初始化顺序"></a>9.JVM类初始化顺序</h3><p>父类静态代码块和静态成员变量-&gt;子类静态代码块和静态成员变量-&gt;父类代码块和普通成员变量-&gt;父类构造方法-&gt;子类代码块和普成员变量-&gt;子类构造方法</p>
<h3 id="10-对象的创建过程"><a href="#10-对象的创建过程" class="headerlink" title="10.对象的创建过程"></a>10.对象的创建过程</h3><p>（1）检查类是否已被加载，没有加载就先加载类</p>
<p>（2）为对象在堆中分配内存，使用CAS方式分配，防止在为A分配内存时，执行当前地址的指针还没有来得及修改，对象B就拿来分配内存。</p>
<p>（3）初始化，将对象中的属性都分配0值或null</p>
<p>（4）设置对象头</p>
<p>（5）为属性赋值和执行构造方法</p>
<h3 id="11-对象头中有哪些信息"><a href="#11-对象头中有哪些信息" class="headerlink" title="11.对象头中有哪些信息"></a>11.对象头中有哪些信息</h3><p>对象头中有两部分，一部分是MarkWork,存储对象运行时的数据，如对象的hashcode、GC分代年龄、GC标记、锁的状态、获取到锁的线程ID等；另外一部分是表明对象所属类，如果是数组，还有一个部分存放数组长度</p>
<h3 id="12-JVM内存参数"><a href="#12-JVM内存参数" class="headerlink" title="12.JVM内存参数"></a>12.JVM内存参数</h3><p>-Xmx[]:堆空间最大内存</p>
<p>-Xms[]:堆空间最小内存，一般设置成跟堆空间最大内存一样的</p>
<p>-Xmn[]:新生代的最大内存</p>
<p>-xx:[survivorRatio&#x3D;3]:eden区与from+to区的比例为3：1，默认为4：1</p>
<p>-xx[use 垃圾回收器名称]：指定垃圾回收器</p>
<p>-xss:设置单个线程栈大小</p>
<p>一般设堆空间为最大可用物理地址的百分之80</p>
<h3 id="13-GC的回收机制和原理"><a href="#13-GC的回收机制和原理" class="headerlink" title="13.GC的回收机制和原理"></a>13.GC的回收机制和原理</h3><p>GC的目的实现内存的自动释放，使用可达性分析法判断对象是否可回收，采用了分代回收思想，</p>
<p>将堆分为新生代、老年代，新生代中采用复制算法，老年代采用整理算法，当新生代内存不足时会发生minorGC,老年代不足时会发送fullGC</p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/23/%E5%85%AB%E8%82%A1%E6%96%87/" title="八股文"><img class="cover" src="/./image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">八股文</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/15/Java%E5%9F%BA%E7%A1%80/" title="Java基础-笔记"><img class="cover" src="/./image/HeadPic/%E5%8F%AF%E8%8E%89.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java基础-笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./image/HeadPic/w.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Awei</div><div class="author-info__description">去码头上整点薯条！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn"><i class="fab fa-github"></i><span>这可能是个链接</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">其实没啥公告的</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81MySQL%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.</span> <span class="toc-text">一、MySQL数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9C%A8MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.1.</span> <span class="toc-text">1.在MySQL中如何定位慢查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E8%BF%99%E4%B8%AA%E6%89%A7%E8%A1%8C%E7%9A%84%E5%BE%88%E6%85%A2%E7%9A%84SQL%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.2.</span> <span class="toc-text">2.如何分析这个执行的很慢的SQL语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.</span> <span class="toc-text">3.什么是索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%81"><span class="toc-number">1.4.</span> <span class="toc-text">4.索引的底层数据结构、</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-B%E6%A0%91%E5%92%8CB-%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text">5.B树和B+树的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">1.6.</span> <span class="toc-text">6.聚簇索引和非聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.7.</span> <span class="toc-text">7.回表查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.8.</span> <span class="toc-text">8.覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-MySQL%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">1.9.</span> <span class="toc-text">9.MySQL超大分页怎么解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99"><span class="toc-number">1.10.</span> <span class="toc-text">10.索引的创建原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">1.11.</span> <span class="toc-text">11.索引失效的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BC%98%E5%8C%96SQL"><span class="toc-number">1.12.</span> <span class="toc-text">12.优化SQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.13.</span> <span class="toc-text">13.事务的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.14.</span> <span class="toc-text">14.并发事务带来的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9FMySQL%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.15.</span> <span class="toc-text">15.怎么解决并发问题？MySQL的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-undo-log%E5%92%8Credo-log%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.</span> <span class="toc-text">16.undo log和redo log的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E8%A7%A3%E5%86%B3MVCC%EF%BC%8C%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-number">1.17.</span> <span class="toc-text">17.解决MVCC，怎么保证事务的隔离性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">1.18.</span> <span class="toc-text">18.主从同步原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">1.19.</span> <span class="toc-text">19.分库分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-MyIsAm%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.20.</span> <span class="toc-text">20.MyIsAm和InnoDB的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E4%BA%8B%E5%8A%A1%E9%9D%A0%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81"><span class="toc-number">1.21.</span> <span class="toc-text">21.事务靠什么保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">1.22.</span> <span class="toc-text">22.什么是快照读和当前读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B4%A2%E5%BC%95"><span class="toc-number">1.23.</span> <span class="toc-text">23.MySQL有哪些索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%86%85%E8%BF%9E%E6%8E%A5%E8%80%8C%E4%B8%8D%E7%94%A8%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.24.</span> <span class="toc-text">24.为什么要用内连接而不用外连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-MySQL%E6%95%B4%E4%B8%AA%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.25.</span> <span class="toc-text">25.MySQL整个查询的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81"><span class="toc-number">1.26.</span> <span class="toc-text">26.MySQL有哪些锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-Mysql%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.27.</span> <span class="toc-text">27.Mysql内连接、左连接、右连接的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-where%E5%92%8Chaving%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.28.</span> <span class="toc-text">28.where和having的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">1.29.</span> <span class="toc-text">29.三大范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-char%E5%92%8Cvarchar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.30.</span> <span class="toc-text">30.char和varchar的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-MySQL-%E5%88%A0%E9%99%A4%E8%87%AA%E5%A2%9E-id%EF%BC%8C%E9%9A%8F%E5%90%8E%E9%87%8D%E5%90%AF-MySQL-%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%86%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%87%AA%E5%A2%9E-id-%E4%BC%9A%E4%BB%8E%E5%87%A0%E5%BC%80%E5%A7%8B"><span class="toc-number">1.31.</span> <span class="toc-text">31.MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Spring%E6%A1%86%E6%9E%B6"><span class="toc-number">2.</span> <span class="toc-text">二、Spring框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E5%8D%95%E4%BE%8Bbean%E6%97%B6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="toc-number">2.1.</span> <span class="toc-text">1.Spring框架中的单例bean时线程安全的吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFAOP"><span class="toc-number">2.2.</span> <span class="toc-text">2.什么是AOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">3.Spring中的事务怎么实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Spring%E4%B8%AD%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">2.4.</span> <span class="toc-text">4.Spring中事务失效的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Spring%E4%B8%ADbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.5.</span> <span class="toc-text">5.Spring中bean的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%87%BA%E7%8E%B0%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">2.6.</span> <span class="toc-text">6.构造方法出现循环依赖怎么解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">7.SpringMVC的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Spring%E6%A1%86%E6%9E%B6%E7%9A%84%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.8.</span> <span class="toc-text">8.Spring框架的常见注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">2.9.</span> <span class="toc-text">9.Springboot的自动装配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81MyBatis"><span class="toc-number">3.</span> <span class="toc-text">三、MyBatis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MyBatis%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">1.MyBatis的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Mybatis%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.2.</span> <span class="toc-text">2.Mybatis是否支持延迟加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">3.延迟加载的底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">3.4.</span> <span class="toc-text">4.Mybatis的一级、二级缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Mybatis%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E6%B8%85%E7%90%86%E7%BC%93%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">3.5.</span> <span class="toc-text">5.Mybatis的二级缓存什么时候会清理缓存中的数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Java%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">四、Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">1.接口和抽象类的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.2.</span> <span class="toc-text">2.重载和重写的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.3.</span> <span class="toc-text">3.&#x3D;&#x3D;和equals的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">4.4.</span> <span class="toc-text">4.异常处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text">5.HashMap的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84hashmap"><span class="toc-number">4.6.</span> <span class="toc-text">6.怎么使用线程安全的hashmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-ConCurrentHashMap%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.7.</span> <span class="toc-text">7.ConCurrentHashMap怎么保证线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-HashMap%E5%92%8CHashTable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.8.</span> <span class="toc-text">8.HashMap和HashTable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB"><span class="toc-number">4.9.</span> <span class="toc-text">9.ArrayList和LinkedList区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81ArrayList%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.10.</span> <span class="toc-text">10.怎么保证ArrayList的线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-String%E3%80%81StringBuilder%E3%80%81StringBuffer%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.11.</span> <span class="toc-text">11.String、StringBuilder、StringBuffer的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-hashcode%E5%92%8Cequals"><span class="toc-number">4.12.</span> <span class="toc-text">12.hashcode和equals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.13.</span> <span class="toc-text">13.面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.14.</span> <span class="toc-text">14.深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.15.</span> <span class="toc-text">15.多态的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84"><span class="toc-number">4.16.</span> <span class="toc-text">16.什么是反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">4.17.</span> <span class="toc-text">17.创建对象的五种方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Java%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">五、Java多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">5.1.</span> <span class="toc-text">1.进程和线程的区别，进程间如何通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">5.2.</span> <span class="toc-text">2.什么是线程上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="toc-number">5.3.</span> <span class="toc-text">3.什么是死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.4.</span> <span class="toc-text">4.死锁的必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-synchronized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.5.</span> <span class="toc-text">5.synchronized和lock的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AFAQS%E9%94%81"><span class="toc-number">5.6.</span> <span class="toc-text">6.什么是AQS锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88AQS%E4%BD%BF%E7%94%A8%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">5.7.</span> <span class="toc-text">7.为什么AQS使用双向链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84AQS%E9%94%81"><span class="toc-number">5.8.</span> <span class="toc-text">8.有哪些常见的AQS锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-sleep%E5%92%8Cwait%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.9.</span> <span class="toc-text">9.sleep和wait的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-yield%E5%92%8Cjoin%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.10.</span> <span class="toc-text">10.yield和join的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">5.11.</span> <span class="toc-text">11.线程池的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-Java%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.12.</span> <span class="toc-text">12.Java的内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">5.13.</span> <span class="toc-text">13.保证并发安全的三大特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Volatile"><span class="toc-number">5.14.</span> <span class="toc-text">14.Volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">5.15.</span> <span class="toc-text">15.线程使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-ThreadLocal%E5%8E%9F%E7%90%86"><span class="toc-number">5.16.</span> <span class="toc-text">16.ThreadLocal原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%BB%80%E4%B9%88%E6%98%AFCAS%E9%94%81"><span class="toc-number">5.17.</span> <span class="toc-text">17.什么是CAS锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-synchronized%E9%94%81%E5%8E%9F%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-number">5.18.</span> <span class="toc-text">18.synchronized锁原理和优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AECPU%E6%A0%B8%E5%BF%83%E6%95%B0%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="toc-number">5.19.</span> <span class="toc-text">19.如何根据CPU核心数设计线程池线程数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-AtomicInteger%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.20.</span> <span class="toc-text">20.AtomicInteger的使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81JVM%E7%AF%87"><span class="toc-number">6.</span> <span class="toc-text">六、JVM篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">1.jvm运行时数据区（内存结构）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">6.2.</span> <span class="toc-text">2.什么情况下会内存溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JVM%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">3.JVM有哪些垃圾回收算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-GC%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="toc-number">6.4.</span> <span class="toc-text">4.GC如何判断对象可以被回收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B8%E5%9E%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">6.5.</span> <span class="toc-text">5.典型垃圾回收器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">6.6.</span> <span class="toc-text">6.类加载器和双亲委派机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-JVM%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8"><span class="toc-number">6.7.</span> <span class="toc-text">7.JVM中有哪些引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">6.8.</span> <span class="toc-text">8.类加载过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-JVM%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.9.</span> <span class="toc-text">9.JVM类初始化顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">6.10.</span> <span class="toc-text">10.对象的创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF"><span class="toc-number">6.11.</span> <span class="toc-text">11.对象头中有哪些信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-JVM%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0"><span class="toc-number">6.12.</span> <span class="toc-text">12.JVM内存参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-GC%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">6.13.</span> <span class="toc-text">13.GC的回收机制和原理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/23/%E5%85%AB%E8%82%A1%E6%96%87/" title="八股文"><img src="/./image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="八股文"/></a><div class="content"><a class="title" href="/2024/05/23/%E5%85%AB%E8%82%A1%E6%96%87/" title="八股文">八股文</a><time datetime="2024-05-23T08:31:21.526Z" title="发表于 2024-05-23 16:31:21">2024-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/16/%E5%85%AB%E8%82%A1%E6%96%87%E9%9D%A2%E8%AF%95%E9%A2%98/" title="八股文面试题"><img src="/./image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="八股文面试题"/></a><div class="content"><a class="title" href="/2024/05/16/%E5%85%AB%E8%82%A1%E6%96%87%E9%9D%A2%E8%AF%95%E9%A2%98/" title="八股文面试题">八股文面试题</a><time datetime="2024-05-16T04:20:57.179Z" title="发表于 2024-05-16 12:20:57">2024-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/15/Java%E5%9F%BA%E7%A1%80/" title="Java基础-笔记"><img src="/./image/HeadPic/%E5%8F%AF%E8%8E%89.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础-笔记"/></a><div class="content"><a class="title" href="/2024/04/15/Java%E5%9F%BA%E7%A1%80/" title="Java基础-笔记">Java基础-笔记</a><time datetime="2024-04-15T08:18:02.220Z" title="发表于 2024-04-15 16:18:02">2024-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/13/Spring5/" title="Spring5-笔记"><img src="/./image/HeadPic/%E4%B8%83%E4%B8%83.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring5-笔记"/></a><div class="content"><a class="title" href="/2024/04/13/Spring5/" title="Spring5-笔记">Spring5-笔记</a><time datetime="2024-04-13T15:46:00.287Z" title="发表于 2024-04-13 23:46:00">2024-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/10/MyBatis/" title="MyBatis-笔记"><img src="/./image/HeadPic/%E7%94%B3%E9%B9%A4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis-笔记"/></a><div class="content"><a class="title" href="/2024/04/10/MyBatis/" title="MyBatis-笔记">MyBatis-笔记</a><time datetime="2024-04-10T01:33:16.980Z" title="发表于 2024-04-10 09:33:16">2024-04-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Awei</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">常看，勤改</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>