<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>八股文 | Awei Blog</title><meta name="author" content="Awei"><meta name="copyright" content="Awei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="用于记录和巩固一些面试相关知识点，不定期添加或修改(记载自B站狂神说Java课程）">
<meta property="og:type" content="article">
<meta property="og:title" content="八股文">
<meta property="og:url" content="https://awei-7.github.io/2024/05/23/%E5%85%AB%E8%82%A1%E6%96%87/index.html">
<meta property="og:site_name" content="Awei Blog">
<meta property="og:description" content="用于记录和巩固一些面试相关知识点，不定期添加或修改(记载自B站狂神说Java课程）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://awei-7.github.io/image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg">
<meta property="article:published_time" content="2024-05-23T08:31:21.526Z">
<meta property="article:modified_time" content="2024-05-23T10:54:59.181Z">
<meta property="article:author" content="Awei">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://awei-7.github.io/image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg"><link rel="shortcut icon" href="/./image/HeadPic/w.jpg"><link rel="canonical" href="https://awei-7.github.io/2024/05/23/%E5%85%AB%E8%82%A1%E6%96%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '八股文',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-23 18:54:59'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./image/HeadPic/w.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/./image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Awei Blog"><span class="site-name">Awei Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">八股文</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-23T08:31:21.526Z" title="发表于 2024-05-23 16:31:21">2024-05-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-23T10:54:59.181Z" title="更新于 2024-05-23 18:54:59">2024-05-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="八股文"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、java基础篇"><a href="#一、java基础篇" class="headerlink" title="一、java基础篇"></a>一、java基础篇</h1><h2 id="1-接口和抽象类的区别"><a href="#1-接口和抽象类的区别" class="headerlink" title="1.  接口和抽象类的区别"></a>1.  接口和抽象类的区别</h2><p>相似点：</p>
<p>（1）接口和抽象类都不能被实例化</p>
<p>（2）实现接口或继承抽象类的普通子类都必须实现这些抽象方法</p>
<p>不同点：</p>
<p>（1）抽象类可以包含普通方法和代码块，接口里只能包含抽象方法，静态方法和默认方法，</p>
<p>（2）抽象类可以有构造方法，而接口没有</p>
<p>（3）抽象类中的成员变量可以是各种类型的，接口的成员变量只能是 public static final 类型的，并且必须赋值</p>
<h2 id="2-重载和重写的区别"><a href="#2-重载和重写的区别" class="headerlink" title="2.  重载和重写的区别"></a>2.  重载和重写的区别</h2><p>重载发生在同一个类中，方法名相同、参数列表、返回类型、权限修饰符可以不同</p>
<p>重写发生在子类中，方法名相、参数列表、返回类型都相同，权限修饰符要大于父类方法，声明异常范围要小于父类方法，但是final和private修饰的方法不可重写</p>
<h2 id="3-equals和-的区别"><a href="#3-equals和-的区别" class="headerlink" title="3.  equals和&#x3D;&#x3D;的区别"></a>3.  equals和&#x3D;&#x3D;的区别</h2><p>&#x3D;&#x3D;比较基本类型，比较的是值，&#x3D;&#x3D;比较引用类型，比较的是内存地址</p>
<p>equlas是Object类的方法，本质上与&#x3D;&#x3D;一样，但是有些类重写了equals方法，比如String的equals被重写后，比较的是字符值，另外重写了equlas后，也必须重写hashcode()方法</p>
<h2 id="4-异常处理机制"><a href="#4-异常处理机制" class="headerlink" title="4.  异常处理机制"></a>4.  异常处理机制</h2><p>（1）使用try、catch、finaly捕获异常，finaly中的代码一定会执行，捕获异常后程序会继续执行</p>
<p>（2）使用throws声明该方法可能会抛出的异常类型，出现异常后，程序终止</p>
<h2 id="5-HashMap原理"><a href="#5-HashMap原理" class="headerlink" title="5.  HashMap原理"></a>5.  HashMap原理</h2><p>(1).HashMap在Jdk1.8以后是基于数组+链表+红黑树来实现的，特点是，key不能重复，可以为null，线程不安全</p>
<p>(2).HashMap的扩容机制：</p>
<p>HashMap的默认容量为16，默认的负载因子为0.75，当HashMap中元素个数超过容量乘以负载因子的个数时，就创建一个大小为前一次两倍的新数组，再将原来数组中的数据复制到新数组中。当数组长度到达64且链表长度大于8时，链表转为红黑树</p>
<p>(3).HashMap存取原理：</p>
<p>1）计算key的hash值，然后进行二次hash，根据二次hash结果找到对应的索引位置</p>
<p>2）如果这个位置有值，先进性equals比较，若结果为true则取代该元素，若结果为false，就使用高低位平移法将节点插入链表（JDK8以前使用头插法，但是头插法在并发扩容时可能会造成环形链表或数据丢失，而高低位平移发会发生数据覆盖的情况）</p>
<h2 id="6-想要线程安全的HashMap怎么办？"><a href="#6-想要线程安全的HashMap怎么办？" class="headerlink" title="6.  想要线程安全的HashMap怎么办？"></a>6.  想要线程安全的HashMap怎么办？</h2><p>（1）使用ConcurrentHashMap</p>
<p>（2）使用HashTable</p>
<p>（3）Collections.synchronizedHashMap()方法</p>
<h2 id="7-ConcurrentHashMap原如何保证的线程安全？"><a href="#7-ConcurrentHashMap原如何保证的线程安全？" class="headerlink" title="7.  ConcurrentHashMap原如何保证的线程安全？"></a>7.  ConcurrentHashMap原如何保证的线程安全？</h2><p>JDK1.7:使用分段锁，将一个Map分为了16个段，每个段都是一个小的hashmap，每次操作只对其中一个段加锁</p>
<p>JDK1.8:采用CAS+Synchronized保证线程安全，每次插入数据时判断在当前数组下标是否是第一次插入，是就通过CAS方式插入，然后判断f.hash是否&#x3D;-1，是的话就说明其他线程正在进行扩容，当前线程也会参与扩容；删除方法用了synchronized修饰，保证并发下移除元素安全</p>
<h2 id="8-HashTable与HashMap的区别"><a href="#8-HashTable与HashMap的区别" class="headerlink" title="8.  HashTable与HashMap的区别"></a>8.  HashTable与HashMap的区别</h2><p>（1）HashTable的每个方法都用synchronized修饰，因此是线程安全的，但同时读写效率很低</p>
<p>（2）HashTable的Key不允许为null</p>
<p>（3）HashTable只对key进行一次hash，HashMap进行了两次Hash</p>
<p>（4）HashTable底层使用的数组加链表</p>
<h2 id="9-ArrayList和LinkedList的区别"><a href="#9-ArrayList和LinkedList的区别" class="headerlink" title="9.  ArrayList和LinkedList的区别"></a>9.  ArrayList和LinkedList的区别</h2><p> ArratList的底层使用动态数组，默认容量为10，当元素数量到达容量时，生成一个新的数组，大小为前一次的1.5倍，然后将原来的数组copy过来；因为数组在内存中是连续的地址，所以ArrayList查找数据更快，由于扩容机制添加数据效率更低</p>
<p>LinkedList的底层使用链表，在内存中是离散的，没有扩容机制；LinkedList在查找数据时需要从头遍历，所以查找慢，但是添加数据效率更高</p>
<h2 id="10-如何保证ArrayList的线程安全？"><a href="#10-如何保证ArrayList的线程安全？" class="headerlink" title="10. 如何保证ArrayList的线程安全？"></a>10. 如何保证ArrayList的线程安全？</h2><p>（1）使用collentions.synchronizedList（）方法为ArrayList加锁</p>
<p>（2）使用Vector，Vector底层与Arraylist相同，但是每个方法都由synchronized修饰，速度很慢</p>
<p>（3）使用juc下的CopyOnWriterArrayList，该类实现了读操作不加锁，写操作时为list创建一个副本，期间其它线程读取的都是原本list，写操作都在副本中进行，写入完成后，再将指针指向副本。</p>
<h2 id="11-String、StringBuffer、StringBuilder的区别"><a href="#11-String、StringBuffer、StringBuilder的区别" class="headerlink" title="11. String、StringBuffer、StringBuilder的区别"></a>11. String、StringBuffer、StringBuilder的区别</h2><p>String 由 char[] 数组构成，使用了 final 修饰，对 String 进行改变时每次都会新生成一个 String 对象，然后把指针指向新的引用对象。</p>
<p>StringBuffer可变并且线程安全</p>
<p>StringBuiler可变但线程不安全。</p>
<p>操作少量字符数据用 String；单线程操作大量数据用 StringBuilder；多线程操作大量数据用 StringBuffer。</p>
<h2 id="12-hashCode和equals"><a href="#12-hashCode和equals" class="headerlink" title="12. hashCode和equals"></a>12. hashCode和equals</h2><p> hashCode()和equals()都是Obkect类的方法，hashCode()默认是通过地址来计算hash码，但是可能被重写过用内容来计算hash码，equals()默认通过地址判断两个对象是否相等，但是可能被重写用内容来比较两个对象</p>
<p>所以两个对象相等，他们的hashCode和equals一定相等，但是hashCode相等的两个对象未必相等</p>
<p>如果重写equals()必须重写hashCode()，比如在HashMap中，key如果是String类型，String如果只重写了equals（）而没有重写hashcode（）的话，则两个equals()比较为true的key，因为hashcode不同导致两个key没有出现在一个索引上，就会出现map中存在两个相同的key</p>
<h2 id="13-面向对象和面向过程的区别"><a href="#13-面向对象和面向过程的区别" class="headerlink" title="13. 面向对象和面向过程的区别"></a>13. 面向对象和面向过程的区别</h2><p>面向对象有封装、继承、多态性的特性，所以相比面向过程易维护、易复用、易扩展，但是因为类调用时要实例化，所以开销大性能比面向过程低</p>
<h2 id="14-深拷贝和浅拷贝"><a href="#14-深拷贝和浅拷贝" class="headerlink" title="14.深拷贝和浅拷贝"></a>14.深拷贝和浅拷贝</h2><p>浅拷贝:浅拷贝只复制某个对象的引用，而不复制对象本身，新旧对象还是共享同一块内存</p>
<p>深拷贝:深拷贝会创造一个一摸一样的对象，新对象和原对象不共享内存，修改新对象不会改变原对对象。</p>
<h2 id="14-多态的作用"><a href="#14-多态的作用" class="headerlink" title="14. 多态的作用"></a>14. 多态的作用</h2><p>多态的实现要有继承、重写，父类引用指向子类对象。它的好处是可以消除类型之间的耦合关系，增加类的可扩充性和灵活性。</p>
<h2 id="15-什么是反射？"><a href="#15-什么是反射？" class="headerlink" title="15. 什么是反射？"></a>15. 什么是反射？</h2><p>反射是通过获取类的class对象，然后动态的获取到这个类的内部结构，动态的去操作类的属性和方法。</p>
<p>应用场景有：要操作权限不够的类属性和方法时、实现自定义注解时、动态加载第三方jar包时、按需加载类，节省编译和初始化时间；</p>
<p>获取class对象的方法有：class.forName(类路径)，类.class()，对象的getClass（）</p>
<h2 id="16-Java创建对象得五种方式"><a href="#16-Java创建对象得五种方式" class="headerlink" title="16. Java创建对象得五种方式?"></a>16. Java创建对象得五种方式?</h2><p>(1)new关键字  (2)Class.newInstance (3)Constructor.newInstance</p>
<p>(4)Clone方法  (5)反序列化</p>
<h1 id="二-Java多线程篇"><a href="#二-Java多线程篇" class="headerlink" title="二.Java多线程篇"></a>二.Java多线程篇</h1><h2 id="1-进程和线程的区别，进程间如何通信"><a href="#1-进程和线程的区别，进程间如何通信" class="headerlink" title="1.  进程和线程的区别，进程间如何通信"></a>1.  进程和线程的区别，进程间如何通信</h2><p>进程：系统运行的基本单位，进程在运行过程中都是相互独立，但是线程之间运行可以相互影响。</p>
<p>线程：独立运行的最小单位，一个进程包含多个线程且它们共享同一进程内的系统资源</p>
<p>进程间通过管道、 共享内存、信号量机制、消息队列通信</p>
<h2 id="2-什么是线程上下文切换"><a href="#2-什么是线程上下文切换" class="headerlink" title="2.  什么是线程上下文切换"></a>2.  什么是线程上下文切换</h2><p>当一个线程被剥夺cpu使用权时，切换到另外一个线程执行</p>
<h2 id="3-什么是死锁"><a href="#3-什么是死锁" class="headerlink" title="3.  什么是死锁"></a>3.  什么是死锁</h2><p>死锁指多个线程在执行过程中，因争夺资源造成的一种相互等待的僵局</p>
<h2 id="4-死锁的必要条件"><a href="#4-死锁的必要条件" class="headerlink" title="4.  死锁的必要条件"></a>4.  死锁的必要条件</h2><p>互斥条件：同一资源同时只能由一个线程读取</p>
<p>不可抢占条件：不能强行剥夺线程占有的资源</p>
<p>请求和保持条件：请求其他资源的同时对自己手中的资源保持不放</p>
<p>循环等待条件：在相互等待资源的过程中，形成一个闭环</p>
<p>想要预防死锁，只需要破坏其中一个条件即可，比如使用定时锁、尽量让线程用相同的加锁顺序，还可以用银行家算法可以预防死锁</p>
<h2 id="5-Synchrpnized和lock的区别"><a href="#5-Synchrpnized和lock的区别" class="headerlink" title="5.  Synchrpnized和lock的区别"></a>5.  Synchrpnized和lock的区别</h2><p>（1）synchronized是关键字，lock是一个类</p>
<p>（2） synchronized在发生异常时会自动释放锁，lock需要手动释放锁</p>
<p>（3）synchronized是可重入锁、非公平锁、不可中断锁，lock的ReentrantLock是可重入锁，可中断锁，可以是公平锁也可以是非公平锁</p>
<p>（4）synchronized是JVM层次通过监视器实现的，Lock是通过AQS实现的</p>
<h2 id="6-什么是AQS锁"><a href="#6-什么是AQS锁" class="headerlink" title="6.  什么是AQS锁?"></a>6.  什么是AQS锁?</h2><p>AQS是一个抽象类，可以用来构造锁和同步类，如ReentrantLock，Semaphore，CountDownLatch，CyclicBarrier。</p>
<p>AQS的原理是，AQS内部有三个核心组件，一个是state代表加锁状态初始值为0，一个是获取到锁的线程，还有一个阻塞队列。当有线程想获取锁时，会以CAS的形式将state变为1，CAS成功后便将加锁线程设为自己。当其他线程来竞争锁时会判断state是不是0，不是0再判断加锁线程是不是自己，不是的话就把自己放入阻塞队列。这个阻塞队列是用双向链表实现的</p>
<p>可重入锁的原理就是每次加锁时判断一下加锁线程是不是自己，是的话state+1，释放锁的时候就将state-1。当state减到0的时候就去唤醒阻塞队列的第一个线程。</p>
<h2 id="7-为什么AQS使用的双向链表？"><a href="#7-为什么AQS使用的双向链表？" class="headerlink" title="7.为什么AQS使用的双向链表？"></a>7.为什么AQS使用的双向链表？</h2><p>因为有一些线程可能发生中断 ，而发生中断时候就需要在同步阻塞队列中删除掉，这个时候用双向链表方便删除掉中间的节点</p>
<h2 id="7-有哪些常见的AQS锁"><a href="#7-有哪些常见的AQS锁" class="headerlink" title="7.  有哪些常见的AQS锁"></a>7.  有哪些常见的AQS锁</h2><p>AQS分为独占锁和共享锁</p>
<p>ReentrantLock（独占锁）：可重入，可中断，可以是公平锁也可以是非公平锁，非公平锁就是会通过两次CAS去抢占锁，公平锁会按队列顺序排队</p>
<p>Semaphore（信号量）:设定一个信号量，当调用acquire()时判断是否还有信号，有就获取一个信号量，没有就阻塞等待其他线程释放信号量，当调用release()时释放一个信号量，唤醒阻塞线程。</p>
<p>应用场景：允许多个线程访问某个临界资源时，如上下车，买卖票</p>
<p>CountDownLatch（倒计数器）:给计数器设置一个初始值，当调用CountDown()时计数器减一，当调用await() 时判断计数器是否归0，不为0就阻塞，直到计数器为0。</p>
<p>应用场景：启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行</p>
<p>CyclicBarrier（循环栅栏）:给计数器设置一个目标值,当调用await() 时会计数+1并判断计数器是否达到目标值，未达到就阻塞，直到计数器达到目标值</p>
<p>应用场景：多线程计算数据，最后合并计算结果的应用场景</p>
<h2 id="9-sleep-和wait-的区别"><a href="#9-sleep-和wait-的区别" class="headerlink" title="9.sleep()和wait()的区别"></a>9.sleep()和wait()的区别</h2><p> (1)wait()是Object的方法，sleep()是Thread类的方法</p>
<p>(2)wait()会释放锁，sleep()不会释放锁</p>
<p>(3)wait()要在同步方法或者同步代码块中执行，sleep()没有限制</p>
<p>(4)wait()要调用notify()或notifyall()唤醒,sleep()自动唤醒</p>
<h2 id="10-yield-和join-区别"><a href="#10-yield-和join-区别" class="headerlink" title="10. yield()和join()区别"></a>10. yield()和join()区别</h2><p>yield()调用后线程进入就绪状态</p>
<p>A线程中调用B线程的join() ,则B执行完前A进入阻塞状态</p>
<h2 id="11-线程池七大参数"><a href="#11-线程池七大参数" class="headerlink" title="11. 线程池七大参数"></a>11. 线程池七大参数</h2><p>核心线程数：线程池中的基本线程数量</p>
<p>最大线程数：当阻塞队列满了之后，逐一启动</p>
<p>最大线程的存活时间：当阻塞队列的任务执行完后，最大线长的回收时间</p>
<p>最大线程的存活时间单位</p>
<p>阻塞队列：当核心线程满后，后面来的任务都进入阻塞队列</p>
<p>线程工厂：用于生产线程</p>
<p>任务拒绝策略：阻塞队列满后，拒绝任务，有四种策略（1）抛异常（2）丢弃任务不抛异常（3）打回任务（4）尝试与最老的线程竞争</p>
<h2 id="12-Java内存模型"><a href="#12-Java内存模型" class="headerlink" title="12. Java内存模型"></a>12. Java内存模型</h2><p>JMM（Java内存模型 ）屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各平台下都能达到一致的内存访问效果，它定义了JVM如何将程序中的变量在主存中读取</p>
<p>具体定义为：所有变量都存在主存中，主存是线程共享区域；每个线程都有自己独有的工作内存，线程想要操作变量必须从主从中copy变量到自己的工作区，每个线程的工作内存是相互隔离的</p>
<p>由于主存与工作内存之间有读写延迟，且读写不是原子性操作，所以会有线程安全问题</p>
<h2 id="13-保证并发安全的三大特性？"><a href="#13-保证并发安全的三大特性？" class="headerlink" title="13. 保证并发安全的三大特性？"></a>13. 保证并发安全的三大特性？</h2><p> 原子性：一次或多次操作在执行期间不被其他线程影响</p>
<p>可见性：当一个线程在工作内存修改了变量，其他线程能立刻知道</p>
<p>有序性：JVM对指令的优化会让指令执行顺序改变，有序性是禁止指令重排</p>
<h2 id="14-Volatile"><a href="#14-Volatile" class="headerlink" title="14. Volatile"></a>14. Volatile</h2><p>保证变量的可见性和有序性，不保证原子性。使用了 volatile 修饰变量后，在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。</p>
<p>单例模式双重校验锁变量为什么使用 volatile 修饰？ 禁止 JVM 指令重排序，new Object()分为三个步骤：为实例对象分配内存，用构造器初始化成员变量，将实例对象引用指向分配的内存；实例对象在分配内存后实才不为null。如果分配内存后还未初始化就先将实例对象指向了内存，那么此时最外层的if会判断实例对象已经不等于null就直接将实例对象返回。而此时初始化还没有完成。</p>
<h2 id="15-线程使用方式"><a href="#15-线程使用方式" class="headerlink" title="15. 线程使用方式"></a>15. 线程使用方式</h2><p>(1)继承 Tread 类</p>
<p>(2)实现 Runnable 接口</p>
<p>(3)实现 Callable 接口：带有返回值</p>
<p>(4)线程池创建线程</p>
<h2 id="16-ThreadLocal原理"><a href="#16-ThreadLocal原理" class="headerlink" title="16. ThreadLocal原理"></a>16. ThreadLocal原理</h2><p>原理是为每个线程创建变量副本，不同线程之间不可见，保证线程安全。每个线程内部都维护了一个Map，key为threadLocal实例，value为要保存的副本。</p>
<p>但是使用ThreadLocal会存在内存泄露问题，因为key为弱引用，而value为强引用，每次gc时key都会回收，而value不会被回收。所以为了解决内存泄漏问题，可以在每次使用完后删除value或者使用static修饰ThreadLocal，可以随时获取value</p>
<h2 id="17-什么是CAS锁"><a href="#17-什么是CAS锁" class="headerlink" title="17. 什么是CAS锁"></a>17. 什么是CAS锁</h2><p>CAS锁可以保证原子性，思想是更新内存时会判断内存值是否被别人修改过，如果没有就直接更新。如果被修改，就重新获取值，直到更新完成为止。这样的缺点是</p>
<p>（1）只能支持一个变量的原子操作，不能保证整个代码块的原子操作</p>
<p>（2）CAS频繁失败导致CPU开销大</p>
<p>（3）ABS问题:线程1和线程2同时去修改一个变量，将值从A改为B，但线程1突然阻塞，此时线程2将A改为B,然后线程3又将B改成A,此时线程1将A又改为B,这个过程线程2是不知道的，这就是ABA问题，可以通过版本号或时间戳解决</p>
<h2 id="18-Synchronized锁原理和优化"><a href="#18-Synchronized锁原理和优化" class="headerlink" title="18. Synchronized锁原理和优化"></a>18. Synchronized锁原理和优化</h2><p>Synchronize是通过对象头的markwordk来表明监视器的，监视器本质是依赖操作系统的互斥锁实现的。操作系统实现线程切换要从用户态切换为核心态，成本很高，此时这种锁叫重量级锁，在JDK1.6以后引入了偏向锁、轻量级锁、重量级锁</p>
<p>偏向锁：当一段代码没有别的线程访问，此时线程去访问会直接获取偏向锁</p>
<p>轻量级锁：当锁是偏向锁时，有另外一个线程来访问，会升级为轻量级锁。线程会通过CAS方式获取锁，不会阻塞，提高性能，</p>
<p>重量级锁：轻量级锁自旋一段时间后线程还没有获取到锁，会升级为重量级锁，重量级锁时，来竞争锁的所有线程都会阻塞，性能降低</p>
<p>注意，锁只能升级不能降级</p>
<h2 id="19-如何根据-CPU-核心数设计线程池线程数量"><a href="#19-如何根据-CPU-核心数设计线程池线程数量" class="headerlink" title="19. 如何根据 CPU 核心数设计线程池线程数量"></a>19. 如何根据 CPU 核心数设计线程池线程数量</h2><p>IO 密集型：线程中十分消耗Io的线程数*2</p>
<p>CPU密集型： cpu线程数量</p>
<h2 id="20-AtomicInteger的使用场景"><a href="#20-AtomicInteger的使用场景" class="headerlink" title="20. AtomicInteger的使用场景"></a>20. AtomicInteger的使用场景</h2><p>AtomicInteger是一个提供原子操作的Integer类，使用CAS+volatile实来现线程安全的数值操作。</p>
<p>因为volatile禁止了jvm的排序优化,所以它不适合在并发量小的时候使用，只适合在一些高并发程序中使用</p>
<h1 id="三-JVM篇"><a href="#三-JVM篇" class="headerlink" title="三.JVM篇"></a>三.JVM篇</h1><h2 id="1-JVM运行时数据区（内存结构）"><a href="#1-JVM运行时数据区（内存结构）" class="headerlink" title="1.  JVM运行时数据区（内存结构）"></a>1.  JVM运行时数据区（内存结构）</h2><p>线程私有区：</p>
<p>（1）虚拟机栈：每次调用方法都会在虚拟机栈中产生一个栈帧，每个栈帧中都有方法的参数、局部变量、方法出口等信息，方法执行完毕后释放栈帧</p>
<p>（2）本地方法栈：为native修饰的本地方法提供的空间，在HotSpot中与虚拟机合二为一</p>
<p>（3）程序计数器：保存指令执行的地址，方便线程切回后能继续执行代码</p>
<p>线程共享区：</p>
<p>（4）堆内存：Jvm进行垃圾回收的主要区域，存放对象信息，分为新生代和老年代，内存比例为1：2，新生代的Eden区内存不够时时发生MinorGC,老年代内存不够时发生FullGC</p>
<p>（5）方法区：存放类信息、静态变量、常量、运行时常量池等信息。JDK1.8之前用持久代实现，JDK1.8后用元空间实现，元空间使用的是本地内存，而非在JVM内存结构中</p>
<h2 id="2-什么情况下会内存溢出？"><a href="#2-什么情况下会内存溢出？" class="headerlink" title="2.  什么情况下会内存溢出？"></a>2.  什么情况下会内存溢出？</h2><p>堆内存溢出：（1）当对象一直创建而不被回收时（2）加载的类越来越多时（3)虚拟机栈的线程越来越多时</p>
<p>栈溢出：方法调用次数过多，一般是递归不当造成</p>
<h2 id="3-JVM有哪些垃圾回收算法？"><a href="#3-JVM有哪些垃圾回收算法？" class="headerlink" title="3.  JVM有哪些垃圾回收算法？"></a>3.  JVM有哪些垃圾回收算法？</h2><p>（1）标记清除算法： 标记不需要回收的对象，然后清除没有标记的对象，会造成许多内存碎片。</p>
<p>（2）复制算法： 将内存分为两块，只使用一块，进行垃圾回收时，先将存活的对象复制到另一块区域，然后清空之前的区域。用在新生代</p>
<p>（3）标记整理算法： 与标记清除算法类似，但是在标记之后，将存活对象向一端移动，然后清除边界外的垃圾对象。用在老年代</p>
<h2 id="4-GC如何判断对象可以被回收？"><a href="#4-GC如何判断对象可以被回收？" class="headerlink" title="4.  GC如何判断对象可以被回收？"></a>4.  GC如何判断对象可以被回收？</h2><p>（1）引用计数法：已淘汰，为每个对象添加引用计数器，引用为0时判定可以回收，会有两个对象相互引用无法回收的问题</p>
<p>（2）可达性分析法：从GCRoot开始往下搜索，搜索过的路径称为引用链，若一个对象GCRoot没有任何的引用链，则判定可以回收</p>
<p> GCRoot有：虚拟机栈中引用的对象，方法区中静态变量引用的对象，本地方法栈中引用的对象</p>
<h2 id="5-典型垃圾回收器"><a href="#5-典型垃圾回收器" class="headerlink" title="5.  典型垃圾回收器"></a>5.  典型垃圾回收器</h2><p>CMS:以最小的停顿时间为目标、只运行在老年代的垃圾回收器，使用标记-清除算法，可以并发收集。</p>
<p>G1 ：JDK1.9以后的默认垃圾回收器，注重响应速度，支持并发，采用标记整理+复制算法回收内存，使用可达性分析法来判断对象是否可以被回收。</p>
<h2 id="6-类加载器和双亲委派机制"><a href="#6-类加载器和双亲委派机制" class="headerlink" title="6.  类加载器和双亲委派机制"></a>6.  类加载器和双亲委派机制</h2><p>从父类加载器到子类加载器分别为：</p>
<p>BootStrapClassLoader  加载路径为：JAVA_HOME&#x2F;jre&#x2F;lib</p>
<p>ExtensionClassLoader  加载路径为：JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext</p>
<p>ApplicationClassLoader 加载路径为：classpath</p>
<p>还有一个自定义类加载器</p>
<p>当一个类加载器收到类加载请求时，会先把这个请求交给父类加载器处理，若父类加载器找不到该类，再由自己去寻找。该机制可以避免类被重复加载，还可以避免系统级别的类被篡改</p>
<h2 id="7-JVM中有哪些引用？"><a href="#7-JVM中有哪些引用？" class="headerlink" title="7.  JVM中有哪些引用？"></a>7.  JVM中有哪些引用？</h2><p>强引用：new的对象。哪怕内存溢出也不会回收</p>
<p>软引用：只有内存不足时才会回收</p>
<p>弱引用：每次垃圾回收都会回收</p>
<p>虚引用：必须配合引用队列使用，一般用于追踪垃圾回收动作</p>
<h2 id="8-类加载过程"><a href="#8-类加载过程" class="headerlink" title="8.  类加载过程"></a>8.  类加载过程</h2><p>（1）加载 ：把字节码通过二进制的方式转化到方法区中的运行数据区</p>
<p>（2）连接：</p>
<p> 验证：验证字节码文件的正确性。</p>
<p> 准备：正式为类变量在方法区中分配内存，并设置初始值，final类型的变量在编译时已经赋值了</p>
<p> 解析：将常量池中的符号引用（如类的全限定名）解析为直接引用（类在实际内存中的地址） </p>
<p>（3）初始化 ：执行类构造器（不是常规的构造方法），为静态变量赋初值并初始化静态代码块。</p>
<h2 id="9-JVM类初始化顺序"><a href="#9-JVM类初始化顺序" class="headerlink" title="9.  JVM类初始化顺序"></a>9.  JVM类初始化顺序</h2><p>父类静态代码块和静态成员变量-&gt;子类静态代码块和静态成员变量-&gt;父类代码块和普通成员变量-&gt;父类构造方法-&gt;子类代码块和普成员变量-&gt;子类构造方法</p>
<h2 id="10-对象的创建过程"><a href="#10-对象的创建过程" class="headerlink" title="10. 对象的创建过程"></a>10. 对象的创建过程</h2><p>（1）检查类是否已被加载，没有加载就先加载类</p>
<p>（2）为对象在堆中分配内存，使用CAS方式分配，防止在为A分配内存时，执行当前地址的指针还没有来得及修改，对象B就拿来分配内存。</p>
<p>（3）初始化，将对象中的属性都分配0值或null</p>
<p>（4）设置对象头</p>
<p>（5）为属性赋值和执行构造方法</p>
<h2 id="11-对象头中有哪些信息"><a href="#11-对象头中有哪些信息" class="headerlink" title="11. 对象头中有哪些信息"></a>11. 对象头中有哪些信息</h2><p>对象头中有两部分，一部分是MarkWork,存储对象运行时的数据，如对象的hashcode、GC分代年龄、GC标记、锁的状态、获取到锁的线程ID等；另外一部分是表明对象所属类，如果是数组，还有一个部分存放数组长度</p>
<h2 id="12-JVM内存参数"><a href="#12-JVM内存参数" class="headerlink" title="12. JVM内存参数"></a>12. JVM内存参数</h2><p>-Xmx[]:堆空间最大内存</p>
<p>-Xms[]:堆空间最小内存，一般设置成跟堆空间最大内存一样的</p>
<p>-Xmn[]:新生代的最大内存</p>
<p>-xx:[survivorRatio&#x3D;3]:eden区与from+to区的比例为3：1，默认为4：1</p>
<p>-xx[use 垃圾回收器名称]：指定垃圾回收器</p>
<p>-xss:设置单个线程栈大小</p>
<p>一般设堆空间为最大可用物理地址的百分之80</p>
<h2 id="13-GC的回收机制和原理"><a href="#13-GC的回收机制和原理" class="headerlink" title="13. GC的回收机制和原理"></a>13. GC的回收机制和原理</h2><p>GC的目的实现内存的自动释放，使用可达性分析法判断对象是否可回收，采用了分代回收思想，</p>
<p>将堆分为新生代、老年代，新生代中采用复制算法，老年代采用整理算法，当新生代内存不足时会发生minorGC,老年代不足时会发送fullGC</p>
<h1 id="四-Mysql篇"><a href="#四-Mysql篇" class="headerlink" title="四.Mysql篇"></a>四.Mysql篇</h1><h2 id="1-MyIsAm和InnoDB的区别"><a href="#1-MyIsAm和InnoDB的区别" class="headerlink" title="1.  MyIsAm和InnoDB的区别"></a>1.  MyIsAm和InnoDB的区别</h2><p>InnoDB有三大特性，分别是事务、外键、行级锁，这些都是MyIsAm不支持的，</p>
<p>另外InnoDB是聚簇索引，MyIAm是非聚簇索引，</p>
<p>InnoDB不支持全文索引，MyIAm支持</p>
<p>InnoDB支持自增和MVCC模式的读写，MyIAm不支持</p>
<p>MyIsAM的访问速度一般InnoDB快，差异在于innodb的mvcc、行锁会比较消耗性能，还可能有回表的过程（先去辅助索引中查询数据，找到数据对应的key之后，再通过key回表到聚簇索引树查找数据）</p>
<h2 id="2-mysql事务特性"><a href="#2-mysql事务特性" class="headerlink" title="2.  mysql事务特性"></a>2.  mysql事务特性</h2><p>原子性：一个事务内的操作统一成功或失败</p>
<p>一致性：事务前后的数据总量不变</p>
<p>隔离性：事务与事务之间相互不影响</p>
<p>持久性：事务一旦提交发生的改变不可逆</p>
<h2 id="3-事务靠什么保证"><a href="#3-事务靠什么保证" class="headerlink" title="3.  事务靠什么保证"></a>3.  事务靠什么保证</h2><p>原子性：由undolog日志保证，他记录了需要回滚的日志信息，回滚时撤销已执行的sql</p>
<p>一致性：由其他三大特性共同保证，是事务的目的</p>
<p>隔离性：由MVCC保证</p>
<p>持久性：由redolog日志和内存保证，mysql修改数据时内存和redolog会记录操作，宕机时可恢复</p>
<h2 id="4-事务的隔离级别"><a href="#4-事务的隔离级别" class="headerlink" title="4.  事务的隔离级别"></a>4.  事务的隔离级别</h2><p>在高并发情况下，并发事务会产生脏读、不可重复读、幻读问题，这时需要用隔离级别来控制</p>
<p>读未提交： 允许一个事务读取另一个事务已提交的数据，可能出现不可重复读，幻读。</p>
<p>读提交：  只允许事务读取另一个事务没有提交的数据可能出现不可重复读，幻读。</p>
<p>可重复读： 确保同一字段多次读取结果一致，可能出现欢幻读。</p>
<p>可串行化： 所有事务逐次执行，没有并发问日</p>
<p>Inno DB 默认隔离级别为可重复读级别，分为快照度和当前读，并且通过间隙锁解决了幻读问题。</p>
<h2 id="5-什么是快照读和当前读"><a href="#5-什么是快照读和当前读" class="headerlink" title="5.  什么是快照读和当前读"></a>5.  什么是快照读和当前读</h2><p>*快照读读取的是当前数据的可见版本，可能是会过期数据，不加锁的select就是快照都</p>
<p>*当前读读取的是数据的最新版本，并且当前读返回的记录都会上锁，保证其他事务不会并发修改这条记录。如update、insert、delete、select for undate（排他锁）、select lockin share mode（共享锁） 都是当前读</p>
<h2 id="6-MVCC是什么"><a href="#6-MVCC是什么" class="headerlink" title="6.  MVCC是什么"></a>6.  MVCC是什么</h2><p>MVCC是多版本并发控制，为每次事务生成一个新版本数据，每个事务都由自己的版本，从而不加锁就决绝读写冲突，这种读叫做快照读。只在读已提交和可重复读中生效。</p>
<p>实现原理由四个东西保证，他们是</p>
<p>undolog日志：记录了数据历史版本</p>
<p>readView:事务进行快照读时动态生成产生的视图，记录了当前系统中活跃的事务id，控制哪个历史版本对当前事务可见</p>
<p>隐藏字段DB_TRC_ID： 最近修改记录的事务ID </p>
<p>隐藏字段DB_Roll_PTR： 回滚指针，配合undolog指向数据的上一个版本</p>
<h2 id="7-MySQL有哪些索引"><a href="#7-MySQL有哪些索引" class="headerlink" title="7.  MySQL有哪些索引"></a>7.  MySQL有哪些索引</h2><p>主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值</p>
<p>唯一索引：唯一索引不能有相同值，但允许为空</p>
<p>普通索引：允许出现重复值</p>
<p>组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则</p>
<p>全文索引：myisam引擎支持，通过建立倒排索引提升检索效率，广泛用于搜索引擎</p>
<h2 id="8-聚簇索引和非聚簇索引的区别"><a href="#8-聚簇索引和非聚簇索引的区别" class="headerlink" title="8.  聚簇索引和非聚簇索引的区别"></a>8.  聚簇索引和非聚簇索引的区别</h2><p>聚簇索引：聚簇索引的叶子节点存放的是主键值和数据行；辅助索引（在聚簇索引上创建的其它索引）的叶子节点存放的是主键值或指向数据行的指针。</p>
<p>优点：根据索引可以直接获取值，所以他获取数据更快；对于主键的排序查找和范围查找效率更高；</p>
<p>缺点：如果主键值很大的话，辅助索引也会变得很大；如果用uuid作为主键，数据存储会很稀疏；修改主键或乱序插入会让数据行移动导致页分裂；所以一般我们定义主键时尽量让主键值小，并且定义为自增和不可修改。</p>
<p>非聚簇索引（辅助索引）：叶子节点存放的是数据行地址，先根据索引找到数据地址，再根据地址去找数据</p>
<p>他们都是b+数结构</p>
<h2 id="9-MySQL如何做慢SQL优化"><a href="#9-MySQL如何做慢SQL优化" class="headerlink" title="9.  MySQL如何做慢SQL优化"></a>9.  MySQL如何做慢SQL优化</h2><p>可以查看执行计划分析数据的扫描类型、索引是否生效，常见的慢查询优化有：</p>
<p>（1）尽量减少select的数据列，尽量使用覆盖索引</p>
<p>（2）orderby查找时使用索引进行排序，否则的话需要进行回表</p>
<p>（3）groupby查询时，同样要用索引，避免使用到临时表</p>
<p>（4）分页查询时，如果limit 后面的数字太大，可以使用子查询查出主键，再limit主键后n条数据就能走覆盖索引</p>
<p>（5） 使用复杂查询时，使用关联查询来代替子查询，并且最好使用内连接</p>
<p>（6）使用count函数时直接使用count的话count(*)的效率最高</p>
<p>count(*)或count(唯一索引)或count(数字):表中总记录数，count(字段)不会统计null</p>
<p> (7) 在写update语句时，where条件要使用索引，否则会锁会从行锁升级为表锁</p>
<p>（8）表中数据是否太大，是不是要分库分表</p>
<h2 id="10-为什么要用内连接而不用外连接？"><a href="#10-为什么要用内连接而不用外连接？" class="headerlink" title="10. 为什么要用内连接而不用外连接？"></a>10. 为什么要用内连接而不用外连接？</h2><p>用外连接的话连接顺序是固定死的，比如left join，他必须先对左表进行全表扫描，然后一条条到右表去匹配；而内连接的话mysql会自己根据查询优化器去判断用哪个表做驱动。</p>
<p>子查询的话同样也会对驱动表进行全表扫描，所以尽量用小表做驱动表。</p>
<h2 id="11-MySQL整个查询的过程"><a href="#11-MySQL整个查询的过程" class="headerlink" title="11. MySQL整个查询的过程"></a>11. MySQL整个查询的过程</h2><p>（1）客户端向 MySQL 服务器发送一条查询请求</p>
<p>（2）服务器首先检查查询缓存，如果命中缓存，则返回存储在缓存中的结果。否则进入下一阶段</p>
<p>（3）服务器进行 SQL 解析、预处理、再由优化器生成对应的执行计划</p>
<p>（4）MySQL 根据执行计划，调用存储引擎的 API 来执行查询</p>
<p>（5）将结果返回给客户端，同时缓存查询结果</p>
<p>注意：只有在8.0之前才有查询缓存，8.0之后查询缓存被去掉了</p>
<h2 id="12-执行计划中有哪些字段？"><a href="#12-执行计划中有哪些字段？" class="headerlink" title="12. 执行计划中有哪些字段？"></a>12. 执行计划中有哪些字段？</h2><p>我们想看一个sql的执行计划使用的语句是explain+SQL，表中的字段包括：</p>
<p>type:扫描类型，效率从底到高为ALL（全表扫描)&gt;index(全索引扫描，我们的需要的数据在索引中可以获取)&gt;range(使用索引进行范围查找)&gt;ref(使用非唯一索引列进行了关联查询)&gt; eq_ref (使用唯一索引进行关联查询)&gt;const(使用唯一索引查询一行数据)&gt;system(表中只有一行数据)</p>
<p> extra（额外的）:mysql如何查询额外信息，常见的有：</p>
<p>filesort:在排序缓冲区中进行排序，需要回表查询数据</p>
<p>index:表示使用覆盖索引</p>
<p>index scan:排序时使用了索引排序，但如果是按照降序排序的话就会使用反向扫描索引</p>
<p>temporary:查询时要建立一个临时表存放数据</p>
<p>rows:找到了多少行数据</p>
<p>key:实际使用到的索引</p>
<p>id:select查询的优先级，id越大优先级越高，子查询的id一般会更大</p>
<p>select_type:查询的类型,是普通查询还是联合查询还是子查询，常见类型有simple（不包含子查询），primary（标记复杂查询中最外层的查询），union(标记primart只后子查询)</p>
<p>table：者一行的数据是数哪张表的</p>
<p>possible_keys（可能的）:当前查询语句可能用到的索引，可能为null(如果用了索引但是为null有可能是表数据太少innodb认为全表扫描更快)</p>
<p>ref（编号）:显示索引的哪一行被使用了</p>
<h2 id="13-哪些情况索引会失效"><a href="#13-哪些情况索引会失效" class="headerlink" title="13. 哪些情况索引会失效"></a>13. 哪些情况索引会失效</h2><p>（1）where条件中有or，除非所有查询条件都有索引，否则失效</p>
<p>（2）like查询用%开头，索引失效</p>
<p>（3）索引列参与计算，索引失效</p>
<p>（4）违背最左匹配原则，索引失效</p>
<p>（5）索引字段发生类型转换，索引失效</p>
<p>（6）mysql觉得全表扫描更快时（数据少），索引失效</p>
<h2 id="14-B和B-数的区别，为什么使用B-数"><a href="#14-B和B-数的区别，为什么使用B-数" class="headerlink" title="14. B和B+数的区别，为什么使用B+数"></a>14. B和B+数的区别，为什么使用B+数</h2><p>二叉树：索引字段有序，极端情况会变成链表形式</p>
<p>AVL数：树的高度不可控</p>
<p>B数：控制了树的高度，但是索引值和data都分布在每个具体的节点当中，若要进行范围查询，要进行多次回溯，IO开销大</p>
<p>B+树：非叶子节点只存储索引值，叶子节点再存储索引+具体数据，从小到大用链表连接在一起，范围查询可直接遍历不需要回溯7</p>
<h2 id="15-MySQL有哪些锁"><a href="#15-MySQL有哪些锁" class="headerlink" title="15. MySQL有哪些锁"></a>15. MySQL有哪些锁</h2><p>基于粒度：</p>
<p> *表级锁：对整张表加锁，粒度大并发小</p>
<p> *行级锁：对行加锁，粒度小并发大</p>
<p> *间隙锁：间隙锁，锁住表的一个区间，间隙锁之间不会冲突只在可重复读下才生效，解决了幻读</p>
<p>基于属性：</p>
<p>  *共享锁：又称读锁，一个事务为表加了读锁，其它事务只能加读锁，不能加写锁</p>
<p>   *排他锁：又称写锁，一个事务加写锁之后，其他事务不能再加任何锁，避免脏读问题  </p>
<h2 id="16-Mysql内连接、左连接、右连接的区别"><a href="#16-Mysql内连接、左连接、右连接的区别" class="headerlink" title="16. Mysql内连接、左连接、右连接的区别"></a>16. Mysql内连接、左连接、右连接的区别</h2><p>内连接取量表交集部分，左连接取左表全部右表匹部分，右连接取右表全部坐表匹部分</p>
<h2 id="17-sql执行顺序"><a href="#17-sql执行顺序" class="headerlink" title="17. sql执行顺序"></a>17. sql执行顺序</h2><p>我单独写了一篇文章 <a target="_blank" rel="noopener" href="http://t.csdn.cn/6a5Y3">http://t.csdn.cn/6a5Y3</a></p>
<h2 id="18-如何设计数据库？"><a href="#18-如何设计数据库？" class="headerlink" title="18. 如何设计数据库？"></a>18. 如何设计数据库？</h2><p>（1）抽取实体，如用户信息，商品信息，评论</p>
<p>（2）分析其中属性，如用户信息：姓名、性别…</p>
<p>（3）分析表与表之间的关联关系</p>
<p>然后可以参考三大范式进行设计，设计主键时，主键要尽量小并且定义为自增和不可修改。</p>
<h2 id="19-where和having的区别？"><a href="#19-where和having的区别？" class="headerlink" title="19. where和having的区别？"></a>19. where和having的区别？</h2><p>where是约束声明，having是过滤声明，where早于having执行，并且where不可以使用聚合函数，having可以</p>
<h2 id="20-三大范式"><a href="#20-三大范式" class="headerlink" title="20. 三大范式"></a>20. 三大范式</h2><p>第一范式：每个列都不可以再拆分。</p>
<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<h2 id="21-char和varchar的区别"><a href="#21-char和varchar的区别" class="headerlink" title="21. char和varchar的区别"></a>21. char和varchar的区别</h2><p>char是不可变的，最大长度为255，varchar是可变的字符串，最大长度为2^16</p>
<h2 id="22-InnoDB-什么情况下会产生死锁"><a href="#22-InnoDB-什么情况下会产生死锁" class="headerlink" title="22. InnoDB 什么情况下会产生死锁"></a>22. InnoDB 什么情况下会产生死锁</h2><p>事务1已经获取数据A的写锁，想要去获取数据B的写锁，然后事务2获取了B的写锁，想要去获取A的写锁，相互等待形成死锁。</p>
<p>mysql解决死锁的机制有两个：1.等待， 直到超时 2.发起死锁检测，主动回滚一条事务</p>
<p>死锁检测的原理是构建一个以事务为顶点、 锁为边的有向图， 判断有向图是否存在环， 存在即有死锁。</p>
<p>我们平时尽量减少事务操作的资源和隔离级别</p>
<h2 id="23-MySQL-删除自增-id，随后重启-MySQL-服务，再插入数据，自增-id-会从几开始？"><a href="#23-MySQL-删除自增-id，随后重启-MySQL-服务，再插入数据，自增-id-会从几开始？" class="headerlink" title="23. MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始？"></a>23. MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始？</h2><p>innodb 引擎：</p>
<p>MySQL8.0前，下次自增会取表中最大 id + 1。原理是最大id会记录在内存中，重启之后会重新读取表中最大的id</p>
<p>MySQL8.0后，仍从删除数据 id 后算起。原理是它将最大id记录在redolog里了</p>
<p>myisam：</p>
<p>自增的 id 都从删除数据 id 后算起。原理是它将最大id记录到数据文件里了</p>
<h2 id="24-MySQL插入百万级的数据如何优化？"><a href="#24-MySQL插入百万级的数据如何优化？" class="headerlink" title="24. MySQL插入百万级的数据如何优化？"></a>24. MySQL插入百万级的数据如何优化？</h2><p>（1）一次sql插入多条数据，可以减少写redolog日志和binlog日志的io次数（sql是有长度限制的，但可以调整）</p>
<p>（2）保证数据按照索引进行有序插入</p>
<p>（3）可以分表后多线程插入</p>
<h1 id="五-常用开发框架系列"><a href="#五-常用开发框架系列" class="headerlink" title="五.常用开发框架系列"></a>五.常用开发框架系列</h1><h2 id="1-什么是Spring？"><a href="#1-什么是Spring？" class="headerlink" title="1.  什么是Spring？"></a>1.  什么是Spring？</h2><p>Spring是个轻量级的框架，通过IOC达到松耦合的目的，通过AOP可以分离应用业务逻辑和系统服务进行内聚性的开发，不过配置各种组件时比较繁琐，所以后面才出选了SpringBoot的框架。 </p>
<h2 id="2-IOC是什么？"><a href="#2-IOC是什么？" class="headerlink" title="2.  IOC是什么？"></a>2.  IOC是什么？</h2><p>IOC是控制反转，是一种思想，把对象的创建和调用从程序员手中交由IOC容器管理，降低对象之间的依赖关系。</p>
<p>创建一个bean的方式有xml方式、@Bean注解方式、@Componte方式</p>
<p>我们在对一个bean进行实例化后，要对他的属性进行填充，大多数我们都是使用 @Autowire直接的填充依赖注入的，他是有限按照类型进行匹配。</p>
<h2 id="3-AOP是什么？"><a href="#3-AOP是什么？" class="headerlink" title="3.  AOP是什么？"></a>3.  AOP是什么？</h2><p>AOP是面向切面编程，可以将那些与业务不相关但是很多业务都要调用的代码抽取出来，思想就是不侵入原有代码的情况下对功能进行增强。</p>
<p>SpringAOP是基于动态代理实现的，动态代理是有两种，一种是jdk动态代理，一种是cglib动态代理;</p>
<p>jdk动态代理是原理是利用反射来实现的，需要调用反射包下的Proxy类的newProxyInstance方法来返回代理对象，这个方法中有三个参数，分别是用于加载代理类的类加载器，被代理类实现的接口的class数组和一个用于增强方法的InvocaHandler实现类。</p>
<p>cglib动态代理原理是利用asm开源包来实现的，是把被代理类的class文件加载进来，通过修改它的字节码生成子类来处理</p>
<p>jdk动态代理要求被代理类必须有实现的接口，生成的动态代理类会和代理类实现同样的接口，cglib则，生成的动态代理类会继承被代理类。Spring默认使用jdk动态代理，当被代理的类没有接口时就使用cglib动态代理</p>
<h2 id="4-如何定义一个全局异常处理类？"><a href="#4-如何定义一个全局异常处理类？" class="headerlink" title="4.  如何定义一个全局异常处理类？"></a>4.  如何定义一个全局异常处理类？</h2><p>想要定义一个全局异常处理类的话，我们需要在这个类上添加@ContaollerAdvice注解，然后定义一些用于捕捉不同异常类型的方法，在这些方法上添加@ExceptionHandler(value &#x3D; 异常类型.class)和@ResponseBody注解，方法参数是HttpServletRequest和异常类型，然后将异常消息进行处理。</p>
<p>如果我们需要自定义异常的话，就写一个自定义异常类，该类需要继承一个异常接口，类属性包括final类型的连续id、错误码、错误信息，再根据需求写构造方法；</p>
<h2 id="5-如何使用aop自定义日志？"><a href="#5-如何使用aop自定义日志？" class="headerlink" title="5.  如何使用aop自定义日志？"></a>5.  如何使用aop自定义日志？</h2><p>第一步：创建一个切面类，把它添加到ioc容器中并添加@Aspect注解</p>
<p>第二步： 在切面类中写一个通知方法，在方法上添加通知注解并通过切入点表达式来表示要对哪些方法进行日志打印，然后方法参数为JoinPoint</p>
<p>第三步：通过JoinPoint这个参数可以获取当前执行的方法名、方法参数等信息，这样就可以根据需求在方法进入或结束时打印日志</p>
<h2 id="6-循环依赖是什么，怎么解决的？"><a href="#6-循环依赖是什么，怎么解决的？" class="headerlink" title="6.  循环依赖是什么，怎么解决的？"></a>6.  循环依赖是什么，怎么解决的？</h2><p>循环依赖就是在创建 A 实例的时候里面包含着 B 属性实例，所以这个时候就需要去创建 B 实例，而创 建 B 实例过程中也包含着 A 实例。 这样 A 实例还在创建的过程当中，所以就导致 A 和 B 实例都创建不出来。</p>
<p>spring通过三级缓存来解决循环依赖：</p>
<p>一级缓存：单例池，缓存经过了已经初始化完毕的Bean</p>
<p>二级缓存 ：半成品池，缓存还未初始化完毕的Bean</p>
<p>三级缓存：缓存的是获取Bean的代理对象的表达式</p>
<p>我们在创建 A 的过程中，先将 A 放入三级缓存 ，这时要创建B，B要创建A就直接去三级缓存中查找，并且判断需不需要进行 AOP 处理，如果需要就在三级缓存中获取A的代理对象，不需要就取A原始对象。然后将取出的对象放入二级缓存中，这个时候其他需要依赖 A 对象的直接从二级缓存中去获取即可。当B初始化完成进入一级缓存后，A 继续执行生命周期，当A完成了属性的注入后，就可以放入一级缓存了</p>
<p>spring2.6之前默认会解决循环依赖。在spring2.6之后需要通过配置开启解决循环依赖</p>
<h2 id="7-Bean-的作用域"><a href="#7-Bean-的作用域" class="headerlink" title="7.  Bean 的作用域"></a>7.  Bean 的作用域</h2><p>（1）Singleton:一个IOC容器只有一个</p>
<p>（2）Prototype:每次调用getBean()都会生成一个新的对象</p>
<p>（3）request:每个http请求都会创建一个自己的bean</p>
<p>（4）session:同一个session共享一个实例</p>
<p>（5）application:整个serverContext只有一个bean</p>
<p>（6）webSocket:一个websocket只有一个bean</p>
<h2 id="8-Bean-生命周期"><a href="#8-Bean-生命周期" class="headerlink" title="8.  Bean 生命周期"></a>8.  Bean 生命周期</h2><p>实例化 Instantiation-&gt;属性赋值 Populate-&gt;初始化 Initialization-&gt;销毁 Destruction</p>
<p>在这四步的基础上面，Spring 提供了一些拓展点：</p>
<p>*Bean 自身的方法: 包括了 Bean 本身调用的方法和通过配置文件中的 init-method 和 destroy-method 指定的方法</p>
<p>*Bean 级生命周期接口方法:包括了 BeanNameAware、BeanFactoryAware、InitializingBean 和 DiposableBean 这些接口的方法</p>
<p>*容器级生命周期接口方法:包括了 InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</p>
<p>*工厂后处理器接口方法: 包括了 AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer 等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</p>
<h2 id="9-Spring-事务原理？"><a href="#9-Spring-事务原理？" class="headerlink" title="9.  Spring 事务原理？"></a>9.  Spring 事务原理？</h2><p>spring事务有编程式和声明式，我们一般使用声明式，在某个方法上增加@Transactional注解，这个方法中的sql会统一成功或失败。</p>
<p>原理是：</p>
<p>当一个方法加上@Transactional注解，spring会基于这个类生成一个代理对象并将这个代理对象作为bean，当使用这个bean中的方法时，如果存在@Transactional注解，就会将事务自动提交设为false，然后执行方法，执行过程没有异常则提交，有异常则回滚、</p>
<h2 id="10-spring事务失效场景"><a href="#10-spring事务失效场景" class="headerlink" title="10. spring事务失效场景"></a>10. spring事务失效场景</h2><p>（1）事务方法所在的类没有加载到容器中</p>
<p>（2）事务方法不是public类型</p>
<p>（3）同一类中，一个没有添加事务的方法调用另外以一个添加事务的方法，事务不生效</p>
<p>（4）spring事务默认只回滚运行时异常，可以用rollbackfor属性设置</p>
<p>（5）业务自己捕获了异常，事务会认为程序正常秩序</p>
<h2 id="11-spring事务的隔离级别"><a href="#11-spring事务的隔离级别" class="headerlink" title="11. spring事务的隔离级别"></a>11. spring事务的隔离级别</h2><p>default:默认级别，使用数据库自定义的隔离级别</p>
<p>其它四种隔离级别与mysql一样</p>
<h2 id="12-spring事务的传播行为"><a href="#12-spring事务的传播行为" class="headerlink" title="12. spring事务的传播行为"></a>12. spring事务的传播行为</h2><p>（1）支持当前事务，如果不存在，则新启一个事务</p>
<p>（2）支持当前事务，如果不存在，则抛出异常</p>
<p>（3）支持当前事务，如果不存在，则以非事务方式执行</p>
<p>（4）不支持当前事务，创建一个新事物</p>
<p>（5）不支持当前事务，如果已存在事务就抛异常</p>
<p>（6）不支持当前事务，始终以非事务方式执行</p>
<h2 id="13-spring用了哪些设计模式"><a href="#13-spring用了哪些设计模式" class="headerlink" title="13. spring用了哪些设计模式"></a>13. spring用了哪些设计模式</h2><p>BeanFactory用了工厂模式，AOP用了动态代理模式，RestTemplate用来模板方法模式，SpringMVC中handlerAdaper用来适配器模式，Spring里的监听器用了观察者模式</p>
<h2 id="14-SpringMV工作原理"><a href="#14-SpringMV工作原理" class="headerlink" title="14. SpringMV工作原理"></a>14. SpringMV工作原理</h2><p>SpringMVC工作过程围绕着前端控制器DispatchServerlet，几个重要组件有HandleMapping（处理器映射器）、HandleAdapter（处理器适配器）、ViewReslover（试图解析器）</p>
<p>工作流程：</p>
<p>（1）DispatchServerlet接收用户请求将请求发送给HandleMapping</p>
<p> （2）HandleMapping根据请求url找到具体的handle和拦截器，返回给DispatchServerlet</p>
<p>（3）DispatchServerlet调用HandleAdapter,HandleAdapter执行具体的controller，并将controller返回的ModelAndView返回给DispatchServler</p>
<p>（4）DispatchServerlet将ModelAndView传给ViewReslover,ViewReslover解析后返回具体view</p>
<p>（5）DispatchServerlet根据view进行视图渲染，返回给用户</p>
<h2 id="15-springboot自动配置原理"><a href="#15-springboot自动配置原理" class="headerlink" title="15. springboot自动配置原理"></a>15. springboot自动配置原理</h2><p>在spring—boot—autoconfigura包下存放了spring内置的自动配置类和spring.factories文件，这个文件中存放了这些配置类的全类名 ；</p>
<p>启动类@SpringbootApplication注解下，有三个关键注解</p>
<p>（1）@springbootConfiguration:表示启动类是一个自动配置类</p>
<p>（2）@CompontScan:扫描启动类所在包下及子包的组件到容器中</p>
<p>（3）@EnableConfigutarion，下面有个子注解@Import会导入上面所说的自动配置类，这些配置类会根据元注解的装配条件生效，生效的类就会被实例化，加载到ioc容器中；这些自动配置类还会通过xxxProperties文件里配置来进行属性设值</p>
<h2 id="16-springboot常用注解"><a href="#16-springboot常用注解" class="headerlink" title="16 .springboot常用注解"></a>16 .springboot常用注解</h2><p>@RestController         ：修饰类，该控制器会返回Json数据 </p>
<p>@RequestMapping(“&#x2F;path”) ：修饰类，该控制器的请求路径</p>
<p>@Autowired             : 修饰属性，按照类型进行依赖注入</p>
<p>@PathVariable           : 修饰参数，将路径值映射到参数上</p>
<p>@ResponseBody         :修饰方法，该方法会返回Json数据</p>
<p>@RequestBody（需要使用Post提交方式） :修饰参数，将Json数据封装到对应参数中</p>
<p>@Controller@Service@Compont: 将类注册到ioc容器</p>
<p>@Transaction：开启事务</p>
<h2 id="16-spring的bean是线程安全的吗？"><a href="#16-spring的bean是线程安全的吗？" class="headerlink" title="16. spring的bean是线程安全的吗？"></a>16. spring的bean是线程安全的吗？</h2><p>spring的默认bean作用域是单例的，单例的bean不是线程安全的，但是开发中大部分的bean都是无状态的，不具备存储功能，比如controller、service、dao，他们不需要保证线程安全。</p>
<p>如果要保证线程安全，可以将bean的作用域改为prototype，比如像Model View。</p>
<p>另外还可以采用ThreadLocal来解决线程安全问题。ThreadLocal为每个线程保存一个副本变量，每个线程只操作自己的副本变量。</p>
<h2 id="17-springcloud主要解决什么问题？"><a href="#17-springcloud主要解决什么问题？" class="headerlink" title="17. springcloud主要解决什么问题？"></a>17. springcloud主要解决什么问题？</h2><p>解决服务之间的通信、容灾、负载平衡、冗余问题，能方便服务集中管理，常用组件有注册中心、配置中心、远程调用。服务熔断、网关</p>
<h2 id="18-CAP理论"><a href="#18-CAP理论" class="headerlink" title="18. CAP理论"></a>18. CAP理论</h2><p>C：一致性，这里指的强一致性，也就是数据更新完，访问任何节点看到的数据完全一致</p>
<p>A：可用性，就是任何没有发生故障的服务必须在规定时间内返回合正确结果</p>
<p>P：容灾性，当网络不稳定时节点之间无法通信，造成分区，这时要保证系统可以继续正常服务。提高容灾性的办法就是把数据分配到每一个节点当中，所以P是分布式系统必须实现的，然后需要在C和A中取舍</p>
<h2 id="19-为什么不能同时保证一致性和可用性呢？"><a href="#19-为什么不能同时保证一致性和可用性呢？" class="headerlink" title="19. 为什么不能同时保证一致性和可用性呢？"></a>19. 为什么不能同时保证一致性和可用性呢？</h2><p>当网络发生故障时，如果要保障数据一致性，那么节点相互间就只能阻塞等待数据真正同步时再返回，就违背可用性了。如果要保证可用性，节点要在有限时间内将结果返回，无法等待其它节点的更新消息，此时返回的数据可能就不是最新数据，就违背了一致性了</p>
<h2 id="20-熔断限流的理解？"><a href="#20-熔断限流的理解？" class="headerlink" title="20. 熔断限流的理解？"></a>20. 熔断限流的理解？</h2><p>SprngCloud中用Hystrix组件来进行降级、熔断、限流</p>
<p>熔断是对于消费者来讲，当对提供者请求时间过久时为了不影响性能就对链接进行熔断，</p>
<p>限流是对于提供者来讲，为了防止某个消费者流量太大，导致其它更重要的消费者请求无法及时处理。限流可用通过拒绝服务、服务降级、消息队列延时处理、限流算法来实现</p>
<h2 id="21-常用限流算法"><a href="#21-常用限流算法" class="headerlink" title="21. 常用限流算法"></a>21. 常用限流算法</h2><p>计数器算法：使用redis的setnx和过期机制实现</p>
<p>漏桶算法：一般使用消息队列来实现，系统以恒定速度处理队列中的请求，当队列满的时候开始拒绝请求。</p>
<p>令牌桶算法：计数器算法和漏桶算法都无法解决突然的大并发，令牌桶算法是预先往桶中放入一定数量token，然后用恒定速度放入token直到桶满为止，所有请求都必须拿到token才能访问系统</p>
<h1 id="六-Redis系列"><a href="#六-Redis系列" class="headerlink" title="六.Redis系列"></a>六.Redis系列</h1><h2 id="1-redis为什么快？"><a href="#1-redis为什么快？" class="headerlink" title="1.  redis为什么快？"></a>1.  redis为什么快？</h2><p>（1）完全基于内存操作</p>
<p>（2）数据结构简单，对数据操作简单</p>
<p>（3）redis执行命令是单线程的，避免了上下文切换带来的性能问题，也不用考虑锁的问题</p>
<p> (4) 采用了非阻塞的io多路复用机制，使用了单线程来处理并发的连接;内部采用的epoll+自己实现的事件分离器</p>
<p>其实Redis不是完全多线程的，在核心的网络模型中是多线程的用来处理并发连接，但是数据的操作都是单线程。Redis坚持单线程是因为Redis是的性能瓶颈是网络延迟而不是CPU，多线程对数据读取不会带来性能提升。</p>
<h2 id="2-redis持久化机制"><a href="#2-redis持久化机制" class="headerlink" title="2.  redis持久化机制"></a>2.  redis持久化机制</h2><p>（1）快照持久化RDB</p>
<p>redis的默认持久化机制，通过父进程fork一个子进程，子进程将redis的数据快照写入一个临时文件，等待持久化完毕后替换上一次的rdb文件。整个过程主进程不进行任何的io操作。持久化策略可以通过save配置单位时间内执行多少次操作触发持久化。所以RDB的优点是保证redis性能最大化，恢复速度数据较快，缺点是可能会丢失两次持久化之间的数据</p>
<p>（2）追加持久化AOF</p>
<p>以日志形式记录每一次的写入和删除操作，策略有每秒同步、每次操作同步、不同步，优点是数据完整性高，缺点是运行效率低，恢复时间长</p>
<h2 id="3-Redis如何实现key的过期删除？"><a href="#3-Redis如何实现key的过期删除？" class="headerlink" title="3.  Redis如何实现key的过期删除？"></a>3.  Redis如何实现key的过期删除？</h2><p>采用的定期过期+惰性过期</p>
<p>定期删除 ：Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。</p>
<p>惰性删除 ：Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。</p>
<h2 id="4-Redis数据类型应用场景"><a href="#4-Redis数据类型应用场景" class="headerlink" title="4.  Redis数据类型应用场景"></a>4.  Redis数据类型应用场景</h2><p>String：可以用来缓存json信息，可以用incr命令实现自增或自减的计数器</p>
<p>Hash：与String一样可以保存json信息</p>
<p>List：可以用来做消息队列，list的pop是原子性操作能一定程度保证线程安全</p>
<p>Set：可以做去重，比如一个用户只能参加一次活动 ;可以做交集求共友</p>
<p>SortSet ：有序的。可以实现排行榜</p>
<h2 id="5-Redis缓存穿透如何解决？"><a href="#5-Redis缓存穿透如何解决？" class="headerlink" title="5.  Redis缓存穿透如何解决？"></a>5.  Redis缓存穿透如何解决？</h2><p>缓存穿透是指频繁请求客户端和缓存中都不存在的数据，缓存永远不生效，请求都到达了数据库。</p>
<p>解决方案：</p>
<p>（1）在接口上做基础校验，比如id&lt;&#x3D;0就拦截</p>
<p>（2）缓存空对象：找不到的数据也缓存起来，并设置过期时间，可能会造成短期不一致</p>
<p>（3）布隆过滤器：在客户端和缓存之间添加一个过滤器，拦截掉一定不存在的数据请求</p>
<h2 id="6-Redis如何解决缓存击穿？"><a href="#6-Redis如何解决缓存击穿？" class="headerlink" title="6.  Redis如何解决缓存击穿？"></a>6.  Redis如何解决缓存击穿？</h2><p>缓存击穿是值一个key非常热点，key在某一瞬间失效，导致大量请求到达数据库</p>
<p>解决方案：</p>
<p>（1）设置热点数据永不过期</p>
<p>（2）给缓存重建的业务加上互斥锁，缺点是性能低</p>
<h2 id="7-Redis如何解决缓存雪崩？"><a href="#7-Redis如何解决缓存雪崩？" class="headerlink" title="7.  Redis如何解决缓存雪崩？"></a>7.  Redis如何解决缓存雪崩？</h2><p>缓存雪崩是值某一时间Key同时失效或redis宕机，导致大量请求到达数据库</p>
<p>解决方案：</p>
<p>（1）搭建集群保证高可用</p>
<p>（2）进行数据预热，给不同的key设置随机的过期时间</p>
<p>（3）给缓存业务添加限流降级，通过加锁或队列控制操作redis的线程数量</p>
<p>（4）给业务添加多级缓存</p>
<h2 id="8-Redis分布式锁的实现原理"><a href="#8-Redis分布式锁的实现原理" class="headerlink" title="8.  Redis分布式锁的实现原理"></a>8.  Redis分布式锁的实现原理</h2><p>原理是使用setnx+setex命令来实现，但是会有一系列问题：</p>
<p>（1）任务时常超过缓存时间，锁自动释放。可以使用Redision看门狗解决</p>
<p>（2）加锁和释放锁的不是同一线程。可以在Value中存入uuid，删除时进行验证。但是要注意验证锁和删除锁也不是一个原子性操作，可以用lua脚本使之成为原子性操作</p>
<p>（3）不可重入。可以使用Redision解决（实现机制类似AQS,计数）</p>
<p>（4）redis集群下主节点宕机导致锁丢失。使用红锁解决</p>
<h2 id="9-Redis集群方案"><a href="#9-Redis集群方案" class="headerlink" title="9.  Redis集群方案"></a>9.  Redis集群方案</h2><p>(1)主从模式：个master节点，多个slave节点，master节点宕机slave自动变成主节点</p>
<p>(2)哨兵模式：在主从集群基础上添加哨兵节点或哨兵集群，用于监控master节点健康状态，通过投票机制选择slave成为主节点</p>
<p>(3)分片集群：主从模式和哨兵模式解决了并发读的问题，但没有解决并发写的问题，因此有了分片集群。分片集群有多个master节点并且不同master保存不同的数据，master之间通过ping相互监测健康状态。客户端请求任意一个节点都会转发到正确节点，因为每个master都被映射到0-16384个插槽上，集群的key是根据key的hash值与插槽绑定</p>
<h2 id="10-Redis集群主从同步原理"><a href="#10-Redis集群主从同步原理" class="headerlink" title="10. Redis集群主从同步原理"></a>10. Redis集群主从同步原理</h2><p>主从同步第一次是全量同步：slave第一次请求master节点会根据replid判断是否是第一次同步，是的话master会生成RDB发送给slave。</p>
<p>后续为增量同步：在发送RDB期间，会产生一个缓存区间记录发送RDB期间产生的新的命令,slave节点在加载完后，会持续读取缓存区间中的数据</p>
<h2 id="11-Redis缓存一致性解决方案"><a href="#11-Redis缓存一致性解决方案" class="headerlink" title="11. Redis缓存一致性解决方案"></a>11. Redis缓存一致性解决方案</h2><p>Redis缓存一致性解决方案主要思考的是删除缓存和更新数据库的先后顺序</p>
<p>先删除缓存后更新数据库存在的问题是可能会数据不一致，一般使用延时双删来解决，即先删除缓存，再更新数据库，休眠X秒后再次淘汰缓存。第二次删除可能导致吞吐率降低，可以考虑进行异步删除。</p>
<p>先更新数据库后删除缓存存在的问题是会可能会更新失败，可以采用延时删除。但由于读比写快，发生这一情况概率较小。</p>
<p>但是无论哪种策略，都可能存在删除失败的问题，解决方案是用中间件canal订阅binlog日志提取需要删除的key，然后另写一段非业务代码去获取key并尝试删除，若删除失败就把删除失败的key发送到消息队列，然后进行删除重试。</p>
<h2 id="12-Redis内存淘汰策略"><a href="#12-Redis内存淘汰策略" class="headerlink" title="12. Redis内存淘汰策略"></a>12. Redis内存淘汰策略</h2><p>当内存不足时按设定好的策略进行淘汰，策略有(1)淘汰最久没使用的（2）淘汰一段时间内最少使用的（3）淘汰快要过期的</p>
<h1 id="八、场景题"><a href="#八、场景题" class="headerlink" title="八、场景题"></a>八、场景题</h1><h2 id="1-Java如何实现统计在线人数的功能？"><a href="#1-Java如何实现统计在线人数的功能？" class="headerlink" title="1. Java如何实现统计在线人数的功能？"></a>1. Java如何实现统计在线人数的功能？</h2><p>博主写了另外一篇文章：<a target="_blank" rel="noopener" href="http://t.csdn.cn/Q1S4h">http://t.csdn.cn/Q1S4h</a></p>
<h2 id="2-电商网站可以分成哪些模块（或订单模块要完成哪些功能）？"><a href="#2-电商网站可以分成哪些模块（或订单模块要完成哪些功能）？" class="headerlink" title="2. 电商网站可以分成哪些模块（或订单模块要完成哪些功能）？"></a>2. 电商网站可以分成哪些模块（或订单模块要完成哪些功能）？</h2><p>用户模块（用户账户、会员等级、收货信息）、订单模块（订单编号、类型信息、状态信息、时间信息等）、商品模块（店铺信息、数量、价格等）、支付模块（支付方式、支付时间、支付单号等）、物流模块（物流公司、物流单号、物流状态等）</p>
<h1 id="九-其他（RabitMQ、数据结构与算法、nginx、git、jwt登录等…）"><a href="#九-其他（RabitMQ、数据结构与算法、nginx、git、jwt登录等…）" class="headerlink" title="九.其他（RabitMQ、数据结构与算法、nginx、git、jwt登录等…）"></a>九.其他（RabitMQ、数据结构与算法、nginx、git、jwt登录等…）</h1><h2 id="1-RabbitMQ如何保证消息不丢失？"><a href="#1-RabbitMQ如何保证消息不丢失？" class="headerlink" title="1.  RabbitMQ如何保证消息不丢失？"></a>1.  RabbitMQ如何保证消息不丢失？</h2><p>发送端：</p>
<p>（1）创建一个消息状态表，开启RabbitMQ的confirm机制，当收到MQ回传的ACK以更新消息状态</p>
<p>（2）开启定时任务，隔断时间重新发送状态表中超时的任务，多次投递失败进行报警。</p>
<p>消费端：</p>
<p>（1）为了避免消息重复消费，要增加一张消息处理表，消费者拿到消息时判断消息处理表中当前消息是否已经存在，已经存在就抛弃，不存在就进行消费并放入记录表，消费和放入记录表要放在一个事务当中。</p>
<p>（2）开启手动ack模式，在消费者处理完业务后才返回ACK，避免消息还没有处理完就ACK。</p>
<p> 具体可以看博主另外一篇文章：(152条消息) RabbitMQ消息丢失的场景，如何保证消息不丢失？（详细讲解，一文看懂）_十八岁讨厌Java的博客-CSDN博客</p>
<h2 id="2-RabbitMQ如何保证消费顺序"><a href="#2-RabbitMQ如何保证消费顺序" class="headerlink" title="2.  RabbitMQ如何保证消费顺序"></a>2.  RabbitMQ如何保证消费顺序</h2><p>RabbitMQ消费顺序乱了是因为消费者集群拿到消息后对消息处理速度不同导致的，比如可能将增删改变成了增改删。</p>
<p>解决方法：为RabbitMQ创建多个Queue,每个消费者只监听其中一个Queue,同一类型的消息都放在一个queue中，同一个 queue 的消息是一定会保证有序的。</p>
<h2 id="3-设计模式六大原则"><a href="#3-设计模式六大原则" class="headerlink" title="3.  设计模式六大原则"></a>3.  设计模式六大原则</h2><p>（1）单一职责原则：一个类或者一个方法只负责一项职责，尽量做到类只有一个行为引起变化；</p>
<p>（2）里氏替换原则：子类可以扩展父类的功能，但不能改变原有父类的功能</p>
<p>（3）依赖倒置原则：高层模块不应该依赖底层模块，两者都应该依赖接口或抽象类</p>
<p>（4）接口隔离原则：建立单一接口，尽量细化接口</p>
<p>（5）迪米特原则：只关心其它对象能提供哪些方法，不关心过多内部细节</p>
<p>（6）开闭原则：对于拓展是开放，对于修改是封闭的</p>
<h2 id="4-设计模式分类"><a href="#4-设计模式分类" class="headerlink" title="4.  设计模式分类"></a>4.  设计模式分类</h2><p>创建型模式：主要是描述对象的创建，代表有单例、原型模式、工厂方法、抽象工厂、建造者模式</p>
<p>结构型模式：主要描述如何将类或对象按某种布局构成更大的结构，代表有代理、适配器、装饰</p>
<p>行为型模式：描述类或对象之间如何相互协作共同完成单个对象无法完成的任务，代表有模板方法模式、策略模式、观察者模式、备忘录模式</p>
<h2 id="5-排序算法的时间复杂度"><a href="#5-排序算法的时间复杂度" class="headerlink" title="5.  排序算法的时间复杂度"></a>5.  排序算法的时间复杂度</h2><p>交换排序：冒泡排序（n^2,稳定）,快速排序(nlogn，不稳定)</p>
<p>选择排序：直接选择排序（n^2,不稳定），堆排序(nlogn,不稳定s)，</p>
<p>插入排序：直接插入排序（n^2,稳定），希尔排序(N^1.25，不稳定)</p>
<p>归并排序(nlogn，稳定)</p>
<h2 id="6-大量数据排名，采用什么数据结构"><a href="#6-大量数据排名，采用什么数据结构" class="headerlink" title="6.  大量数据排名，采用什么数据结构"></a>6.  大量数据排名，采用什么数据结构</h2><p>当数据很大时，并且有序程度低时，堆排序最快;当数据很大时，并且有序程度高时，快速排序最快</p>
<h2 id="7-二叉树和堆之间联系或区别"><a href="#7-二叉树和堆之间联系或区别" class="headerlink" title="7.  二叉树和堆之间联系或区别"></a>7.  二叉树和堆之间联系或区别</h2><p>堆是一种特殊的二叉树，所有父结点都比子结点要小的完全二叉树我们称为最小堆，所有父结点都比子结点要大，这样的完全二叉树称为最大堆。</p>
<h2 id="8-平衡二叉树不平衡如何调整？"><a href="#8-平衡二叉树不平衡如何调整？" class="headerlink" title="8.  平衡二叉树不平衡如何调整？"></a>8.  平衡二叉树不平衡如何调整？</h2><p>按照不平衡的情况有四种调整方法，分别是LR、RL、LL、RR调整</p>
<p>当不平衡的子树以当前节点为第一个节点往下再数到第三个节点的路径是先左再右时使用LR调整，LR是先将第二个节点旋转到第三个节点的左边，将第一个节点移动到第三个节点的右边；</p>
<p>RL与LR相反，RR是把第一个节点移到第三个节点左边，RR与LL相反</p>
<h2 id="9-hash表冲突的解决方法"><a href="#9-hash表冲突的解决方法" class="headerlink" title="9.  hash表冲突的解决方法"></a>9.  hash表冲突的解决方法</h2><p>开放地址法：有线性探测法和平方探测法，当发生冲突时，继续往后找</p>
<p>再哈希法：构造多个哈希函数，发生冲突后使用下一个函数</p>
<p>链地址法：将hash值相同的记录用链表链接起来</p>
<p>建立公共溢出区：将哈希表分为基础表和益处表两部分，发生冲突的填入益处表</p>
<h2 id="10-cookie和session的联系"><a href="#10-cookie和session的联系" class="headerlink" title="10. cookie和session的联系"></a>10. cookie和session的联系</h2><p>因为http协议是无状态的，无法识别两次请求是否来自同一个客户端，于是就有了cookie和session的概念。</p>
<p>cookies:是存放在客户浏览器中，每次http请求都会携带，可以用来告知服务端两个请求是否来自同一浏览器，cookied的单个数据大小和存储个数是有限制的，不同浏览器限制不同，cookie的安全性较低。</p>
<p>session：当客户端第一次请求服务器时服务器为这个请求分配的一块区域，的存储结构为ConcurrentHashMap，服务器会将sessionId返回给客户端并存入cookie。相比cookie他的安全性更高，但失效时间较短</p>
<p>接下来客户端每次请求带着cookie，服务端会从中获取sessionId来进行匹配，用这套机制就实现了服务器和客户端进行有记忆的对话。</p>
<h2 id="11-Nginx反向代理是什么，负载均衡算法有哪些？"><a href="#11-Nginx反向代理是什么，负载均衡算法有哪些？" class="headerlink" title="11. Nginx反向代理是什么，负载均衡算法有哪些？"></a>11. Nginx反向代理是什么，负载均衡算法有哪些？</h2><p>反向代理是用来代理服务器接收请求的，然后将请求转发给内部网络的服务器，并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。</p>
<p>负载均衡算法有：轮询（默认）、带权轮询、ip_hash（按ip哈希结果分配，能解决session共享问题）、url_hash(按访问的URL的哈希结果分配)、fair（根据服务端响应时间分配，响应时间短优先）</p>
<h1 id="九、秒杀项目相关问题："><a href="#九、秒杀项目相关问题：" class="headerlink" title="九、秒杀项目相关问题："></a>九、秒杀项目相关问题：</h1><h2 id="1-项目流程"><a href="#1-项目流程" class="headerlink" title="1.  项目流程"></a>1.  项目流程</h2><p>​    用户点击下单按钮时，进行三次判断：先判断请求路径是否合法,因为做了动态URL；再判断用户是否已经下单过，就是看redis缓存中有没有用户下单信息；最后判断库存，这里进行了redis库存预减，由于判断库存和预减库存不是原子性操作，所以用lua脚本来执行这一段代码。然后从这里开始使用分布式锁，锁id为用户id+商品id,防止一个用户发送多次请求让redis多次预减。</p>
<p>   Redis扣减成功后，进行异步下单，直接将正在处理返回给前端，将用户id和商品Id发送RabbitMQ中，负责下单的业务会从消息队列中拿出消息，去执行以下操作：</p>
<p>1.减库存，减库存时用where 库存&gt;0防止超卖</p>
<p>2.订单表中生成记录，订单表中的用户id和商品id添加了联合唯一索引防止超卖</p>
<p> 减库存和增加订单放在一个事务内保证一致性</p>
<p>3.将用户id和订单id缓存到redis中用来最初对用户重复下单的判断</p>
<p>4.释放分布式锁，根据value去判断锁是不是当前线程的，判断和删除锁不是原子性操作，所以封装到了lua脚本中</p>
<ol start="2">
<li>提升qps的操作</li>
</ol>
<p>（1）页面动静分离，静态页面缓存到redis</p>
<p>（2）分布式锁拦截不同用户的重复</p>
<p>（3）限流算法</p>
<p>（4）验证码限流</p>
<p>（5）rabbitMq流量削峰</p>
<p>（6）接口隐藏</p>
<p>微学院相关问题</p>
<p>1.如何用springSecurity做的认证授权？</p>
<p>在数据库中有五张表，分别是菜单表，角色表，用户表，他们是多对多的关系，所以还有角色菜单表，角色用户表</p>
<p>登录后进入认证过滤器，获取用户名和密码，根据用户名查询用户具有的权限并把用户名和对应权限信息放到redis，JWT生成token后放入cookie,每次调用接口时携带</p>
<p>然后执行授权过滤器,从header中获取token解析出用户名，根据用户名从redis中获取权限列表，然后springSecurity就能够判断当前请求是否有权限访问</p>
<p>2.前后端联调经常遇到的问题：</p>
<p>1.请求方式不匹配</p>
<p>2.json、x-wwww-form-urlencoded混乱的错误</p>
<p>3.前后端参数不一致，空指针异常，数据类型不匹配</p>
<p>4.mp生成的分布式id是19位，JavsScrip只会处理16位，将id生成策略改为String类型</p>
<p>5.跨域问题：跨域问题是在访问协议、ip地址、端口号这三个有任何一个不一样，相互访问就会出现跨域，可以通过Spring注解解决跨域的 @CrossOrigin，也可以使用nginx反向代理、网关</p>
<p>6.maven加载项目时，默认不会加载src-java文件夹的xml类型文件，可以 将xml放到resources文件夹下，也可以在yaml和pom中添加配置 </p>
</article><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/./image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/05/16/%E5%85%AB%E8%82%A1%E6%96%87%E9%9D%A2%E8%AF%95%E9%A2%98/" title="八股文面试题"><img class="cover" src="/./image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">八股文面试题</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./image/HeadPic/w.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Awei</div><div class="author-info__description">去码头上整点薯条！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn"><i class="fab fa-github"></i><span>这可能是个链接</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">其实没啥公告的</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81java%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">一、java基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">1.  接口和抽象类的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">2.  重载和重写的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-equals%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.</span> <span class="toc-text">3.  equals和&#x3D;&#x3D;的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">4.  异常处理机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-HashMap%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">5.  HashMap原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%83%B3%E8%A6%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84HashMap%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">6.  想要线程安全的HashMap怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-ConcurrentHashMap%E5%8E%9F%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">7.  ConcurrentHashMap原如何保证的线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-HashTable%E4%B8%8EHashMap%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.8.</span> <span class="toc-text">8.  HashTable与HashMap的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-ArrayList%E5%92%8CLinkedList%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.9.</span> <span class="toc-text">9.  ArrayList和LinkedList的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81ArrayList%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">10. 如何保证ArrayList的线程安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.</span> <span class="toc-text">11. String、StringBuffer、StringBuilder的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-hashCode%E5%92%8Cequals"><span class="toc-number">1.12.</span> <span class="toc-text">12. hashCode和equals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.</span> <span class="toc-text">13. 面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.14.</span> <span class="toc-text">14.深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.15.</span> <span class="toc-text">14. 多态的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">15. 什么是反射？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%BE%97%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">1.17.</span> <span class="toc-text">16. Java创建对象得五种方式?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">二.Java多线程篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.</span> <span class="toc-text">1.  进程和线程的区别，进程间如何通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">2.2.</span> <span class="toc-text">2.  什么是线程上下文切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="toc-number">2.3.</span> <span class="toc-text">3.  什么是死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.4.</span> <span class="toc-text">4.  死锁的必要条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Synchrpnized%E5%92%8Clock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text">5.  Synchrpnized和lock的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AFAQS%E9%94%81"><span class="toc-number">2.6.</span> <span class="toc-text">6.  什么是AQS锁?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%B8%BA%E4%BB%80%E4%B9%88AQS%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">7.为什么AQS使用的双向链表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84AQS%E9%94%81"><span class="toc-number">2.8.</span> <span class="toc-text">7.  有哪些常见的AQS锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-sleep-%E5%92%8Cwait-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.</span> <span class="toc-text">9.sleep()和wait()的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-yield-%E5%92%8Cjoin-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.10.</span> <span class="toc-text">10. yield()和join()区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%83%E5%A4%A7%E5%8F%82%E6%95%B0"><span class="toc-number">2.11.</span> <span class="toc-text">11. 线程池七大参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.12.</span> <span class="toc-text">12. Java内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">13. 保证并发安全的三大特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-Volatile"><span class="toc-number">2.14.</span> <span class="toc-text">14. Volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">2.15.</span> <span class="toc-text">15. 线程使用方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-ThreadLocal%E5%8E%9F%E7%90%86"><span class="toc-number">2.16.</span> <span class="toc-text">16. ThreadLocal原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E4%BB%80%E4%B9%88%E6%98%AFCAS%E9%94%81"><span class="toc-number">2.17.</span> <span class="toc-text">17. 什么是CAS锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-Synchronized%E9%94%81%E5%8E%9F%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-number">2.18.</span> <span class="toc-text">18. Synchronized锁原理和优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE-CPU-%E6%A0%B8%E5%BF%83%E6%95%B0%E8%AE%BE%E8%AE%A1%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="toc-number">2.19.</span> <span class="toc-text">19. 如何根据 CPU 核心数设计线程池线程数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-AtomicInteger%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.20.</span> <span class="toc-text">20. AtomicInteger的使用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-JVM%E7%AF%87"><span class="toc-number">3.</span> <span class="toc-text">三.JVM篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%EF%BC%88%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">1.  JVM运行时数据区（内存结构）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">2.  什么情况下会内存溢出？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-JVM%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">3.  JVM有哪些垃圾回收算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-GC%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">4.  GC如何判断对象可以被回收？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%85%B8%E5%9E%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">5.  典型垃圾回收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%92%8C%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">3.6.</span> <span class="toc-text">6.  类加载器和双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-JVM%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">7.  JVM中有哪些引用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">3.8.</span> <span class="toc-text">8.  类加载过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-JVM%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.9.</span> <span class="toc-text">9.  JVM类初始化顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">3.10.</span> <span class="toc-text">10. 对象的创建过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%AF%B9%E8%B1%A1%E5%A4%B4%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BF%A1%E6%81%AF"><span class="toc-number">3.11.</span> <span class="toc-text">11. 对象头中有哪些信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-JVM%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0"><span class="toc-number">3.12.</span> <span class="toc-text">12. JVM内存参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-GC%E7%9A%84%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">3.13.</span> <span class="toc-text">13. GC的回收机制和原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-Mysql%E7%AF%87"><span class="toc-number">4.</span> <span class="toc-text">四.Mysql篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-MyIsAm%E5%92%8CInnoDB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">1.  MyIsAm和InnoDB的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-mysql%E4%BA%8B%E5%8A%A1%E7%89%B9%E6%80%A7"><span class="toc-number">4.2.</span> <span class="toc-text">2.  mysql事务特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%8B%E5%8A%A1%E9%9D%A0%E4%BB%80%E4%B9%88%E4%BF%9D%E8%AF%81"><span class="toc-number">4.3.</span> <span class="toc-text">3.  事务靠什么保证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">4.4.</span> <span class="toc-text">4.  事务的隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%92%8C%E5%BD%93%E5%89%8D%E8%AF%BB"><span class="toc-number">4.5.</span> <span class="toc-text">5.  什么是快照读和当前读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-MVCC%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.6.</span> <span class="toc-text">6.  MVCC是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B4%A2%E5%BC%95"><span class="toc-number">4.7.</span> <span class="toc-text">7.  MySQL有哪些索引</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.8.</span> <span class="toc-text">8.  聚簇索引和非聚簇索引的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-MySQL%E5%A6%82%E4%BD%95%E5%81%9A%E6%85%A2SQL%E4%BC%98%E5%8C%96"><span class="toc-number">4.9.</span> <span class="toc-text">9.  MySQL如何做慢SQL优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%86%85%E8%BF%9E%E6%8E%A5%E8%80%8C%E4%B8%8D%E7%94%A8%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">4.10.</span> <span class="toc-text">10. 为什么要用内连接而不用外连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-MySQL%E6%95%B4%E4%B8%AA%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">4.11.</span> <span class="toc-text">11. MySQL整个查询的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%EF%BC%9F"><span class="toc-number">4.12.</span> <span class="toc-text">12. 执行计划中有哪些字段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="toc-number">4.13.</span> <span class="toc-text">13. 哪些情况索引会失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-B%E5%92%8CB-%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%95%B0"><span class="toc-number">4.14.</span> <span class="toc-text">14. B和B+数的区别，为什么使用B+数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-MySQL%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81"><span class="toc-number">4.15.</span> <span class="toc-text">15. MySQL有哪些锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-Mysql%E5%86%85%E8%BF%9E%E6%8E%A5%E3%80%81%E5%B7%A6%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%B3%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.16.</span> <span class="toc-text">16. Mysql内连接、左连接、右连接的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-sql%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.17.</span> <span class="toc-text">17. sql执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9F"><span class="toc-number">4.18.</span> <span class="toc-text">18. 如何设计数据库？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-where%E5%92%8Chaving%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.19.</span> <span class="toc-text">19. where和having的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">4.20.</span> <span class="toc-text">20. 三大范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-char%E5%92%8Cvarchar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.21.</span> <span class="toc-text">21. char和varchar的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-InnoDB-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81"><span class="toc-number">4.22.</span> <span class="toc-text">22. InnoDB 什么情况下会产生死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-MySQL-%E5%88%A0%E9%99%A4%E8%87%AA%E5%A2%9E-id%EF%BC%8C%E9%9A%8F%E5%90%8E%E9%87%8D%E5%90%AF-MySQL-%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%86%8D%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%87%AA%E5%A2%9E-id-%E4%BC%9A%E4%BB%8E%E5%87%A0%E5%BC%80%E5%A7%8B%EF%BC%9F"><span class="toc-number">4.23.</span> <span class="toc-text">23. MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-MySQL%E6%8F%92%E5%85%A5%E7%99%BE%E4%B8%87%E7%BA%A7%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">4.24.</span> <span class="toc-text">24. MySQL插入百万级的数据如何优化？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94-%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E7%B3%BB%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">五.常用开发框架系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AFSpring%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">1.  什么是Spring？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-IOC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">2.  IOC是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-AOP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">3.  AOP是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%B1%BB%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">4.  如何定义一个全局异常处理类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8aop%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">5.  如何使用aop自定义日志？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F"><span class="toc-number">5.6.</span> <span class="toc-text">6.  循环依赖是什么，怎么解决的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.7.</span> <span class="toc-text">7.  Bean 的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Bean-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.8.</span> <span class="toc-text">8.  Bean 生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Spring-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">5.9.</span> <span class="toc-text">9.  Spring 事务原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="toc-number">5.10.</span> <span class="toc-text">10. spring事务失效场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">5.11.</span> <span class="toc-text">11. spring事务的隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-spring%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA"><span class="toc-number">5.12.</span> <span class="toc-text">12. spring事务的传播行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-spring%E7%94%A8%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.13.</span> <span class="toc-text">13. spring用了哪些设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-SpringMV%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.14.</span> <span class="toc-text">14. SpringMV工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-springboot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86"><span class="toc-number">5.15.</span> <span class="toc-text">15. springboot自动配置原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-springboot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.16.</span> <span class="toc-text">16 .springboot常用注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-spring%E7%9A%84bean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">5.17.</span> <span class="toc-text">16. spring的bean是线程安全的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-springcloud%E4%B8%BB%E8%A6%81%E8%A7%A3%E5%86%B3%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">5.18.</span> <span class="toc-text">17. springcloud主要解决什么问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-CAP%E7%90%86%E8%AE%BA"><span class="toc-number">5.19.</span> <span class="toc-text">18. CAP理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%90%8C%E6%97%B6%E4%BF%9D%E8%AF%81%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%8F%AF%E7%94%A8%E6%80%A7%E5%91%A2%EF%BC%9F"><span class="toc-number">5.20.</span> <span class="toc-text">19. 为什么不能同时保证一致性和可用性呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E7%86%94%E6%96%AD%E9%99%90%E6%B5%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">5.21.</span> <span class="toc-text">20. 熔断限流的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%B8%B8%E7%94%A8%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95"><span class="toc-number">5.22.</span> <span class="toc-text">21. 常用限流算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD-Redis%E7%B3%BB%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">六.Redis系列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">1.  redis为什么快？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.</span> <span class="toc-text">2.  redis持久化机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Redis%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0key%E7%9A%84%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">3.  Redis如何实现key的过期删除？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.4.</span> <span class="toc-text">4.  Redis数据类型应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">5.  Redis缓存穿透如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Redis%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F"><span class="toc-number">6.6.</span> <span class="toc-text">6.  Redis如何解决缓存击穿？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Redis%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F"><span class="toc-number">6.7.</span> <span class="toc-text">7.  Redis如何解决缓存雪崩？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">6.8.</span> <span class="toc-text">8.  Redis分布式锁的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-Redis%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88"><span class="toc-number">6.9.</span> <span class="toc-text">9.  Redis集群方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-Redis%E9%9B%86%E7%BE%A4%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="toc-number">6.10.</span> <span class="toc-text">10. Redis集群主从同步原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Redis%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">6.11.</span> <span class="toc-text">11. Redis缓存一致性解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">6.12.</span> <span class="toc-text">12. Redis内存淘汰策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%9C%BA%E6%99%AF%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">八、场景题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Java%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BB%9F%E8%AE%A1%E5%9C%A8%E7%BA%BF%E4%BA%BA%E6%95%B0%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">1. Java如何实现统计在线人数的功能？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E5%8F%AF%E4%BB%A5%E5%88%86%E6%88%90%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%9D%97%EF%BC%88%E6%88%96%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97%E8%A6%81%E5%AE%8C%E6%88%90%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD%EF%BC%89%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">2. 电商网站可以分成哪些模块（或订单模块要完成哪些功能）？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D-%E5%85%B6%E4%BB%96%EF%BC%88RabitMQ%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E3%80%81nginx%E3%80%81git%E3%80%81jwt%E7%99%BB%E5%BD%95%E7%AD%89%E2%80%A6%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">九.其他（RabitMQ、数据结构与算法、nginx、git、jwt登录等…）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">1.  RabbitMQ如何保证消息不丢失？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-RabbitMQ%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E8%B4%B9%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.2.</span> <span class="toc-text">2.  RabbitMQ如何保证消费顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">8.3.</span> <span class="toc-text">3.  设计模式六大原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">8.4.</span> <span class="toc-text">4.  设计模式分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">8.5.</span> <span class="toc-text">5.  排序算法的时间复杂度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%8E%92%E5%90%8D%EF%BC%8C%E9%87%87%E7%94%A8%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">8.6.</span> <span class="toc-text">6.  大量数据排名，采用什么数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%92%8C%E5%A0%86%E4%B9%8B%E9%97%B4%E8%81%94%E7%B3%BB%E6%88%96%E5%8C%BA%E5%88%AB"><span class="toc-number">8.7.</span> <span class="toc-text">7.  二叉树和堆之间联系或区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8D%E5%B9%B3%E8%A1%A1%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%EF%BC%9F"><span class="toc-number">8.8.</span> <span class="toc-text">8.  平衡二叉树不平衡如何调整？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-hash%E8%A1%A8%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">8.9.</span> <span class="toc-text">9.  hash表冲突的解决方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-cookie%E5%92%8Csession%E7%9A%84%E8%81%94%E7%B3%BB"><span class="toc-number">8.10.</span> <span class="toc-text">10. cookie和session的联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">8.11.</span> <span class="toc-text">11. Nginx反向代理是什么，负载均衡算法有哪些？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">9.</span> <span class="toc-text">九、秒杀项目相关问题：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">9.1.</span> <span class="toc-text">1.  项目流程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/05/23/%E5%85%AB%E8%82%A1%E6%96%87/" title="八股文"><img src="/./image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="八股文"/></a><div class="content"><a class="title" href="/2024/05/23/%E5%85%AB%E8%82%A1%E6%96%87/" title="八股文">八股文</a><time datetime="2024-05-23T08:31:21.526Z" title="发表于 2024-05-23 16:31:21">2024-05-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/16/%E5%85%AB%E8%82%A1%E6%96%87%E9%9D%A2%E8%AF%95%E9%A2%98/" title="八股文面试题"><img src="/./image/HeadPic/%E6%9D%BF%E9%B8%AD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="八股文面试题"/></a><div class="content"><a class="title" href="/2024/05/16/%E5%85%AB%E8%82%A1%E6%96%87%E9%9D%A2%E8%AF%95%E9%A2%98/" title="八股文面试题">八股文面试题</a><time datetime="2024-05-16T04:20:57.179Z" title="发表于 2024-05-16 12:20:57">2024-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/15/Java%E5%9F%BA%E7%A1%80/" title="Java基础-笔记"><img src="/./image/HeadPic/%E5%8F%AF%E8%8E%89.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java基础-笔记"/></a><div class="content"><a class="title" href="/2024/04/15/Java%E5%9F%BA%E7%A1%80/" title="Java基础-笔记">Java基础-笔记</a><time datetime="2024-04-15T08:18:02.220Z" title="发表于 2024-04-15 16:18:02">2024-04-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/13/Spring5/" title="Spring5-笔记"><img src="/./image/HeadPic/%E4%B8%83%E4%B8%83.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring5-笔记"/></a><div class="content"><a class="title" href="/2024/04/13/Spring5/" title="Spring5-笔记">Spring5-笔记</a><time datetime="2024-04-13T15:46:00.287Z" title="发表于 2024-04-13 23:46:00">2024-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/04/10/MyBatis/" title="MyBatis-笔记"><img src="/./image/HeadPic/%E7%94%B3%E9%B9%A4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis-笔记"/></a><div class="content"><a class="title" href="/2024/04/10/MyBatis/" title="MyBatis-笔记">MyBatis-笔记</a><time datetime="2024-04-10T01:33:16.980Z" title="发表于 2024-04-10 09:33:16">2024-04-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Awei</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">常看，勤改</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>